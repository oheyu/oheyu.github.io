<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Linux的IO复用之select | 史玉浩的个人博客</title>
<meta name="keywords" content="Linux">
<meta name="description" content="select() 函数作为一种经典的多路复用机制，在处理多个文件描述符（如套接字）时扮演着重要角色。虽然已经过时，但对于我们进一步了解其他复用有极大的帮助。">
<meta name="author" content="史玉浩">
<link rel="canonical" href="https://oheyu.github.io/zh/posts/tech/linux%E7%9A%84io%E5%A4%8D%E7%94%A8%E4%B9%8Bselect/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.9c78afd72529c14d4d3c0fa583c3e82265e0d8a303d475223d3b37442260ba22.css" integrity="sha256-nHiv1yUpwU1NPA&#43;lg8PoImXg2KMD1HUiPTs3RCJguiI=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://oheyu.github.io/img/logo.svg">
<link rel="icon" type="image/png" sizes="16x16" href="https://oheyu.github.io/img/logo.svg">
<link rel="icon" type="image/png" sizes="32x32" href="https://oheyu.github.io/img/logo.svg">
<link rel="apple-touch-icon" href="https://oheyu.github.io/logo.svg">
<link rel="mask-icon" href="https://oheyu.github.io/logo.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://oheyu.github.io/zh/posts/tech/linux%E7%9A%84io%E5%A4%8D%E7%94%A8%E4%B9%8Bselect/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

  

<meta property="og:title" content="Linux的IO复用之select" />
<meta property="og:description" content="select() 函数作为一种经典的多路复用机制，在处理多个文件描述符（如套接字）时扮演着重要角色。虽然已经过时，但对于我们进一步了解其他复用有极大的帮助。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://oheyu.github.io/zh/posts/tech/linux%E7%9A%84io%E5%A4%8D%E7%94%A8%E4%B9%8Bselect/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-19T20:19:02+08:00" />
<meta property="article:modified_time" content="2024-03-19T20:19:02+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux的IO复用之select"/>
<meta name="twitter:description" content="select() 函数作为一种经典的多路复用机制，在处理多个文件描述符（如套接字）时扮演着重要角色。虽然已经过时，但对于我们进一步了解其他复用有极大的帮助。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 文章",
      "item": "https://oheyu.github.io/zh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "👨🏻‍💻 技术",
      "item": "https://oheyu.github.io/zh/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Linux的IO复用之select",
      "item": "https://oheyu.github.io/zh/posts/tech/linux%E7%9A%84io%E5%A4%8D%E7%94%A8%E4%B9%8Bselect/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux的IO复用之select",
  "name": "Linux的IO复用之select",
  "description": "select() 函数作为一种经典的多路复用机制，在处理多个文件描述符（如套接字）时扮演着重要角色。虽然已经过时，但对于我们进一步了解其他复用有极大的帮助。",
  "keywords": [
    "Linux"
  ],
  "articleBody": "\rselect() 函数作为一种经典的多路复用机制，在处理多个文件描述符（如套接字）时扮演着重要角色。虽然已经过时，但对于我们进一步了解其他复用有极大的帮助。\n一、什么是 select() 函数？ select() 是一个系统调用，位于 POSIX 标准中，主要用于监视多个文件描述符，以检测哪些文件描述符准备好进行 I/O 操作（如读、写或发生异常）。它允许程序在单个线程或进程中同时处理多个 I/O 事件，从而实现高效的资源利用。\n1 2 3 #include int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); nfds：需要监视的文件描述符集合中最大文件描述符的值加一。 readfds：指向 fd_set 结构的指针，用于监视可读事件的文件描述符集合。 writefds：指向 fd_set 结构的指针，用于监视可写事件的文件描述符集合。 exceptfds：指向 fd_set 结构的指针，用于监视异常事件的文件描述符集合。 timeout：指向 timeval 结构的指针，指定 select() 函数的超时时间。如果为 NULL，select() 会一直阻塞直到有事件发生。 返回值 正数：表示发生事件的文件描述符数量。 0：表示 select() 超时，没有事件发生。 -1：表示调用失败，错误信息存储在 errno 中。 二、select() 的工作原理 select() 的核心思想是利用文件描述符集合（fd_set）来监视多个文件描述符的状态变化。它通过以下步骤工作：\n初始化文件描述符集合：使用 FD_ZERO 清空集合，使用 FD_SET 将需要监视的文件描述符加入集合。 调用 select()：将准备好的 fd_set 传递给 select()，并指定监视的事件类型（读、写、异常）。 等待事件发生：select() 会阻塞，直到有文件描述符满足指定的事件，或超时时间到达。 处理事件：select() 返回后，遍历文件描述符集合，使用 FD_ISSET 判断哪些文件描述符发生了事件，并进行相应的处理。 注意：select() 会修改传入的 fd_set 集合，仅保留发生事件的文件描述符。因此，在每次调用 select() 前，需要重新初始化或复制原始的 fd_set。\n三、select() 的使用方法 以下是一个基于 select() 的简单 TCP 服务器示例，能够同时处理多个客户端连接，并回显客户端发送的数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 #include #include #include #include #include #include #include #include #define BUFFER_SIZE 1024 // 初始化服务端的监听端口。 int initserver(int port); int main(int argc, char *argv[]) { if (argc != 2) { fprintf(stderr, \"Usage: %s \\n\", argv[0]); return EXIT_FAILURE; } // 初始化服务端用于监听的socket。 int listensock = initserver(atoi(argv[1])); if (listensock \u003c 0) { fprintf(stderr, \"initserver() failed.\\n\"); return EXIT_FAILURE; } printf(\"Listening on socket=%d\\n\", listensock); fd_set readfds; FD_ZERO(\u0026readfds); FD_SET(listensock, \u0026readfds); int maxfd = listensock; while (1) // 事件循环。 { struct timeval timeout; timeout.tv_sec = 10; // 秒 timeout.tv_usec = 0; // 微秒。 fd_set tmpfds = readfds; // 复制 readfds，避免被 select() 修改 // 调用select() 等待事件的发生（监视哪些socket发生了事件)。 int infds = select(maxfd + 1, \u0026tmpfds, NULL, NULL, \u0026timeout); // 如果infds\u003c0，表示调用select()失败。 if (infds \u003c 0) { if (errno == EINTR) { // 被信号中断，继续循环 continue; } perror(\"select() failed\"); break; } // 如果infds==0，表示select()超时。 if (infds == 0) { printf(\"select() timeout.\\n\"); continue; } // 如果infds\u003e0，表示有事件发生，infds存放了已发生事件的个数。 for (int eventfd = 0; eventfd \u003c= maxfd \u0026\u0026 infds \u003e 0; eventfd++) { if (FD_ISSET(eventfd, \u0026tmpfds)) { infds--; // 如果发生事件的是listensock，表示有新的客户端连上来了。 if (eventfd == listensock) { struct sockaddr_in client; socklen_t len = sizeof(client); int clientsock = accept(listensock, (struct sockaddr*)\u0026client, \u0026len); if (clientsock \u003c 0) { perror(\"accept() failed\"); continue; } printf(\"Accepted client(socket=%d) from %s:%d.\\n\", clientsock, inet_ntoa(client.sin_addr), ntohs(client.sin_port)); FD_SET(clientsock, \u0026readfds); // 把新连上来的客户端的标志位置为1。 if (clientsock \u003e maxfd) maxfd = clientsock; // 更新maxfd的值。 } else { // 如果是客户端连接的socket有事件，表示接收缓存中有数据可以读，或者有客户端已断开连接。 char buffer[BUFFER_SIZE]; memset(buffer, 0, sizeof(buffer)); ssize_t bytes_received = recv(eventfd, buffer, sizeof(buffer) - 1, 0); if (bytes_received \u003c= 0) { if (bytes_received == 0) { // 客户端关闭连接 printf(\"Client(socket=%d) disconnected.\\n\", eventfd); } else { perror(\"recv() failed\"); } close(eventfd); // 关闭客户端的socket FD_CLR(eventfd, \u0026readfds); // 把bitmap中已关闭客户端的标志位清空。 if (eventfd == maxfd) // 重新计算maxfd的值，只有当eventfd==maxfd时才需要计算。 { while (FD_ISSET(maxfd, \u0026readfds) == 0 \u0026\u0026 maxfd \u003e listensock) { maxfd--; } } } else { // 如果客户端有报文发过来。 buffer[bytes_received] = '\\0'; // 确保字符串终止 printf(\"Received from socket=%d: %s\\n\", eventfd, buffer); // 把接收到的报文内容原封不动的发回去。 ssize_t bytes_sent = send(eventfd, buffer, bytes_received, 0); if (bytes_sent \u003c 0) { perror(\"send() failed\"); close(eventfd); // 关闭客户端的socket FD_CLR(eventfd, \u0026readfds); // 把bitmap中已关闭客户端的标志位清空。 if (eventfd == maxfd) { while (FD_ISSET(maxfd, \u0026readfds) == 0 \u0026\u0026 maxfd \u003e listensock) { maxfd--; } } } else { printf(\"Echoed back to socket=%d.\\n\", eventfd); } } } } } } close(listensock); // 程序结束前关闭监听socket return 0; } // 初始化服务端的监听端口。 int initserver(int port) { int sock = socket(AF_INET, SOCK_STREAM, 0); if (sock \u003c 0) { perror(\"socket() failed\"); return -1; } int opt = 1; unsigned int len = sizeof(opt); if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, \u0026opt, len) \u003c 0) { perror(\"setsockopt() failed\"); close(sock); return -1; } struct sockaddr_in servaddr; memset(\u0026servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(port); if (bind(sock, (struct sockaddr *)\u0026servaddr, sizeof(servaddr)) \u003c 0) { perror(\"bind() failed\"); close(sock); return -1; } if (listen(sock, 5) != 0) { perror(\"listen() failed\"); close(sock); return -1; } return sock; } 代码详解\n初始化服务器套接字：\n创建套接字：使用 socket(AF_INET, SOCK_STREAM, 0) 创建一个 TCP 套接字。 设置套接字选项：通过 setsockopt 设置 SO_REUSEADDR 选项，允许重用本地地址和端口，避免在服务器重启后出现 bind 失败的情况。 绑定地址和端口：将套接字绑定到指定端口和所有可用接口 (INADDR_ANY)。 监听：将套接字置于监听状态，等待客户端连接。 初始化 fd_set 集合：\n使用 FD_ZERO 清空 readfds 集合。 使用 FD_SET 将监听套接字加入 readfds 集合。 维护一个变量 maxfd，记录当前监视的最大文件描述符值，用于 select() 函数的第一个参数。 事件循环：\n超时设置：定义一个 timeval 结构体，设置 select() 的超时时间为 10 秒。 复制 fd_set：每次调用 select() 前，将原始的 readfds 集合复制到一个临时的 tmpfds 集合，因为 select() 会修改传入的集合。 调用 select()：监视读事件，等待事件发生或超时。 处理事件： 新连接事件：如果监听套接字有事件，调用 accept() 接受新的客户端连接，将新客户端的套接字加入 readfds 集合，并更新 maxfd。 数据接收事件：如果已有客户端套接字有事件，调用 recv() 接收数据。如果 recv() 返回值 \u003c= 0，表示客户端断开连接，关闭套接字并从 readfds 中移除；否则，将接收到的数据回显给客户端。 资源管理：\n在客户端断开连接时，关闭相应的套接字并从 readfds 中移除，防止资源泄漏。 程序结束前，关闭监听套接字，释放资源。 3.1 关键点解析 为什么需要复制 readfds 给 tmpfds select() 函数会修改传入的 fd_set 集合，仅保留发生事件的文件描述符。因此，在每次调用 select() 前，需要将原始的 readfds 复制到一个临时集合 tmpfds，以便在下一次循环中仍能监视所有需要的文件描述符。\n1 2 fd_set tmpfds = readfds; int infds = select(maxfd + 1, \u0026tmpfds, NULL, NULL, \u0026timeout); 否则，如果直接传入 readfds，每次 select() 调用后，readfds 只会包含发生了事件的文件描述符，导致无法继续监视其他套接字。\n维护 maxfd select() 的第一个参数 nfds 需要设置为所有监视的文件描述符中最大的文件描述符值加一。因此，每次有新的客户端连接时，需要更新 maxfd：\n1 if (clientsock \u003e maxfd) maxfd = clientsock; 当有客户端断开连接且该套接字是当前 maxfd 时，需要重新计算新的 maxfd：\n1 2 3 4 5 6 7 if (eventfd == maxfd) { while (FD_ISSET(maxfd, \u0026readfds) == 0 \u0026\u0026 maxfd \u003e listensock) { maxfd--; } } 超时处理 在原始代码中，虽然定义了 timeout，但传入 select() 的参数是 0，表示无限等待。正确的做法是将 \u0026timeout 传入 select()，以实现超时机制。\n1 int infds = select(maxfd + 1, \u0026tmpfds, NULL, NULL, \u0026timeout); 这样，当超过 10 秒没有事件发生时，select() 会返回 0，程序可以根据需要执行相应的操作，如打印超时信息。\n缓冲区安全 在接收数据后，手动添加 null 字符，确保字符串安全，防止缓冲区溢出。\n1 buffer[bytes_received] = '\\0'; // 确保字符串终止 同时，recv() 调用中，使用 sizeof(buffer) - 1 作为接收长度，留出一个字节用于存储 null 字符。\n错误处理 在套接字操作中，合理处理错误情况，如 accept()、recv()、send() 失败时，打印错误信息并采取相应的措施（如关闭套接字、移除集合等），确保程序的健壮性。\n四、select() 的优缺点 优点 简单易用：select() 是一种相对简单的多路复用机制，易于理解和实现。 跨平台支持：select() 在大多数 POSIX 系统（如 Linux、BSD、macOS）和 Windows 平台上都有实现，具有良好的跨平台兼容性。 无需额外库：使用 select() 不需要依赖额外的库，适用于轻量级应用。 缺点 文件描述符数量限制： select() 受限于 FD_SETSIZE（通常为 1024），无法处理大量并发连接。 在高并发场景下，select() 无法满足需求。 性能问题： select() 需要线性扫描所有文件描述符，时间复杂度为 O(n)，在监视大量文件描述符时效率低下。 每次调用 select() 都需要重新设置 fd_set，增加了系统调用的开销。 不支持边缘触发： select() 仅支持水平触发（Level-Triggered），无法像 epoll 支持边缘触发（Edge-Triggered）那样高效处理事件。 可读性与维护性： 随着监视的文件描述符增多，代码的复杂性和可维护性降低。 五、select() 的应用场景 尽管 select() 存在一些限制，但在某些场景下，select() 仍然是一个合适的选择：\n低并发连接： 对于连接数较少的服务器，select() 可以有效管理多个客户端连接，无需担心性能问题。 跨平台应用： 需要在不同操作系统间移植的应用，select() 的广泛支持使其成为首选。 简单的 I/O 多路复用需求： 在需要简单实现 I/O 多路复用功能但不需要处理大量并发连接的情况下，select() 是一种便捷的选择。 嵌入式系统： 资源有限的嵌入式系统中，select() 的轻量级特性使其适用于简单的网络通信任务。 六、select() 的替代方案 随着网络应用的发展，出现了多种替代 select() 的多路复用机制，以克服其不足。这些替代方案在处理大量并发连接和提升性能方面具有显著优势。\n6.1 poll() poll() 是 select() 的直接替代品，具有以下特点：\n文件描述符数量不受限制：不像 select() 有 FD_SETSIZE 的限制，poll() 可以处理更多的文件描述符。 更简洁的接口：使用数组来管理文件描述符，避免了 FD_SET 等宏的复杂性。 6.2 epoll（Linux 特有） epoll 是 Linux 提供的一种高效的 I/O 多路复用机制，具有以下优点：\n高性能：epoll 采用事件驱动机制，时间复杂度为 O(1)，适合处理大规模并发连接。 支持边缘触发：相比 select() 仅支持水平触发，epoll 支持边缘触发，减少不必要的事件通知。 内核与用户空间共享事件表：避免了每次调用 epoll_wait() 时都需要重新传递大量的文件描述符，提高效率。 6.3 kqueue（BSD 系统特有） kqueue 是 BSD 系统（如 FreeBSD、macOS）提供的一种高效的事件通知机制，具有以下特点：\n高效的事件处理：类似于 epoll，kqueue 提供高效的事件通知和管理。 灵活的事件过滤：支持多种类型的事件过滤，如文件描述符事件、信号事件等。 6.4 多线程/多进程模型 除了基于 I/O 多路复用的方案，多线程和多进程模型也是处理并发连接的常见方法：\n多线程： 每个客户端连接由一个独立的线程处理，适用于连接数较少的场景。 需要处理线程同步和资源共享问题。 多进程： 使用 fork() 为每个客户端创建一个独立的子进程，适用于需要隔离不同客户端的场景。 进程间资源消耗较高，管理复杂。 6.5 异步 I/O 现代编程语言和框架（如 C++ 的 Boost.Asio、Python 的 asyncio）提供了异步 I/O 支持，结合事件驱动机制，可以高效地处理并发连接。\n",
  "wordCount" : "4354",
  "inLanguage": "zh",
  "datePublished": "2024-03-19T20:19:02+08:00",
  "dateModified": "2024-03-19T20:19:02+08:00",
  "author":[{
    "@type": "Person",
    "name": "史玉浩"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://oheyu.github.io/zh/posts/tech/linux%E7%9A%84io%E5%A4%8D%E7%94%A8%E4%B9%8Bselect/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "史玉浩的个人博客",
    "logo": {
      "@type": "ImageObject",
      "url": "https://oheyu.github.io/img/logo.svg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://oheyu.github.io/zh/" accesskey="h" title="史玉浩的个人博客 (Alt + H)">史玉浩的个人博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://oheyu.github.io/en/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://oheyu.github.io/zh/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://oheyu.github.io/zh/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://oheyu.github.io/zh/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://oheyu.github.io/zh/archives" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://oheyu.github.io/zh/categories" title="🧩分类">
                    <span>🧩分类</span>
                </a>
            </li>
            <li>
                <a href="https://oheyu.github.io/zh/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://oheyu.github.io/zh/">主页</a>&nbsp;»&nbsp;<a href="https://oheyu.github.io/zh/posts/">📚 文章</a>&nbsp;»&nbsp;<a href="https://oheyu.github.io/zh/posts/tech/">👨🏻‍💻 技术</a></div>
    <h1 class="post-title entry-hint-parent">
      Linux的IO复用之select
    </h1>
    <div class="post-meta"><span title='2024-03-19 20:19:02 +0800 CST'>2024-03-19</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;史玉浩

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e4%b8%80%e4%bb%80%e4%b9%88%e6%98%af-select-%e5%87%bd%e6%95%b0" aria-label="一、什么是 select() 函数？">一、什么是 <code>select()</code> 函数？</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#%e8%bf%94%e5%9b%9e%e5%80%bc" aria-label="返回值">返回值</a></li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#%e4%ba%8cselect-%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="二、select() 的工作原理">二、<code>select()</code> 的工作原理</a></li>
                    <li>
                        <a href="#%e4%b8%89select-%e7%9a%84%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="三、select() 的使用方法">三、<code>select()</code> 的使用方法</a><ul>
                            
                    <li>
                        <a href="#31-%e5%85%b3%e9%94%ae%e7%82%b9%e8%a7%a3%e6%9e%90" aria-label="3.1 关键点解析">3.1 关键点解析</a><ul>
                            
                    <li>
                        <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%a4%8d%e5%88%b6-readfds-%e7%bb%99-tmpfds" aria-label="为什么需要复制 readfds 给 tmpfds">为什么需要复制 <code>readfds</code> 给 <code>tmpfds</code></a></li>
                    <li>
                        <a href="#%e7%bb%b4%e6%8a%a4-maxfd" aria-label="维护 maxfd">维护 <code>maxfd</code></a></li>
                    <li>
                        <a href="#%e8%b6%85%e6%97%b6%e5%a4%84%e7%90%86" aria-label="超时处理">超时处理</a></li>
                    <li>
                        <a href="#%e7%bc%93%e5%86%b2%e5%8c%ba%e5%ae%89%e5%85%a8" aria-label="缓冲区安全">缓冲区安全</a></li>
                    <li>
                        <a href="#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86" aria-label="错误处理">错误处理</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e5%9b%9bselect-%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="四、select() 的优缺点">四、<code>select()</code> 的优缺点</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#%e4%bc%98%e7%82%b9" aria-label="优点">优点</a></li>
                    <li>
                        <a href="#%e7%bc%ba%e7%82%b9" aria-label="缺点">缺点</a></li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#%e4%ba%94select-%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="五、select() 的应用场景">五、<code>select()</code> 的应用场景</a></li>
                    <li>
                        <a href="#%e5%85%adselect-%e7%9a%84%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88" aria-label="六、select() 的替代方案">六、<code>select()</code> 的替代方案</a><ul>
                            
                    <li>
                        <a href="#61-poll" aria-label="6.1 poll()">6.1 <code>poll()</code></a></li>
                    <li>
                        <a href="#62-epolllinux-%e7%89%b9%e6%9c%89" aria-label="6.2 epoll（Linux 特有）">6.2 <code>epoll</code>（Linux 特有）</a></li>
                    <li>
                        <a href="#63-kqueuebsd-%e7%b3%bb%e7%bb%9f%e7%89%b9%e6%9c%89" aria-label="6.3 kqueue（BSD 系统特有）">6.3 <code>kqueue</code>（BSD 系统特有）</a></li>
                    <li>
                        <a href="#64-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%a4%9a%e8%bf%9b%e7%a8%8b%e6%a8%a1%e5%9e%8b" aria-label="6.4 多线程/多进程模型">6.4 多线程/多进程模型</a></li>
                    <li>
                        <a href="#65-%e5%bc%82%e6%ad%a5-io" aria-label="6.5 异步 I/O">6.5 异步 I/O</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
  <div class="post-content"><!-- more -->
<p><code>select()</code> 函数作为一种经典的多路复用机制，在处理多个文件描述符（如套接字）时扮演着重要角色。虽然已经过时，但对于我们进一步了解其他复用有极大的帮助。</p>
<hr>
<h2 id="一什么是-select-函数">一、什么是 <code>select()</code> 函数？<a hidden class="anchor" aria-hidden="true" href="#一什么是-select-函数">#</a></h2>
<p><code>select()</code> 是一个系统调用，位于 POSIX 标准中，主要用于监视多个文件描述符，以检测哪些文件描述符准备好进行 I/O 操作（如读、写或发生异常）。它允许程序在单个线程或进程中同时处理多个 I/O 事件，从而实现高效的资源利用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/select.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>nfds</code></strong>：需要监视的文件描述符集合中最大文件描述符的值加一。</li>
<li><strong><code>readfds</code></strong>：指向 <code>fd_set</code> 结构的指针，用于监视可读事件的文件描述符集合。</li>
<li><strong><code>writefds</code></strong>：指向 <code>fd_set</code> 结构的指针，用于监视可写事件的文件描述符集合。</li>
<li><strong><code>exceptfds</code></strong>：指向 <code>fd_set</code> 结构的指针，用于监视异常事件的文件描述符集合。</li>
<li><strong><code>timeout</code></strong>：指向 <code>timeval</code> 结构的指针，指定 <code>select()</code> 函数的超时时间。如果为 <code>NULL</code>，<code>select()</code> 会一直阻塞直到有事件发生。</li>
</ul>
<h4 id="返回值">返回值<a hidden class="anchor" aria-hidden="true" href="#返回值">#</a></h4>
<ul>
<li><strong>正数</strong>：表示发生事件的文件描述符数量。</li>
<li><strong><code>0</code></strong>：表示 <code>select()</code> 超时，没有事件发生。</li>
<li><strong><code>-1</code></strong>：表示调用失败，错误信息存储在 <code>errno</code> 中。</li>
</ul>
<hr>
<h2 id="二select-的工作原理">二、<code>select()</code> 的工作原理<a hidden class="anchor" aria-hidden="true" href="#二select-的工作原理">#</a></h2>
<p><code>select()</code> 的核心思想是利用文件描述符集合（<code>fd_set</code>）来监视多个文件描述符的状态变化。它通过以下步骤工作：</p>
<ol>
<li><strong>初始化文件描述符集合</strong>：使用 <code>FD_ZERO</code> 清空集合，使用 <code>FD_SET</code> 将需要监视的文件描述符加入集合。</li>
<li><strong>调用 <code>select()</code></strong>：将准备好的 <code>fd_set</code> 传递给 <code>select()</code>，并指定监视的事件类型（读、写、异常）。</li>
<li><strong>等待事件发生</strong>：<code>select()</code> 会阻塞，直到有文件描述符满足指定的事件，或超时时间到达。</li>
<li><strong>处理事件</strong>：<code>select()</code> 返回后，遍历文件描述符集合，使用 <code>FD_ISSET</code> 判断哪些文件描述符发生了事件，并进行相应的处理。</li>
</ol>
<p><strong>注意</strong>：<code>select()</code> 会修改传入的 <code>fd_set</code> 集合，仅保留发生事件的文件描述符。因此，在每次调用 <code>select()</code> 前，需要重新初始化或复制原始的 <code>fd_set</code>。</p>
<hr>
<h2 id="三select-的使用方法">三、<code>select()</code> 的使用方法<a hidden class="anchor" aria-hidden="true" href="#三select-的使用方法">#</a></h2>
<p>以下是一个基于 <code>select()</code> 的简单 TCP 服务器示例，能够同时处理多个客户端连接，并回显客户端发送的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BUFFER_SIZE 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化服务端的监听端口。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">initserver</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Usage: %s &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化服务端用于监听的socket。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">listensock</span> <span class="o">=</span> <span class="nf">initserver</span><span class="p">(</span><span class="nf">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">listensock</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;initserver() failed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Listening on socket=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">listensock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">fd_set</span> <span class="n">readfds</span><span class="p">;</span>                         
</span></span><span class="line"><span class="cl">    <span class="nf">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>                
</span></span><span class="line"><span class="cl">    <span class="nf">FD_SET</span><span class="p">(</span><span class="n">listensock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">maxfd</span> <span class="o">=</span> <span class="n">listensock</span><span class="p">;</span>              
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>        <span class="c1">// 事件循环。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">timeval</span> <span class="n">timeout</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">        <span class="n">timeout</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>        <span class="c1">// 秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">timeout</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1">// 微秒。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="n">fd_set</span> <span class="n">tmpfds</span> <span class="o">=</span> <span class="n">readfds</span><span class="p">;</span>      <span class="c1">// 复制 readfds，避免被 select() 修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用select() 等待事件的发生（监视哪些socket发生了事件)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">infds</span> <span class="o">=</span> <span class="nf">select</span><span class="p">(</span><span class="n">maxfd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpfds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果infds&lt;0，表示调用select()失败。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">infds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 被信号中断，继续循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;select() failed&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果infds==0，表示select()超时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">infds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;select() timeout.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果infds&gt;0，表示有事件发生，infds存放了已发生事件的个数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">eventfd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">eventfd</span> <span class="o">&lt;=</span> <span class="n">maxfd</span> <span class="o">&amp;&amp;</span> <span class="n">infds</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">eventfd</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">FD_ISSET</span><span class="p">(</span><span class="n">eventfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpfds</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">infds</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果发生事件的是listensock，表示有新的客户端连上来了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">eventfd</span> <span class="o">==</span> <span class="n">listensock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">client</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">socklen_t</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">int</span> <span class="n">clientsock</span> <span class="o">=</span> <span class="nf">accept</span><span class="p">(</span><span class="n">listensock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">clientsock</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">                    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">                        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;accept() failed&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">                        <span class="k">continue</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Accepted client(socket=%d) from %s:%d.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                           <span class="n">clientsock</span><span class="p">,</span> <span class="nf">inet_ntoa</span><span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">),</span> <span class="nf">ntohs</span><span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">sin_port</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="nf">FD_SET</span><span class="p">(</span><span class="n">clientsock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>                      <span class="c1">// 把新连上来的客户端的标志位置为1。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">clientsock</span> <span class="o">&gt;</span> <span class="n">maxfd</span><span class="p">)</span> <span class="n">maxfd</span> <span class="o">=</span> <span class="n">clientsock</span><span class="p">;</span>    <span class="c1">// 更新maxfd的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 如果是客户端连接的socket有事件，表示接收缓存中有数据可以读，或者有客户端已断开连接。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">ssize_t</span> <span class="n">bytes_received</span> <span class="o">=</span> <span class="nf">recv</span><span class="p">(</span><span class="n">eventfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">bytes_received</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">bytes_received</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="c1">// 客户端关闭连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Client(socket=%d) disconnected.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">eventfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                        <span class="k">else</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;recv() failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="nf">close</span><span class="p">(</span><span class="n">eventfd</span><span class="p">);</span>                         <span class="c1">// 关闭客户端的socket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">                        <span class="nf">FD_CLR</span><span class="p">(</span><span class="n">eventfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>     <span class="c1">// 把bitmap中已关闭客户端的标志位清空。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">eventfd</span> <span class="o">==</span> <span class="n">maxfd</span><span class="p">)</span>              <span class="c1">// 重新计算maxfd的值，只有当eventfd==maxfd时才需要计算。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="k">while</span> <span class="p">(</span><span class="nf">FD_ISSET</span><span class="p">(</span><span class="n">maxfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">maxfd</span> <span class="o">&gt;</span> <span class="n">listensock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                <span class="n">maxfd</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                            <span class="p">}</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="k">else</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">// 如果客户端有报文发过来。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">buffer</span><span class="p">[</span><span class="n">bytes_received</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="c1">// 确保字符串终止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Received from socket=%d: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">eventfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="c1">// 把接收到的报文内容原封不动的发回去。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="kt">ssize_t</span> <span class="n">bytes_sent</span> <span class="o">=</span> <span class="nf">send</span><span class="p">(</span><span class="n">eventfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">bytes_received</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">bytes_sent</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;send() failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                            <span class="nf">close</span><span class="p">(</span><span class="n">eventfd</span><span class="p">);</span>                         <span class="c1">// 关闭客户端的socket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="nf">FD_CLR</span><span class="p">(</span><span class="n">eventfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>     <span class="c1">// 把bitmap中已关闭客户端的标志位清空。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">                            <span class="k">if</span> <span class="p">(</span><span class="n">eventfd</span> <span class="o">==</span> <span class="n">maxfd</span><span class="p">)</span>              
</span></span><span class="line"><span class="cl">                            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                <span class="k">while</span> <span class="p">(</span><span class="nf">FD_ISSET</span><span class="p">(</span><span class="n">maxfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">maxfd</span> <span class="o">&gt;</span> <span class="n">listensock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">maxfd</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                            <span class="p">}</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                        <span class="k">else</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Echoed back to socket=%d.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">eventfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">listensock</span><span class="p">);</span> <span class="c1">// 程序结束前关闭监听socket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化服务端的监听端口。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">initserver</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sock</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;socket() failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">opt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;setsockopt() failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">servaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="nf">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;bind() failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;listen() failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>代码详解</strong></p>
<ol>
<li>
<p><strong>初始化服务器套接字</strong>：</p>
<ul>
<li><strong>创建套接字</strong>：使用 <code>socket(AF_INET, SOCK_STREAM, 0)</code> 创建一个 TCP 套接字。</li>
<li><strong>设置套接字选项</strong>：通过 <code>setsockopt</code> 设置 <code>SO_REUSEADDR</code> 选项，允许重用本地地址和端口，避免在服务器重启后出现 <code>bind</code> 失败的情况。</li>
<li><strong>绑定地址和端口</strong>：将套接字绑定到指定端口和所有可用接口 (<code>INADDR_ANY</code>)。</li>
<li><strong>监听</strong>：将套接字置于监听状态，等待客户端连接。</li>
</ul>
</li>
<li>
<p><strong>初始化 <code>fd_set</code> 集合</strong>：</p>
<ul>
<li>使用 <code>FD_ZERO</code> 清空 <code>readfds</code> 集合。</li>
<li>使用 <code>FD_SET</code> 将监听套接字加入 <code>readfds</code> 集合。</li>
<li>维护一个变量 <code>maxfd</code>，记录当前监视的最大文件描述符值，用于 <code>select()</code> 函数的第一个参数。</li>
</ul>
</li>
<li>
<p><strong>事件循环</strong>：</p>
<ul>
<li><strong>超时设置</strong>：定义一个 <code>timeval</code> 结构体，设置 <code>select()</code> 的超时时间为 10 秒。</li>
<li><strong>复制 <code>fd_set</code></strong>：每次调用 <code>select()</code> 前，将原始的 <code>readfds</code> 集合复制到一个临时的 <code>tmpfds</code> 集合，因为 <code>select()</code> 会修改传入的集合。</li>
<li><strong>调用 <code>select()</code></strong>：监视读事件，等待事件发生或超时。</li>
<li><strong>处理事件</strong>：
<ul>
<li><strong>新连接事件</strong>：如果监听套接字有事件，调用 <code>accept()</code> 接受新的客户端连接，将新客户端的套接字加入 <code>readfds</code> 集合，并更新 <code>maxfd</code>。</li>
<li><strong>数据接收事件</strong>：如果已有客户端套接字有事件，调用 <code>recv()</code> 接收数据。如果 <code>recv()</code> 返回值 &lt;= 0，表示客户端断开连接，关闭套接字并从 <code>readfds</code> 中移除；否则，将接收到的数据回显给客户端。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>资源管理</strong>：</p>
<ul>
<li>在客户端断开连接时，关闭相应的套接字并从 <code>readfds</code> 中移除，防止资源泄漏。</li>
<li>程序结束前，关闭监听套接字，释放资源。</li>
</ul>
</li>
</ol>
<h3 id="31-关键点解析">3.1 关键点解析<a hidden class="anchor" aria-hidden="true" href="#31-关键点解析">#</a></h3>
<h4 id="为什么需要复制-readfds-给-tmpfds">为什么需要复制 <code>readfds</code> 给 <code>tmpfds</code><a hidden class="anchor" aria-hidden="true" href="#为什么需要复制-readfds-给-tmpfds">#</a></h4>
<p><code>select()</code> 函数会修改传入的 <code>fd_set</code> 集合，仅保留发生事件的文件描述符。因此，在每次调用 <code>select()</code> 前，需要将原始的 <code>readfds</code> 复制到一个临时集合 <code>tmpfds</code>，以便在下一次循环中仍能监视所有需要的文件描述符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">fd_set</span> <span class="n">tmpfds</span> <span class="o">=</span> <span class="n">readfds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">infds</span> <span class="o">=</span> <span class="nf">select</span><span class="p">(</span><span class="n">maxfd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpfds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>否则，如果直接传入 <code>readfds</code>，每次 <code>select()</code> 调用后，<code>readfds</code> 只会包含发生了事件的文件描述符，导致无法继续监视其他套接字。</p>
<h4 id="维护-maxfd">维护 <code>maxfd</code><a hidden class="anchor" aria-hidden="true" href="#维护-maxfd">#</a></h4>
<p><code>select()</code> 的第一个参数 <code>nfds</code> 需要设置为所有监视的文件描述符中最大的文件描述符值加一。因此，每次有新的客户端连接时，需要更新 <code>maxfd</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">clientsock</span> <span class="o">&gt;</span> <span class="n">maxfd</span><span class="p">)</span> <span class="n">maxfd</span> <span class="o">=</span> <span class="n">clientsock</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当有客户端断开连接且该套接字是当前 <code>maxfd</code> 时，需要重新计算新的 <code>maxfd</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">eventfd</span> <span class="o">==</span> <span class="n">maxfd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nf">FD_ISSET</span><span class="p">(</span><span class="n">maxfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">maxfd</span> <span class="o">&gt;</span> <span class="n">listensock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">maxfd</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="超时处理">超时处理<a hidden class="anchor" aria-hidden="true" href="#超时处理">#</a></h4>
<p>在原始代码中，虽然定义了 <code>timeout</code>，但传入 <code>select()</code> 的参数是 <code>0</code>，表示无限等待。正确的做法是将 <code>&amp;timeout</code> 传入 <code>select()</code>，以实现超时机制。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">infds</span> <span class="o">=</span> <span class="nf">select</span><span class="p">(</span><span class="n">maxfd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpfds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样，当超过 10 秒没有事件发生时，<code>select()</code> 会返回 <code>0</code>，程序可以根据需要执行相应的操作，如打印超时信息。</p>
<h4 id="缓冲区安全">缓冲区安全<a hidden class="anchor" aria-hidden="true" href="#缓冲区安全">#</a></h4>
<p>在接收数据后，手动添加 null 字符，确保字符串安全，防止缓冲区溢出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">buffer</span><span class="p">[</span><span class="n">bytes_received</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="c1">// 确保字符串终止
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>同时，<code>recv()</code> 调用中，使用 <code>sizeof(buffer) - 1</code> 作为接收长度，留出一个字节用于存储 null 字符。</p>
<h4 id="错误处理">错误处理<a hidden class="anchor" aria-hidden="true" href="#错误处理">#</a></h4>
<p>在套接字操作中，合理处理错误情况，如 <code>accept()</code>、<code>recv()</code>、<code>send()</code> 失败时，打印错误信息并采取相应的措施（如关闭套接字、移除集合等），确保程序的健壮性。</p>
<hr>
<h2 id="四select-的优缺点">四、<code>select()</code> 的优缺点<a hidden class="anchor" aria-hidden="true" href="#四select-的优缺点">#</a></h2>
<h4 id="优点">优点<a hidden class="anchor" aria-hidden="true" href="#优点">#</a></h4>
<ol>
<li><strong>简单易用</strong>：<code>select()</code> 是一种相对简单的多路复用机制，易于理解和实现。</li>
<li><strong>跨平台支持</strong>：<code>select()</code> 在大多数 POSIX 系统（如 Linux、BSD、macOS）和 Windows 平台上都有实现，具有良好的跨平台兼容性。</li>
<li><strong>无需额外库</strong>：使用 <code>select()</code> 不需要依赖额外的库，适用于轻量级应用。</li>
</ol>
<h4 id="缺点">缺点<a hidden class="anchor" aria-hidden="true" href="#缺点">#</a></h4>
<ol>
<li><strong>文件描述符数量限制</strong>：
<ul>
<li><code>select()</code> 受限于 <code>FD_SETSIZE</code>（通常为 1024），无法处理大量并发连接。</li>
<li>在高并发场景下，<code>select()</code> 无法满足需求。</li>
</ul>
</li>
<li><strong>性能问题</strong>：
<ul>
<li><code>select()</code> 需要线性扫描所有文件描述符，时间复杂度为 O(n)，在监视大量文件描述符时效率低下。</li>
<li>每次调用 <code>select()</code> 都需要重新设置 <code>fd_set</code>，增加了系统调用的开销。</li>
</ul>
</li>
<li><strong>不支持边缘触发</strong>：
<ul>
<li><code>select()</code> 仅支持水平触发（Level-Triggered），无法像 <code>epoll</code> 支持边缘触发（Edge-Triggered）那样高效处理事件。</li>
</ul>
</li>
<li><strong>可读性与维护性</strong>：
<ul>
<li>随着监视的文件描述符增多，代码的复杂性和可维护性降低。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="五select-的应用场景">五、<code>select()</code> 的应用场景<a hidden class="anchor" aria-hidden="true" href="#五select-的应用场景">#</a></h2>
<p>尽管 <code>select()</code> 存在一些限制，但在某些场景下，<code>select()</code> 仍然是一个合适的选择：</p>
<ol>
<li><strong>低并发连接</strong>：
<ul>
<li>对于连接数较少的服务器，<code>select()</code> 可以有效管理多个客户端连接，无需担心性能问题。</li>
</ul>
</li>
<li><strong>跨平台应用</strong>：
<ul>
<li>需要在不同操作系统间移植的应用，<code>select()</code> 的广泛支持使其成为首选。</li>
</ul>
</li>
<li><strong>简单的 I/O 多路复用需求</strong>：
<ul>
<li>在需要简单实现 I/O 多路复用功能但不需要处理大量并发连接的情况下，<code>select()</code> 是一种便捷的选择。</li>
</ul>
</li>
<li><strong>嵌入式系统</strong>：
<ul>
<li>资源有限的嵌入式系统中，<code>select()</code> 的轻量级特性使其适用于简单的网络通信任务。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="六select-的替代方案">六、<code>select()</code> 的替代方案<a hidden class="anchor" aria-hidden="true" href="#六select-的替代方案">#</a></h2>
<p>随着网络应用的发展，出现了多种替代 <code>select()</code> 的多路复用机制，以克服其不足。这些替代方案在处理大量并发连接和提升性能方面具有显著优势。</p>
<h3 id="61-poll">6.1 <code>poll()</code><a hidden class="anchor" aria-hidden="true" href="#61-poll">#</a></h3>
<p><code>poll()</code> 是 <code>select()</code> 的直接替代品，具有以下特点：</p>
<ul>
<li><strong>文件描述符数量不受限制</strong>：不像 <code>select()</code> 有 <code>FD_SETSIZE</code> 的限制，<code>poll()</code> 可以处理更多的文件描述符。</li>
<li><strong>更简洁的接口</strong>：使用数组来管理文件描述符，避免了 <code>FD_SET</code> 等宏的复杂性。</li>
</ul>
<h3 id="62-epolllinux-特有">6.2 <code>epoll</code>（Linux 特有）<a hidden class="anchor" aria-hidden="true" href="#62-epolllinux-特有">#</a></h3>
<p><code>epoll</code> 是 Linux 提供的一种高效的 I/O 多路复用机制，具有以下优点：</p>
<ul>
<li><strong>高性能</strong>：<code>epoll</code> 采用事件驱动机制，时间复杂度为 O(1)，适合处理大规模并发连接。</li>
<li><strong>支持边缘触发</strong>：相比 <code>select()</code> 仅支持水平触发，<code>epoll</code> 支持边缘触发，减少不必要的事件通知。</li>
<li><strong>内核与用户空间共享事件表</strong>：避免了每次调用 <code>epoll_wait()</code> 时都需要重新传递大量的文件描述符，提高效率。</li>
</ul>
<h3 id="63-kqueuebsd-系统特有">6.3 <code>kqueue</code>（BSD 系统特有）<a hidden class="anchor" aria-hidden="true" href="#63-kqueuebsd-系统特有">#</a></h3>
<p><code>kqueue</code> 是 BSD 系统（如 FreeBSD、macOS）提供的一种高效的事件通知机制，具有以下特点：</p>
<ul>
<li><strong>高效的事件处理</strong>：类似于 <code>epoll</code>，<code>kqueue</code> 提供高效的事件通知和管理。</li>
<li><strong>灵活的事件过滤</strong>：支持多种类型的事件过滤，如文件描述符事件、信号事件等。</li>
</ul>
<h3 id="64-多线程多进程模型">6.4 多线程/多进程模型<a hidden class="anchor" aria-hidden="true" href="#64-多线程多进程模型">#</a></h3>
<p>除了基于 I/O 多路复用的方案，多线程和多进程模型也是处理并发连接的常见方法：</p>
<ul>
<li><strong>多线程</strong>：
<ul>
<li>每个客户端连接由一个独立的线程处理，适用于连接数较少的场景。</li>
<li>需要处理线程同步和资源共享问题。</li>
</ul>
</li>
<li><strong>多进程</strong>：
<ul>
<li>使用 <code>fork()</code> 为每个客户端创建一个独立的子进程，适用于需要隔离不同客户端的场景。</li>
<li>进程间资源消耗较高，管理复杂。</li>
</ul>
</li>
</ul>
<h3 id="65-异步-io">6.5 异步 I/O<a hidden class="anchor" aria-hidden="true" href="#65-异步-io">#</a></h3>
<p>现代编程语言和框架（如 C++ 的 Boost.Asio、Python 的 asyncio）提供了异步 I/O 支持，结合事件驱动机制，可以高效地处理并发连接。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://oheyu.github.io/zh/tags/linux/">Linux</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://oheyu.github.io/zh/posts/tech/memcpy%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/">
    <span class="title">« 上一页</span>
    <br>
    <span>memcpy()函数详解</span>
  </a>
  <a class="next" href="https://oheyu.github.io/zh/posts/tech/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E8%AF%BB%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%86%99%E4%BA%8B%E4%BB%B6/">
    <span class="title">下一页 »</span>
    <br>
    <span>网络通信中的读事件与写事件</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://oheyu.github.io/zh/">史玉浩的个人博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
