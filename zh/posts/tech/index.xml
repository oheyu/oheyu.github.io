<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>👨🏻‍💻 技术 on 史玉浩的个人博客</title>
    <link>https://oheyu.github.io/zh/posts/tech/</link>
    <description>Recent content in 👨🏻‍💻 技术 on 史玉浩的个人博客</description>
    <generator>Hugo -- 0.127.0</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 01 Sep 2024 10:37:23 +0800</lastBuildDate>
    <atom:link href="https://oheyu.github.io/zh/posts/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Native_handle访问系统原生线程句柄</title>
      <link>https://oheyu.github.io/zh/posts/tech/native_handle%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%94%9F%E7%BA%BF%E7%A8%8B%E5%8F%A5%E6%9F%84/</link>
      <pubDate>Sun, 01 Sep 2024 10:37:23 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/native_handle%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%94%9F%E7%BA%BF%E7%A8%8B%E5%8F%A5%E6%9F%84/</guid>
      <description>C++11 为多线程编程提供了标准化的线程库，通过 std::thread 类封装了底层操作系统的线程库。然而，不同的操作系统具有各自的线程管理功能，有时我们需要直接访问这些</description>
    </item>
    <item>
      <title>CPP中的可调用对象</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 30 Aug 2024 15:25:18 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/</guid>
      <description>在 C++ 中，所有可以像函数一样被调用的实体，统称为可调用对象（Callable Objects）。这些对象不仅仅局限于普通函数，还包括类的静态成员</description>
    </item>
    <item>
      <title>CPP中的可调用对象包装器</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8/</link>
      <pubDate>Tue, 27 Aug 2024 16:28:40 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8/</guid>
      <description>std::function 是一种通用的模板类，用于封装不同类型的可调用对象并通过统一的接口调用它们，使得处理这些可调用对象变得更加简洁、灵活。 一、什么是 std::f</description>
    </item>
    <item>
      <title>CPP中的函数适配器</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8/</link>
      <pubDate>Sun, 25 Aug 2024 16:40:32 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8/</guid>
      <description>C++ 中，通用的函数适配器 std::bind 是一个强大而灵活的工具。它允许将可调用对象及其参数进行绑定，并生成一个新的可调用对象。在涉及回调机制、延迟函数执行、</description>
    </item>
    <item>
      <title>消息队列中的回调函数</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 21 Aug 2024 17:00:17 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid>
      <description>在异步编程中，回调函数是一种非常常见的设计模式，尤其是在消息队列或网络库中。它允许我们在接收到消息（或事件）时，调用预先注册的用户自定义处理</description>
    </item>
    <item>
      <title>CPP的虚函数及其替代品</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%9B%BF%E4%BB%A3%E5%93%81/</link>
      <pubDate>Sat, 17 Aug 2024 08:24:46 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%9B%BF%E4%BB%A3%E5%93%81/</guid>
      <description>对于 C++ 编程，多态是面向对象编程的核心特性之一。虚函数是实现多态性的主要工具，它允许通过基类指针或引用来调用派生类的成员函数，从而实现动态的行</description>
    </item>
    <item>
      <title>CPP中的原子类型</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 09 Aug 2024 20:59:01 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B/</guid>
      <description>在并发环境中，如何保证数据在多个线程之间的同步与一致性是一个关键问题。传统的同步方式使用互斥锁（mutex）来保护共享数据，但锁的使用带来了</description>
    </item>
    <item>
      <title>条件变量</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 05 Aug 2024 20:11:40 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid>
      <description>在多线程编程中，协调线程间的执行顺序和资源共享是一个重要问题。条件变量（condition_variable）是 C++11 提供的一种线程同步机制，允</description>
    </item>
    <item>
      <title>再探CPP中的互斥锁</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%86%8D%E6%8E%A2cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81/</link>
      <pubDate>Sat, 03 Aug 2024 10:49:56 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%86%8D%E6%8E%A2cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81/</guid>
      <description>很久之前，我就相关内容写了一篇博客。今日，重读相关内容，还是觉得自己要就相关内容，再写一篇。不为别的，权当加深印象之用吧。C++11 提供了标</description>
    </item>
    <item>
      <title>Call_once实现线程安全的单次执行</title>
      <link>https://oheyu.github.io/zh/posts/tech/call_once%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E6%AC%A1%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Wed, 31 Jul 2024 10:22:02 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/call_once%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E6%AC%A1%E6%89%A7%E8%A1%8C/</guid>
      <description>在多线程编程中，经常会遇到这样的需求：某些函数或操作只能被调用一次，特别是在初始化某些全局或共享资源时。C++11 提供了一个简洁的解决方案：</description>
    </item>
    <item>
      <title>This_thread</title>
      <link>https://oheyu.github.io/zh/posts/tech/this_thread/</link>
      <pubDate>Mon, 29 Jul 2024 09:59:30 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/this_thread/</guid>
      <description>在 C++11 中，为了更好地支持并发编程，标准库提供了命名空间 std::this_thread，它专门用于表示当前线程，并提供了一些常用的与线程管理相</description>
    </item>
    <item>
      <title>线程资源的回收</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Sat, 27 Jul 2024 09:50:25 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%9B%9E%E6%94%B6/</guid>
      <description>在 C++ 中，线程的使用为我们带来了多任务并发执行的能力，但与此同时，如何管理和回收线程资源也是一个不可忽视的问题。虽然一个进程的所有线程共享同一</description>
    </item>
    <item>
      <title>CPP11中的线程支持</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp11%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81/</link>
      <pubDate>Wed, 24 Jul 2024 09:33:07 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp11%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81/</guid>
      <description>在 C++11 之前，C++ 没有原生的线程支持，开发者需要依赖于操作系统提供的线程库，不同平台的实现各不相同，这导致了跨平台开发的复杂性。C++11 引入</description>
    </item>
    <item>
      <title>memcpy()函数详解</title>
      <link>https://oheyu.github.io/zh/posts/tech/memcpy%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 08 Jul 2024 17:57:04 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/memcpy%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid>
      <description>memcpy() 函数是 C 标准库中用于内存操作的一个重要函数，它被广泛用于在内存中复制数据块。在系统编程和低级数据操作中，memcpy() 是一个常用且高效的</description>
    </item>
    <item>
      <title>再探信号量：互斥锁与生产者 消费者模型</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%86%8D%E6%8E%A2%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Tue, 31 Oct 2023 10:48:51 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%86%8D%E6%8E%A2%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</guid>
      <description>并发编程中，信号量（Semaphore）作为一种强大的同步工具，可以有效地控制多个线程或进程对共享资源的访问。C++ 提供了信号量的基本操作接</description>
    </item>
    <item>
      <title>常引用与临时变量的自动创建</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%B8%B8%E5%BC%95%E7%94%A8%E4%B8%8E%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA/</link>
      <pubDate>Mon, 30 Oct 2023 10:41:50 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%B8%B8%E5%BC%95%E7%94%A8%E4%B8%8E%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA/</guid>
      <description>在 C++ 编程中，引用（References）是一个非常常用的特性，允许我们通过别名来引用已有的变量。通常情况下，引用要求引用的类型和实际变量类型</description>
    </item>
    <item>
      <title>数组指针</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/</link>
      <pubDate>Fri, 13 Oct 2023 10:21:22 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/</guid>
      <description>在 C++ 编程中，指针和数组是两个非常基础且重要的概念。数组指针（Pointer to Array）是指向数组的指针，它们在多维数组、动态内存分配、函数</description>
    </item>
    <item>
      <title>RAII：资源获取即初始化</title>
      <link>https://oheyu.github.io/zh/posts/tech/raii%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Sat, 07 Oct 2023 10:07:35 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/raii%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>在 C++ 编程中，资源管理是一项至关重要的任务，尤其是在内存分配、文件操作、网络连接等与系统资源密切相关的场景中。RAII（Resource Acquisition Is I</description>
    </item>
    <item>
      <title>进程间同步：信号量</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E4%BF%A1%E5%8F%B7%E9%87%8F/</link>
      <pubDate>Fri, 06 Oct 2023 09:45:57 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid>
      <description>在多任务操作系统中，进程间同步和共享资源的管理是至关重要的。信号量（Semaphore）作为一种经典的同步机制，为控制对共享资源的访问提供了</description>
    </item>
    <item>
      <title>Linux的僵尸进程</title>
      <link>https://oheyu.github.io/zh/posts/tech/linux%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Sat, 30 Sep 2023 08:59:03 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/linux%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</guid>
      <description>在 Linux 和其他类 Unix 系统中，进程管理是保证系统稳定性和高效运行的重要组成部分。其中，僵尸进程（Zombie Process）是一个特殊但常见的问题。</description>
    </item>
    <item>
      <title>进程间的通信</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Fri, 29 Sep 2023 08:39:02 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</guid>
      <description>进程间通信（IPC，Inter-Process Communication）是 Linux 操作系统中的一个重要组成部分，它允许多个独立进程之间共享数据、</description>
    </item>
    <item>
      <title>共享内存初探</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Wed, 27 Sep 2023 22:13:57 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%88%9D%E6%8E%A2/</guid>
      <description>在操作系统中，进程是独立的执行实体，拥有自己的独立地址空间，无法直接访问其他进程的内存。然而，在多进程程序中，有时需要多个进程之间共享数据，</description>
    </item>
    <item>
      <title>Fork函数的工作原理</title>
      <link>https://oheyu.github.io/zh/posts/tech/fork%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 25 Sep 2023 17:08:06 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/fork%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</guid>
      <description>在 Linux 系统编程中，fork() 函数是创建新进程的基础工具之一。它允许进程在运行时创建自己的副本，即子进程，从而实现并行处理。今天，我们来详细探</description>
    </item>
    <item>
      <title>左值与右值</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/</link>
      <pubDate>Sun, 24 Sep 2023 16:55:52 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/</guid>
      <description>最近写代码，对左值（lvalue） 和 右值（rvalue） 两个概念感到有些拿不准，总结一下。 一、左值（lvalue）与右值（rvalue）的基</description>
    </item>
    <item>
      <title>Lock_guard与unique_lock</title>
      <link>https://oheyu.github.io/zh/posts/tech/lock_guard%E4%B8%8Eunique_lock/</link>
      <pubDate>Fri, 22 Sep 2023 16:44:33 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/lock_guard%E4%B8%8Eunique_lock/</guid>
      <description>在现代 C++ 多线程编程中，锁机制是确保线程安全访问共享资源的关键手段。C++ 标准库为开发者提供了多种锁管理工具，其中最常用的是 std::lock_guard 和 std::un</description>
    </item>
    <item>
      <title>CPP中的const与constexpr</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84const%E4%B8%8Econstexpr/</link>
      <pubDate>Wed, 20 Sep 2023 16:10:28 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84const%E4%B8%8Econstexpr/</guid>
      <description>在 C++ 中，const和constexpr是两个非常重要的关键字，它们的主要功能是保证变量和表达式在不同上下文中的不可修改性。然而，虽然这两个关</description>
    </item>
    <item>
      <title>Sizeof运算符</title>
      <link>https://oheyu.github.io/zh/posts/tech/sizeof%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Tue, 19 Sep 2023 16:00:43 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/sizeof%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>sizeof 运算符是一个极为常用且强大的工具。它能够在编译时计算任意数据类型或对象在内存中占用的字节数。 一、什么是 sizeof 运算符？ sizeof 是一个内置于 C++ 的运算符，</description>
    </item>
    <item>
      <title>CPP函数返回值的存储位置与优化策略</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</link>
      <pubDate>Sun, 17 Sep 2023 15:39:19 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</guid>
      <description>不论是那个编程语言，函数返回值是一个极其重要的概念，它不仅影响代码的逻辑，还直接关系到程序的性能。在不同的场景下，函数返回值的处理方式会对程</description>
    </item>
    <item>
      <title>Ulimit：资源限制与性能优化</title>
      <link>https://oheyu.github.io/zh/posts/tech/ulimit%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Fri, 15 Sep 2023 15:27:16 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/ulimit%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>在 Linux 和 Unix 系统中，系统资源的合理分配和限制是确保系统稳定性和性能的关键。而 ulimit 命令正是用于管理和控制用户进程的资源限制的工具。通过 ulimit，</description>
    </item>
    <item>
      <title>CPP中的内联函数</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 13 Sep 2023 11:23:38 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</guid>
      <description>在C++编程中，内联函数（inline function）是一个强大的优化工具，它允许编译器将函数调用直接展开为内联代码，从而减少函数调用的开</description>
    </item>
    <item>
      <title>CPP智能指针初探</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Sun, 10 Sep 2023 11:17:32 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%9D%E6%8E%A2/</guid>
      <description>在 C++ 编程中，内存管理始终是一个关键问题，尤其是在手动管理动态分配内存时，容易引发内存泄漏、悬空指针等问题。为了解决这些问题，C++11 引入了</description>
    </item>
    <item>
      <title>冷不丁儿的内存就泄漏了</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%86%B7%E4%B8%8D%E4%B8%81%E5%84%BF%E7%9A%84%E5%86%85%E5%AD%98%E5%B0%B1%E6%B3%84%E6%BC%8F%E4%BA%86/</link>
      <pubDate>Sat, 09 Sep 2023 11:05:16 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%86%B7%E4%B8%8D%E4%B8%81%E5%84%BF%E7%9A%84%E5%86%85%E5%AD%98%E5%B0%B1%E6%B3%84%E6%BC%8F%E4%BA%86/</guid>
      <description>在 C++ 编程中，内存泄漏是一个经常遇到的重大问题，特别是在涉及动态内存管理的场景中。如果程序在分配内存后没有及时释放，可能导致系统内存逐渐被耗尽</description>
    </item>
    <item>
      <title>冒泡排序</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 03 Sep 2023 10:53:37 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>一、引言 冒泡排序（Bubble Sort）是一种基础且直观的排序算法，它通过反复遍历待排序的数组，每次比较相邻的元素，如果顺序错误则交换它们的</description>
    </item>
    <item>
      <title>CPP模板参数推导与显示指定的原理及应用场景</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC%E4%B8%8E%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Thu, 31 Aug 2023 21:42:05 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC%E4%B8%8E%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>C++ 的模板机制是其强大功能的核心之一，它允许编写通用的代码，并根据不同的类型进行实例化。然而，C++ 中的模板使用过程中，有时我们可以依赖编译器</description>
    </item>
    <item>
      <title>Return、exit、_exit以及_Exit</title>
      <link>https://oheyu.github.io/zh/posts/tech/returnexit_exit%E4%BB%A5%E5%8F%8A_exit/</link>
      <pubDate>Sun, 27 Aug 2023 21:20:55 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/returnexit_exit%E4%BB%A5%E5%8F%8A_exit/</guid>
      <description>在 C 和 C++ 编程中，return、exit()、_exit() 以及 _Exit() 都可以用于终止程序或函数的执行，但它们的行为、作用范围以及对资源的处理方式存</description>
    </item>
    <item>
      <title>Linux退出状态码</title>
      <link>https://oheyu.github.io/zh/posts/tech/linux%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%A0%81/</link>
      <pubDate>Fri, 25 Aug 2023 21:14:56 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/linux%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%A0%81/</guid>
      <description>在 Unix 和 Linux 系统中，每个命令或程序在执行后都会返回一个退出状态码（Exit Status Code），用于指示该命令的执行结果。echo $? 是一个简单但非常有用</description>
    </item>
    <item>
      <title>CPP中的拷贝构造函数与赋值构造函数</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 23 Aug 2023 21:00:18 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid>
      <description>在 C++ 中，拷贝构造函数和赋值构造函数是管理对象复制行为的两个核心机制。它们的正确实现对于保障程序的健壮性与资源管理的正确性至关重要。 一、拷贝构</description>
    </item>
    <item>
      <title>静态库与动态库</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Wed, 23 Aug 2023 20:47:58 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>在 C++ 开发中，库文件是用于封装可重用代码的文件，帮助开发者在多个项目中共享和重用函数、类或数据结构。库文件主要分为两类：静态库（Static L</description>
    </item>
    <item>
      <title>CPP中的静态成员函数与普通成员函数</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 21 Aug 2023 20:25:34 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</guid>
      <description>在 C++ 面向对象编程中，类是封装数据和行为的核心概念。类的成员函数分为普通成员函数和静态成员函数两类，它们在访问方式、功能、以及使用场景上有着显</description>
    </item>
    <item>
      <title>Linux信号机制及其在CPP中的实现</title>
      <link>https://oheyu.github.io/zh/posts/tech/linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%9C%A8cpp%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 18 Aug 2023 20:05:41 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%9C%A8cpp%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>在 UNIX/Linux 操作系统中，信号（Signal）是一种进程间的通信机制，用于通知进程特定的事件发生。信号是异步的，允许进程在无需轮询的情况下处理来自系统</description>
    </item>
    <item>
      <title>CPP中的互斥锁：概念、实现与使用技巧</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E6%A6%82%E5%BF%B5%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 17 Aug 2023 19:46:48 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E6%A6%82%E5%BF%B5%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description>在并发编程中，互斥锁（Mutex）是保证多个线程或进程访问共享资源时数据一致性的重要同步机制。它通过限制同时访问某段代码的线程数，避免数据竞</description>
    </item>
    <item>
      <title>函数调用栈</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</link>
      <pubDate>Wed, 16 Aug 2023 19:29:32 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</guid>
      <description>在 C++ 编程中，函数调用栈是管理函数调用和返回的核心机制，它帮助程序高效管理函数的执行流程，包括参数传递、局部变量的存储和函数返回的控制。理解函</description>
    </item>
    <item>
      <title>CPP中共享内存的使用：为啥要避免string对象</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%BA%E5%95%A5%E8%A6%81%E9%81%BF%E5%85%8Dstring%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Tue, 15 Aug 2023 17:09:57 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%BA%E5%95%A5%E8%A6%81%E9%81%BF%E5%85%8Dstring%E5%AF%B9%E8%B1%A1/</guid>
      <description>在多进程编程中，共享内存是一种常用的进程间通信机制，允许多个进程访问同一块物理内存。这种方式不仅能够提高效率，还可以减少数据在进程间拷贝的开</description>
    </item>
    <item>
      <title>CPP中的仿函数（Functors）</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0functors/</link>
      <pubDate>Sun, 13 Aug 2023 16:59:30 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0functors/</guid>
      <description>在 C++ 编程中，仿函数（Function Objects, Functors）是一种强大的工具，它不仅可以像普通函数那样调用，还可以携带状态、使用类的继承和多态来</description>
    </item>
    <item>
      <title>CPP中结构体的内存管理：sizeof与memset的使用陷阱</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86sizeof%E4%B8%8Ememset%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1/</link>
      <pubDate>Fri, 11 Aug 2023 16:37:46 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86sizeof%E4%B8%8Ememset%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1/</guid>
      <description>在 C++ 编程中，结构体（struct）是一种常用的数据结构，尤其是在需要组织和管理多个相关数据时。然而，当结构体中包含指向动态分配内存的指针时，</description>
    </item>
    <item>
      <title>CPP中执行外部程序</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Tue, 08 Aug 2023 16:27:36 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</guid>
      <description>在 C++ 开发中，执行外部程序（如二进制文件、系统命令或 Shell 脚本）是一个常见的需求，尤其是在 Linux 系统中。C++ 提供了多种方式来实现这一功能，其中最常用</description>
    </item>
    <item>
      <title>全局变量与静态变量</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 07 Aug 2023 11:14:55 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</guid>
      <description>在 C++ 开发中，全局变量和静态变量的使用是一个常见且重要的话题。虽然它们有着各自独特的特性，但在实际项目中，合理运用这些变量可以帮助我们提高代码</description>
    </item>
    <item>
      <title>CPP内存模型</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 05 Aug 2023 10:37:41 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>内存，也就是我们常说的内存条，是计算机系统中至关重要的组成部分，它不仅用于存储程序的代码和数据，还负责数据的快速访问和处理。计算机内部以字节</description>
    </item>
    <item>
      <title>Free与malloc以及new与delete</title>
      <link>https://oheyu.github.io/zh/posts/tech/free%E4%B8%8Emalloc%E4%BB%A5%E5%8F%8Anew%E4%B8%8Edelete/</link>
      <pubDate>Sat, 05 Aug 2023 09:22:41 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/free%E4%B8%8Emalloc%E4%BB%A5%E5%8F%8Anew%E4%B8%8Edelete/</guid>
      <description>在 C/C++ 中，new/delete 与 malloc/free 的使用涉及内存分配和释放的机制，虽然它们的功能表面上类似，但在使用上存在许多本质上的区别，使用时务必配对使用</description>
    </item>
    <item>
      <title>半角字符与全角字符</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%8D%8A%E8%A7%92%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%85%A8%E8%A7%92%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Wed, 02 Aug 2023 08:05:43 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%8D%8A%E8%A7%92%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%85%A8%E8%A7%92%E5%AD%97%E7%AC%A6/</guid>
      <description>在处理文本特别是涉及东亚语言时，对于 “半角” 和 “全角“ 这两个术语，使用计算机这么多年，我们也疑惑了这么多年。事实上，它们主要与字符在屏幕或页</description>
    </item>
    <item>
      <title>Linux中的符号链接与符号链接所引用的文件</title>
      <link>https://oheyu.github.io/zh/posts/tech/linux%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E6%89%80%E5%BC%95%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 01 Aug 2023 21:58:41 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/linux%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E6%89%80%E5%BC%95%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6/</guid>
      <description>在操作系统中，符号链接（Symbolic Link）是一种常用的文件系统功能，它允许用户通过快捷方式访问其他文件或目录。 一、什么是符号链接？ 符</description>
    </item>
    <item>
      <title>Fg命令</title>
      <link>https://oheyu.github.io/zh/posts/tech/fg%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 30 Jul 2023 15:49:00 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/fg%E5%91%BD%E4%BB%A4/</guid>
      <description>fg 命令是 Unix 和类 Unix 操作系统中的一个重要命令，用于将后台运行的任务（进程）恢复到前台。它的全称是 &amp;ldquo;foreground&amp;rdquo;</description>
    </item>
    <item>
      <title>深入剖析addrinfo结构体</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90addrinfo%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Thu, 27 Jul 2023 15:32:48 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90addrinfo%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>在网络编程中，特别是在使用套接字编程时，地址解析和管理是一个关键问题。为了简化这个过程，POSIX 标准定义了 addrinfo 结构体和相关函数。 一、addr</description>
    </item>
    <item>
      <title>监听描述符与已连接描述符在网络编程中的区别</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E7%9B%91%E5%90%AC%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E5%B7%B2%E8%BF%9E%E6%8E%A5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%9C%A8%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 26 Jul 2023 15:22:55 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E7%9B%91%E5%90%AC%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E5%B7%B2%E8%BF%9E%E6%8E%A5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%9C%A8%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>一、什么是监听描述符（Listening Descriptor）？ 监听描述符主要用于等待和接受传入的客户端连接请求。它在服务器启动时被创建和配</description>
    </item>
    <item>
      <title>理解和构建一个高效的C&#43;&#43;工程项目目录结构</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3%E5%92%8C%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84c&#43;&#43;%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 25 Jul 2023 14:54:42 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3%E5%92%8C%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84c&#43;&#43;%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</guid>
      <description>在软件开发过程中，组织和管理项目文件是一项至关重要的任务。一个良好的目录结构可以提高开发效率、简化项目维护、促进团队协作。在 C++ 项目中，目录结</description>
    </item>
    <item>
      <title>Linux手册页指南：了解各章节及其使用场景</title>
      <link>https://oheyu.github.io/zh/posts/tech/linux%E6%89%8B%E5%86%8C%E9%A1%B5%E6%8C%87%E5%8D%97%E4%BA%86%E8%A7%A3%E5%90%84%E7%AB%A0%E8%8A%82%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Mon, 24 Jul 2023 20:59:07 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/linux%E6%89%8B%E5%86%8C%E9%A1%B5%E6%8C%87%E5%8D%97%E4%BA%86%E8%A7%A3%E5%90%84%E7%AB%A0%E8%8A%82%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>Linux 手册页（man pages）是每个 Linux 用户和开发者的重要资源。它们提供了关于各种命令、系统调用、库函数、文件格式等的详细信息。手册页分为多个章</description>
    </item>
    <item>
      <title>PyTorch中的训练模式和损失计算</title>
      <link>https://oheyu.github.io/zh/posts/tech/pytorch%E4%B8%AD%E7%9A%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8D%9F%E5%A4%B1%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Sun, 23 Jul 2023 21:50:42 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/pytorch%E4%B8%AD%E7%9A%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8D%9F%E5%A4%B1%E8%AE%A1%E7%AE%97/</guid>
      <description>在使用 PyTorch 进行模型训练时，为什么需要设置训练模式？如何计算每个 epoch 的平均损失？今天，我们来唠一唠。 一、模型的训练模式 在训练神经网络模型时，特别是</description>
    </item>
    <item>
      <title>理解CPP中的逗号运算符及其在赋值中的应用</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3cpp%E4%B8%AD%E7%9A%84%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E5%9C%A8%E8%B5%8B%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Fri, 21 Jul 2023 17:27:47 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3cpp%E4%B8%AD%E7%9A%84%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E5%9C%A8%E8%B5%8B%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>在 C++ 中，逗号运算符 , 是一个有趣且常见的运算符，它允许在一个语句中计算多个表达式。虽然它的使用相对简单，但在某些情况下可能会引起混淆。 逗号运算</description>
    </item>
    <item>
      <title>理解C语言中的NULL字符</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84null%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Tue, 18 Jul 2023 16:52:00 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84null%E5%AD%97%E7%AC%A6/</guid>
      <description>在C语言编程中，NULL字符（通常表示为 \0）是一个关键的概念，尤其在处理字符串时。它标志着字符串的结束，并在许多函数和算法中起着至关重要的</description>
    </item>
    <item>
      <title>缓冲性质函数与非缓冲性质函数：为何不能交替使用</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E7%BC%93%E5%86%B2%E6%80%A7%E8%B4%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%9E%E7%BC%93%E5%86%B2%E6%80%A7%E8%B4%A8%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E4%BA%A4%E6%9B%BF%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 16 Jul 2023 16:41:17 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E7%BC%93%E5%86%B2%E6%80%A7%E8%B4%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%9E%E7%BC%93%E5%86%B2%E6%80%A7%E8%B4%A8%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E4%BA%A4%E6%9B%BF%E4%BD%BF%E7%94%A8/</guid>
      <description>在系统编程中，尤其是文件 I/O 操作中，我们经常需要处理大量数据的读取和写入。为了提高效率，常常使用缓冲机制。本文将详细探讨缓冲性质函数和非缓冲性</description>
    </item>
    <item>
      <title>Ubuntu系统快照是个什么玩意儿</title>
      <link>https://oheyu.github.io/zh/posts/tech/ubuntu%E7%B3%BB%E7%BB%9F%E5%BF%AB%E7%85%A7%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E7%8E%A9%E6%84%8F%E5%84%BF/</link>
      <pubDate>Fri, 14 Jul 2023 16:24:40 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/ubuntu%E7%B3%BB%E7%BB%9F%E5%BF%AB%E7%85%A7%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E7%8E%A9%E6%84%8F%E5%84%BF/</guid>
      <description>Ubuntu 系统快照是一种用于捕捉和保存系统当前状态的技术。这种技术允许用户在将来某个时间点恢复到快照创建时的系统状态。这对于备份、系统更新前的保护、</description>
    </item>
    <item>
      <title>Vim重复上一次命令</title>
      <link>https://oheyu.github.io/zh/posts/tech/vim%E9%87%8D%E5%A4%8D%E4%B8%8A%E4%B8%80%E6%AC%A1%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Wed, 12 Jul 2023 16:15:16 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/vim%E9%87%8D%E5%A4%8D%E4%B8%8A%E4%B8%80%E6%AC%A1%E5%91%BD%E4%BB%A4/</guid>
      <description>在 Vim 中，我们可以使用重复上一次输入内容的命令来提高编辑效率。以下是几种常用的方法： 一. 使用 . 命令 . 命令是 Vim 中最常用的重复命令。它可以重复上一</description>
    </item>
    <item>
      <title>理解梯度下降在机器学习、深度学习和强化学习中的应用</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Tue, 11 Jul 2023 15:53:52 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>梯度下降是一种核心优化算法，广泛应用于机器学习、深度学习和强化学习中。本文将详细介绍这三者的关系，以及梯度下降在这些领域中的具体应用和实现方</description>
    </item>
    <item>
      <title>理解梯度下降：批量、随机与小批量的对比</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%89%B9%E9%87%8F%E9%9A%8F%E6%9C%BA%E4%B8%8E%E5%B0%8F%E6%89%B9%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Mon, 10 Jul 2023 15:39:18 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%89%B9%E9%87%8F%E9%9A%8F%E6%9C%BA%E4%B8%8E%E5%B0%8F%E6%89%B9%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94/</guid>
      <description>在机器学习和深度学习中，梯度下降是一种广泛使用的优化算法，用于最小化模型的损失函数，从而优化模型参数。梯度下降的三种主要变体是批量梯度下降、</description>
    </item>
    <item>
      <title>Vim如何快速删除括号里的内容</title>
      <link>https://oheyu.github.io/zh/posts/tech/vim%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%A0%E9%99%A4%E6%8B%AC%E5%8F%B7%E9%87%8C%E7%9A%84%E5%86%85%E5%AE%B9/</link>
      <pubDate>Thu, 06 Jul 2023 16:11:50 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/vim%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%A0%E9%99%A4%E6%8B%AC%E5%8F%B7%E9%87%8C%E7%9A%84%E5%86%85%E5%AE%B9/</guid>
      <description>在 Vim 的普通模式下，我们可以将光标放在括号内的任意位置输入如下命令快速删除括号（圆括号()、方括号[]、花括号{}）里的内容： di(：删除当前</description>
    </item>
    <item>
      <title>大端序与小端序</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%AB%AF%E5%BA%8F/</link>
      <pubDate>Thu, 06 Jul 2023 16:06:38 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%AB%AF%E5%BA%8F/</guid>
      <description>大端序（Big-endian） 数据的高字节存储在低地址，低字节存储在高地址。即，大端序是从“最高有效字节（Most Significant Byte, MSB）”到“最低有效</description>
    </item>
    <item>
      <title>结构体与联合体</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E8%81%94%E5%90%88%E4%BD%93/</link>
      <pubDate>Tue, 04 Jul 2023 19:57:05 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E8%81%94%E5%90%88%E4%BD%93/</guid>
      <description>结构体（Struct） 结构体是一种用户定义的数据类型，允许将不同类型的变量组合在一起作为一个单一的实体进行处理。结构体常用于组织和管理不同类</description>
    </item>
    <item>
      <title>解释型语言与编译型语言</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Mon, 03 Jul 2023 16:03:19 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80/</guid>
      <description>解释型语言 解释型语言是被解释器逐行解释和执行源代码的语言。这意味着程序代码在运行时将被直接翻译为机器代码并执行。 解释型语言有以下三个优点以及</description>
    </item>
    <item>
      <title>源文件到可执行文件的过程</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sat, 01 Jul 2023 22:12:27 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <description>在C、C++语言中，将源代码文件转换成可执行文件涉及多个步骤，主要包括预处理、编译、汇编和链接。 源代码（Source code）文件 源代码文件</description>
    </item>
    <item>
      <title>二级指针</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/</guid>
      <description>在 C++ 编程中，指针是一种非常强大的工具，它允许开发者直接操作内存地址。当处理简单的数据时，一级指针已经能够满足大部分需求，但在更复杂的场景中，</description>
    </item>
  </channel>
</rss>
