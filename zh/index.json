[{"content":"\rmemcpy() 函数是 C 标准库中用于内存操作的一个重要函数，它被广泛用于在内存中复制数据块。在系统编程和低级数据操作中，memcpy() 是一个常用且高效的工具。\nmemcpy() 函数的概述 memcpy() 函数用于将指定数量的字节从一个内存位置复制到另一个内存位置。它的操作是直接的、低级的，不会进行任何数据类型的转换或优化。在 string.h 头文件中，memcpy() 的定义如下：\n1 2 3 #include \u0026lt;string.h\u0026gt; void *memcpy(void *dest, const void *src, size_t n); 其中，对于参数而言：\ndest：目标内存地址的指针，表示数据的复制去向。 src：源内存地址的指针，表示数据的复制来源。 n：要复制的字节数。 对于返回值，该函数返回一个通用指针，该指针指向 dest。\n理解 void*。\nvoid* 是一种通用指针（generic pointer）。不同于空指针 NULL 表示一个不指向任何有效内存的特殊指针值，void* 指针可以指向内存中的某个位置，但其指向的数据类型是未确定的（通用的）。\n也正是因为 void* 指针不包含类型信息，所以它是类型不安全的。这意味着我们在使用 void* 时，必须确保正确的将其转换为合适的类型。此外，void* 指针也不能进行指针算术运算（如递增、递减），因为它不包含类型信息，编译器不知道要增加（减少）多少字节。最后，void* 指针也不能被直接解引用，必须将其转换为特定类型的指针。\n为什么 memcpy() 的返回值 void* 指向目标内存地址？\n函数链式调用的便利性：char *copied_data = memcpy(buffer, source, size);，在这条语句中，memcpy() 返回的指针可以直接被用于 copied_data，不需要额外的变量或操作。\nmemcpy() 函数的使用示例 以下是一个使用 memcpy() 函数将一个数组的数据复制到另一个数组的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char src[] = \u0026#34;Hello, World!\u0026#34;; char dest[20]; // 使用 memcpy 函数复制数据 memcpy(dest, src, strlen(src) + 1); // +1 是为了包括字符串的终止符 \u0026#39;\\0\u0026#39; printf(\u0026#34;Source: %s\\n\u0026#34;, src); printf(\u0026#34;Destination: %s\\n\u0026#34;, dest); return 0; } 在这个示例中：\n我们定义了一个源数组 src，其中包含字符串 \u0026quot;Hello, World!\u0026quot;。 我们定义了一个目标数组 dest，大小足以容纳源数组的内容。 我们使用 memcpy() 函数将 src 数组的内容复制到 dest 数组。 复制操作包括了字符串的终止符 '\\0'，以确保目标数组中的字符串正确终止。 memcpy() 函数的工作原理 memcpy() 函数的工作原理是直接在内存级别复制字节数据。它不进行任何类型检查或优化，而是逐字节地将数据从源地址复制到目标地址。\n逐字节复制：\nmemcpy() 从源地址 src 开始，逐字节地读取数据，并将这些数据写入到目标地址 dest。 复制的字节数由参数 n 指定。 指针操作：\n源地址和目标地址通过指针传递，因此函数能够直接操作内存地址。 复制操作是按照内存地址的顺序进行的，从 src 开始依次向后复制 n 个字节到 dest。 不处理重叠：\nmemcpy() 假设源和目标内存区域不会重叠。 如果源和目标区域重叠，memcpy() 的行为未定义，可能会导致数据损坏。在这种情况下，应该使用 memmove() 函数。 memcpy() 函数的使用注意事项 内存重叠问题：\nmemcpy() 假设源和目标区域不重叠。如果内存区域重叠，可能会导致数据复制的过程出现问题，数据可能会被覆盖或损坏。 如果你需要在重叠的内存区域之间复制数据，应该使用 memmove()，它能够正确处理重叠区域。 目标内存大小：\n确保目标内存区域 dest 足够大，能够容纳复制的数据。如果目标内存区域不够大，可能会导致内存越界，造成未定义行为或程序崩溃。 类型不匹配：\nmemcpy() 直接复制字节数据，不关心数据的类型。因此，目标和源数据类型不匹配时，需要小心，确保数据类型和大小一致。 速度与效率：\nmemcpy() 是一个低级别的、直接的内存操作函数，通常比逐个元素复制数据更快，但它不进行任何优化。 在处理大块数据时，memcpy() 通常比手动逐字节复制更高效。 memcpy() 函数与其他内存操作函数的比较 memmove() 函数：\nmemmove() 函数类似于 memcpy() 函数，但它能够正确处理源和目标内存区域重叠的情况。 memmove() 在内部处理重叠区域的数据，确保数据不会在复制过程中被覆盖。 strcpy() 函数：\nstrcpy() 函数专用于复制以 \\0 结尾的字符串。 memcpy() 函数可以复制任意类型的内存数据，而不仅仅是字符串。 memset() 函数：\nmemset() 用于将内存区域中的所有字节设置为指定的值。 memcpy() 用于从一个内存区域复制数据到另一个内存区域。 memcpy() 函数的常见应用场景 数据复制：\nmemcpy() 常用于在内存中复制数据块，例如从一个数组复制到另一个数组。 在网络编程中，memcpy() 可以用于将数据包复制到缓冲区。 结构体复制：\n可以用于将一个结构体的数据复制到另一个相同类型的结构体中。例如，复制一个结构体数组的元素到另一个结构体数组。 内存初始化：\n使用 memcpy() 将初始化数据块复制到目标内存区域，以快速设置内存的初始状态。例如，初始化缓冲区或缓存数据。 文件处理：\n在文件 I/O 操作中，memcpy() 可以用于将文件内容读入到内存缓冲区，或将缓冲区的数据写入到文件。 memcpy() 函数的使用代码示例 以下是使用 memcpy() 函数复制结构体数据的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef struct { int id; char name[20]; float salary; } Employee; int main() { Employee emp1 = {1, \u0026#34;John Doe\u0026#34;, 50000.0}; Employee emp2; // 使用 memcpy 复制结构体数据 memcpy(\u0026amp;emp2, \u0026amp;emp1, sizeof(Employee)); printf(\u0026#34;Employee 2 - ID: %d, Name: %s, Salary: %.2f\\n\u0026#34;, emp2.id, emp2.name, emp2.salary); return 0; } 在这个示例中：\n我们定义了一个 Employee 结构体，并创建了两个 Employee 类型的变量 emp1 和 emp2。 使用 memcpy() 将 emp1 的数据复制到 emp2，包括 id、name 和 salary。 复制后，我们打印 emp2 的数据，验证 memcpy() 的复制效果。 ","permalink":"https://oheyu.github.io/zh/posts/tech/memcpy%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","summary":"memcpy() 函数是 C 标准库中用于内存操作的一个重要函数，它被广泛用于在内存中复制数据块。在系统编程和低级数据操作中，memcpy() 是一个常用且高效的","title":"memcpy()函数详解"},{"content":"\r在 UNIX/Linux 操作系统中，信号（Signal）是一种进程间的通信机制，用于通知进程特定的事件发生。信号是异步的，允许进程在无需轮询的情况下处理来自系统或其他进程的事件。今儿个，咱们来唠一唠信号的概念、处理方法、以及在 C++ 中的实现。\n一、什么是信号？ 信号是一种用于通知进程发生特定事件的软中断机制。信号可以由操作系统、硬件设备、用户（例如通过 Ctrl+C）或其他进程发出。信号允许进程异步地响应事件，例如异常情况、外部中断等。\n信号的主要特性包括： 异步性：信号可以在任意时刻被发送，接收进程并不需要主动查询。 软中断：信号不会强行中断进程，而是通知它处理特定的事件。 系统资源管理：信号机制帮助操作系统管理进程生命周期、资源、权限和状态。 二、信号的处理方式 当一个进程接收到信号时，操作系统为其提供了三种处理方式：\n2.1 默认处理 大多数信号都有默认的处理方式。例如，收到 SIGTERM 信号时，默认行为是终止进程；收到 SIGSEGV 信号时，进程会被终止并生成核心转储文件。程序可以选择不修改这些默认行为。\n2.2 自定义处理 进程可以通过定义信号处理函数（signal handler）来覆盖信号的默认处理方式。当进程接收到指定信号时，操作系统将调用用户定义的处理函数来执行自定义逻辑。\n2.3 忽略信号 某些信号允许进程选择忽略它们。例如，程序可以忽略 SIGPIPE 信号，避免在向关闭的套接字写数据时导致进程终止。\n三、使用 signal() 设置信号处理函数 在 UNIX/Linux 系统中，可以使用 signal() 函数来设置信号的处理方式。该函数允许开发者为特定信号定义自定义处理函数，或者选择恢复默认处理或忽略信号。\n3.1 signal() 函数的原型 1 sighandler_t signal(int signum, sighandler_t handler); signum：信号的编号，例如 SIGINT（中断信号）。 handler：信号处理函数，可以是自定义函数，SIG_IGN（忽略信号）或 SIG_DFL（恢复默认行为）。 四、信号处理函数的编写 信号处理函数是一个符合特定原型的函数，它在信号到达时被操作系统调用。该函数通常只接收一个参数，即信号的编号。\n信号处理函数的原型：\n1 void signalHandler(int signum); 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;csignal\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 自定义信号处理函数 void signalHandler(int signum) { std::cout \u0026lt;\u0026lt; \u0026#34;Received signal: \u0026#34; \u0026lt;\u0026lt; signum \u0026lt;\u0026lt; std::endl; // 处理信号的逻辑 } int main() { // 设置 SIGINT 信号的处理函数 signal(SIGINT, signalHandler); std::cout \u0026lt;\u0026lt; \u0026#34;Press Ctrl+C to send SIGINT signal...\u0026#34; \u0026lt;\u0026lt; std::endl; // 无限循环等待信号 while (true) { sleep(1); } return 0; } 在上面的代码中，当用户按下 Ctrl+C 时，SIGINT 信号被发送给程序，操作系统调用 signalHandler 函数来处理这个信号，输出收到信号的编号。\n五、常见信号及其默认行为 以下是一些常见的信号及其默认行为：\n信号编号 信号名称 描述 默认行为 SIGINT 中断信号 用户通过键盘（Ctrl+C）触发 终止进程 SIGTERM 终止信号 请求正常终止进程 终止进程 SIGKILL 强制终止 无法被捕捉或忽略，强制终止进程 立即终止进程 SIGSEGV 段错误 无效的内存访问，如访问非法地址 终止进程，并生成核心转储 SIGPIPE 管道破裂 写入一个读端已经关闭的管道 终止进程 SIGALRM 定时器信号 定时器到期 终止进程 六、信号处理中的注意事项 6.1 信号处理函数的简洁性 由于信号处理函数是异步调用的，在信号处理函数中，必须保证代码尽可能简短，避免复杂操作。例如，标准库中的很多函数（如 malloc、printf 等）在信号处理函数中是不安全的，因为它们可能会在多个信号到达时产生未定义行为。\n建议使用：\nwrite() 代替 printf()。 使用全局标志位记录信号状态，并在主循环中处理复杂逻辑。 6.2 线程安全与信号重入问题 信号处理函数是异步的，可能在执行过程中被新的信号打断（信号的重入问题）。为了避免这种情况，信号处理函数应避免使用非线程安全的函数，并考虑使用信号屏蔽机制来阻止其他信号的干扰。\n屏蔽信号： 可以使用 sigprocmask() 来屏蔽在信号处理期间不希望处理的信号，确保信号处理函数的执行是安全的。\n6.3 特殊信号的处理 某些信号如 SIGKILL 和 SIGSTOP 是无法被捕捉或忽略的。SIGKILL 是一种强制终止信号，通常用于无法通过其他信号终止的进程；SIGSTOP 则用于暂停进程，无法被进程自身阻止或处理。\n七、高级信号处理：使用 sigaction() 尽管 signal() 函数足以应对大多数简单的信号处理场景，但在实际开发中，使用 sigaction() 提供更强大的控制功能。sigaction() 允许开发者指定更复杂的信号处理行为，如信号阻塞、自动恢复等。\nsigaction() 函数的原型：\n1 int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); signum：信号编号。 act：新的信号处理行为。 oldact：保存旧的信号处理行为。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;csignal\u0026gt; #include \u0026lt;unistd.h\u0026gt; void signalHandler(int signum) { std::cout \u0026lt;\u0026lt; \u0026#34;Interrupt signal (\u0026#34; \u0026lt;\u0026lt; signum \u0026lt;\u0026lt; \u0026#34;) received.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { struct sigaction action; action.sa_handler = signalHandler; // 设置自定义处理函数 sigemptyset(\u0026amp;action.sa_mask); // 清空阻塞的信号集 action.sa_flags = 0; // 使用 sigaction 设置 SIGINT 的处理行为 sigaction(SIGINT, \u0026amp;action, NULL); while (true) { std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for signal...\u0026#34; \u0026lt;\u0026lt; std::endl; sleep(1); } return 0; } 在这个例子中，sigaction() 允许开发者对信号处理的控制更加细致，例如阻塞某些信号并恢复处理前的状态。\n八、总结 信号机制是 UNIX/Linux 操作系统中重要的进程间通信手段，通过它可以异步地处理系统级事件和进程间通信。C++ 提供了 signal() 和 sigaction() 等函数，帮助开发者方便地管理信号处理。理解信号的工作原理、捕捉和屏蔽信号的正确方式，有助于编写更健壮、更高效的系统程序。\n","permalink":"https://oheyu.github.io/zh/posts/tech/linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%9C%A8cpp%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"在 UNIX/Linux 操作系统中，信号（Signal）是一种进程间的通信机制，用于通知进程特定的事件发生。信号是异步的，允许进程在无需轮询的情况下处理来自系统","title":"Linux信号机制及其在CPP中的实现"},{"content":"\r在并发编程中，互斥锁（Mutex）是保证多个线程或进程访问共享资源时数据一致性的重要同步机制。它通过限制同时访问某段代码的线程数，避免数据竞争和不可预期的行为。在 C++ 中，互斥锁广泛用于多线程编程以保证线程安全。\n一、什么是互斥锁？ 互斥锁（Mutex）全称是 “Mutual Exclusion Lock”，是一种用于保证共享资源不被多个线程同时访问的锁机制。它的基本功能是在同一时刻只允许一个线程进入临界区，从而避免数据竞争。\n1.1 互斥锁的两种状态 互斥锁的状态非常简单：\n锁定状态（Locked）：当一个线程成功获取互斥锁时，其他线程将被阻塞，直到该线程释放锁。 解锁状态（Unlocked）：当持有锁的线程完成操作并释放锁后，其他等待的线程才能获取到锁并继续执行。 互斥锁的操作通常包括以下两种：\nlock()：尝试获取互斥锁。如果锁已经被其他线程持有，当前线程将进入等待状态，直到锁可用。 unlock()：释放锁，允许其他等待线程获取锁。 C++ 标准库提供了 std::mutex，用于实现基本的互斥锁功能。\n二、互斥锁的典型用法 互斥锁通常用于保护共享数据或共享资源，以防止多个线程同时访问并引发数据不一致的问题。以下是一些常见的应用场景：\n2.1 保护共享变量 在多线程程序中，如果多个线程同时访问和修改某个共享变量，会导致数据竞争，从而产生不可预测的结果。通过互斥锁，程序可以保证一次只有一个线程可以访问这个变量，确保数据安全。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx; // 创建一个互斥锁 int shared_data = 0; void updateData() { mtx.lock(); // 获取锁 ++shared_data; // 修改共享数据 mtx.unlock(); // 释放锁 } int main() { std::thread t1(updateData); std::thread t2(updateData); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;Shared data: \u0026#34; \u0026lt;\u0026lt; shared_data \u0026lt;\u0026lt; std::endl; // 输出 2 return 0; } 在这个示例中，mtx.lock() 确保在同一时刻只有一个线程可以更新 shared_data。\n2.2 线程间通信：生产者-消费者模型 生产者-消费者模式是一种经典的并发编程模型，多个线程可能会同时向一个共享缓冲区写入或读取数据。为了避免多个线程在操作缓冲区时导致数据竞争，需要使用互斥锁来保护对缓冲区的访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; std::mutex mtx; std::queue\u0026lt;int\u0026gt; buffer; std::condition_variable cond_var; void producer() { for (int i = 0; i \u0026lt; 10; ++i) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); buffer.push(i); // 添加数据到缓冲区 cond_var.notify_one(); // 通知消费者 } } void consumer() { while (true) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); cond_var.wait(lock, []{ return !buffer.empty(); }); // 等待缓冲区有数据 int data = buffer.front(); buffer.pop(); std::cout \u0026lt;\u0026lt; \u0026#34;Consumed: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; if (data == 9) break; // 消费完所有数据后退出 } } int main() { std::thread prod(producer); std::thread cons(consumer); prod.join(); cons.join(); return 0; } 在这个示例中，生产者线程和消费者线程通过互斥锁保护缓冲区，确保线程安全。\n三、互斥锁的实现原理 互斥锁的实现依赖于底层的硬件原子操作和操作系统提供的同步机制。以下是几种常见的实现方式：\n3.1 自旋锁（Spinlock） 自旋锁是一种简单的锁机制，当一个线程无法获取锁时，它会持续尝试获取锁而不让出 CPU。这种方式适用于锁持有时间非常短的场景，因为它避免了线程切换的开销。\n1 2 3 4 5 6 7 8 9 10 11 std::atomic_flag lock = ATOMIC_FLAG_INIT; void spinLock() { while (lock.test_and_set(std::memory_order_acquire)) { // busy-wait (自旋等待) } } void spinUnlock() { lock.clear(std::memory_order_release); } 3.2 休眠锁（Sleep Lock） 与自旋锁不同，休眠锁会在无法获取锁时将线程挂起，让操作系统调度其他线程执行。当锁可用时，线程被唤醒并尝试获取锁。这种方式适用于锁持有时间较长的场景。\n四、使用互斥锁的注意事项 4.1 避免死锁 死锁是指两个或多个线程相互等待对方释放资源而永远无法继续执行的情况。避免死锁的常用方法包括：\n锁的获取顺序保持一致：多个线程获取多个锁时，必须按照相同的顺序获取锁。 使用 std::lock 同时锁定多个互斥锁：std::lock 可以一次性获取多个锁，避免死锁。 1 2 3 4 5 6 7 8 std::mutex mtx1, mtx2; void safeThreadFunc() { std::lock(mtx1, mtx2); // 一次性获取多个锁 std::lock_guard\u0026lt;std::mutex\u0026gt; lock1(mtx1, std::adopt_lock); std::lock_guard\u0026lt;std::mutex\u0026gt; lock2(mtx2, std::adopt_lock); // 处理共享数据 } 4.2 使用 RAII 管理锁的获取与释放 为了避免忘记释放锁，推荐使用 RAII 模式。std::lock_guard 和 std::unique_lock 是标准库提供的锁管理类，它们能够在作用域结束时自动释放锁。\n1 2 3 4 5 6 std::mutex mtx; void safeFunction() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); // 自动获取和释放锁 // 临界区代码 } 4.3 减少锁的持有时间 为了提高程序的并发性能，应尽量缩小临界区的范围，减少锁的持有时间。长时间持有锁会导致其他线程无法及时获取资源，降低系统效率。\n1 2 3 4 5 6 7 8 void process() { prepareData(); // 处理不需要锁的部分 { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); // 临界区代码，尽量简短 } postProcessData(); } 4.4 考虑锁的粒度 锁的粒度指的是锁保护的资源范围。粒度过大，容易导致线程频繁等待；粒度过小，则可能增加死锁风险。选择合适的锁粒度，能够在性能和安全性之间取得平衡。\n五、结论 互斥锁是并发编程中不可或缺的同步工具，能够有效防止数据竞争，确保多线程环境下的资源安全。在实际开发中，使用互斥锁时需要格外小心，避免死锁、长时间持有锁以及锁管理不当等问题。通过合理使用互斥锁和 RAII 模式，我们可以编写出安全、健壮的并发程序，并且在多线程环境下确保数据的一致性和程序的稳定性。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E6%A6%82%E5%BF%B5%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","summary":"在并发编程中，互斥锁（Mutex）是保证多个线程或进程访问共享资源时数据一致性的重要同步机制。它通过限制同时访问某段代码的线程数，避免数据竞","title":"CPP中的互斥锁：概念、实现与使用技巧"},{"content":"\r在 C++ 编程中，函数调用栈是管理函数调用和返回的核心机制，它帮助程序高效管理函数的执行流程，包括参数传递、局部变量的存储和函数返回的控制。理解函数调用栈的工作原理不仅对调试程序至关重要，还对优化代码性能、处理递归问题、避免栈溢出等方面有着深远的影响。\n一、什么是函数调用栈？ 函数调用栈是计算机程序在运行时用来追踪函数调用和返回的内存区域。它是一种栈数据结构，遵循先进后出（LIFO，Last In First Out）的原则。\n每当程序调用一个函数时，系统会为该函数创建一个栈帧（stack frame），用于保存该函数的参数、局部变量、返回地址以及当前的 CPU 寄存器状态；当函数执行结束返回时，栈帧会被销毁。函数调用栈确保了函数的执行是线性且可追溯的。\n二、函数调用栈的结构 每次函数调用时，系统会在栈上创建一个栈帧。一个典型的栈帧包含以下四个部分：\n返回地址：每当函数被调用时，程序需要知道在函数执行完毕后返回的地址。返回地址通常是调用该函数的位置，它在栈帧中保存，以便函数结束后程序可以继续从正确的指令位置执行。\n函数参数：函数的参数在调用栈上也占有一部分内存区域。当函数被调用时，传入的参数会被复制到栈帧中，供函数体内部使用。\n局部变量：函数内部定义的局部变量也存储在栈帧中，这些变量的生命周期仅限于该函数执行的范围。当函数返回时，这些局部变量就会被销毁。\n寄存器状态：调用函数时，CPU 的寄存器状态需要保存下来，以便在函数返回后恢复原有的状态。这个操作确保了函数调用前后的执行环境保持一致。\n三、函数调用栈的工作原理 3.1 函数调用过程 当一个函数被调用时，系统会执行以下步骤：\n保存返回地址：将调用函数的返回地址压入栈中。 创建栈帧：为被调用的函数分配一个新的栈帧，保存函数参数、局部变量以及 CPU 的当前状态。 更新栈指针：栈指针会向下移动，指向新的栈顶。 3.2 函数执行过程 函数的局部变量和参数被分配在栈帧中，程序通过栈指针和帧指针访问这些变量。由于栈的内存分配和释放效率非常高，函数调用栈能够快速地创建和销毁栈帧。\n3.3 函数返回过程 当函数执行完毕后，系统会执行以下步骤：\n恢复寄存器状态：从栈帧中恢复函数调用前保存的寄存器状态。 恢复返回地址：弹出栈帧，程序跳转到返回地址继续执行。 栈帧销毁：栈指针恢复到函数调用前的状态，当前函数的栈帧被销毁。 四、栈溢出（Stack Overflow）及其原因 栈溢出是一种运行时错误，通常发生在函数调用栈超出系统分配的内存限制时。栈溢出的典型原因包括：\n4.1 递归调用过深 递归函数在每次递归调用时都会创建新的栈帧。如果递归深度过大，系统分配给栈的空间就可能不够，导致栈溢出。\n1 2 3 4 5 6 7 void recursiveFunction() { recursiveFunction(); // 无限递归 } int main() { recursiveFunction(); // 导致栈溢出 } 这个程序因无限递归不断消耗栈空间，最终导致栈溢出。\n4.2 局部变量过大 如果函数的局部变量占用了过多的栈空间，也会导致栈溢出，尤其是在嵌套函数调用较多时。\n1 2 3 void largeArrayFunction() { int largeArray[100000]; // 分配过大的局部数组 } 五、函数调用栈的实际应用与调试 5.1 调试函数调用栈 函数调用栈在调试程序时非常重要，特别是通过工具如 gdb、lldb 等调试器，可以查看当前的调用栈、了解程序的执行路径以及各个函数的参数和局部变量的状态。\n查看调用栈： 使用调试工具中的 backtrace 命令，可以查看程序在当前时刻的调用栈。\n示例（使用 gdb）：\n1 2 3 gdb ./my_program (gdb) run (gdb) backtrace 5.2 函数调用栈优化 减少递归深度：避免不必要的深度递归，或使用尾递归优化。 局部变量优化：避免在栈上分配过大的局部变量，特别是数组或大型对象。 5.3 递归优化（尾递归） 尾递归是一种特殊的递归形式，编译器可以通过优化将其转换为迭代，从而避免栈溢出。实现尾递归可以显著减少递归调用栈的深度。\n1 2 3 4 int tailRecursiveFactorial(int n, int result = 1) { if (n == 1) return result; return tailRecursiveFactorial(n - 1, n * result); // 尾递归 } 尾递归允许编译器在每次递归调用时直接复用栈帧，避免栈的无限增长。\n六、现代 C++ 与函数调用栈 6.1 栈与堆的协同工作 在 C++ 中，函数调用栈主要用于存储局部变量、参数和函数返回地址，而动态分配的对象存储在堆中。合理管理栈与堆的使用有助于提升程序的性能和内存利用效率。\n6.2 RAII（Resource Acquisition Is Initialization） RAII 是 C++ 中的一种资源管理惯用法，利用栈帧的自动销毁特性来管理资源。在函数返回时，栈帧中的局部对象会被自动析构，这使得资源的释放变得更加自动化和安全。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class FileHandler { public: FileHandler(const std::string\u0026amp; filename) { file = fopen(filename.c_str(), \u0026#34;r\u0026#34;); } ~FileHandler() { if (file) fclose(file); } private: FILE* file; }; void processFile(const std::string\u0026amp; filename) { FileHandler handler(filename); // RAII 方式管理文件资源 } 在函数返回时，FileHandler 的析构函数会自动关闭文件，避免了资源泄漏。\n七、总结 函数调用栈是 C++ 程序管理函数调用和返回的重要机制，它通过栈帧的形式保存每次函数调用的参数、局部变量和返回地址。理解函数调用栈的工作原理对编写高效的代码、避免栈溢出和调试程序至关重要。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/","summary":"在 C++ 编程中，函数调用栈是管理函数调用和返回的核心机制，它帮助程序高效管理函数的执行流程，包括参数传递、局部变量的存储和函数返回的控制。理解函","title":"函数调用栈"},{"content":"\r在多进程编程中，共享内存是一种常用的进程间通信机制，允许多个进程访问同一块物理内存。这种方式不仅能够提高效率，还可以减少数据在进程间拷贝的开销。然而，在使用共享内存时，数据类型的选择至关重要，特别是在涉及动态内存分配的复杂数据类型时，比如 std::string。不当的使用可能导致数据的不一致或内存问题。我们来详细分析为什么在共享内存中应避免使用 std::string，并建议使用 char[] 作为替代方案。\n一、共享内存的基本原理 共享内存段是一块特殊的物理内存区域，可以被多个进程映射到各自的虚拟地址空间中。由于这块内存是共享的，所有进程可以直接访问相同的物理内存数据，而不需要进行复杂的 IPC（进程间通信）或拷贝操作。这使得共享内存非常适合用于需要频繁交换大量数据的场景，如数据库缓存、图像处理等高性能需求的领域。\n二、std::string 的内存管理机制 std::string 是 C++ 标准库中的字符串类，提供了动态扩展、字符处理等功能。为了实现这些功能，std::string 通常涉及动态内存分配。\n动态内存分配：当字符串的大小超过某个阈值时，std::string 会在堆上动态分配内存来存储实际的字符串内容，而字符串对象本身只保存一个指向堆中字符数组的指针。 堆内存管理：堆内存的分配与释放由 std::string 内部自动处理，开发者无需显式干预。std::string 对象通过其内部的指针操作堆上的数据。 虽然 std::string 使用起来十分方便，但它依赖于动态内存分配的特性给共享内存带来了问题。\n三、多进程堆内存管理的独立性 在操作系统中，每个进程的堆内存是独立的，即便两个进程执行相同的代码，它们的堆内存空间也是不同的。即使两个进程共享了某块共享内存，它们的堆内存区域依然各自独立，无法相互访问。\n堆内存独立性：每个进程都有自己的堆，动态内存的分配和释放是由操作系统为每个进程单独管理的。因此，进程 A 中的堆地址在进程 B 中无效。即便两个进程拥有同样的 std::string 对象，其内部的指针也指向不同的堆内存区域。\n共享内存的局限性：当 std::string 对象存储在共享内存中时，虽然 std::string 本身可以在共享内存中访问，但其指向的堆内存并不在共享内存中。因此，当另一个进程试图访问该 std::string 时，访问的将是该进程的无效指针，这导致了未定义行为。\n1 2 3 struct SharedData { std::string text; }; 如果将上面结构体的 SharedData 置于共享内存中，两个进程访问 text 字段时会出现问题，因为每个进程中的 std::string 内部指针指向不同的堆内存，造成数据不一致或程序崩溃。\n四、为什么 std::string 在共享内存中不可靠？ 4.1 动态分配的指针问题 std::string 依赖堆来存储字符数据。每个进程有独立的堆内存空间，堆中的地址只在进程本地有效。因此，当进程 A 使用 std::string 分配堆内存并存储字符串时，另一个进程 B 即便能够通过共享内存访问 std::string 对象的元数据，但由于 std::string 的指针指向进程 A 的堆，进程 B 无法通过该指针访问到正确的数据。\n4.2 未定义行为 如果共享内存中的 std::string 在某个进程中被修改，而其他进程尝试访问或操作该字符串对象，结果是不可预期的，通常会引发以下问题：\n崩溃：由于进程之间无法共享堆指针，访问无效地址可能导致程序崩溃。 数据损坏：即使程序不崩溃，访问错误的数据区域可能导致数据被破坏，进而影响程序的正常运行。 内存泄漏：如果一个进程释放了 std::string 的内存，而其他进程仍然尝试访问该对象，会导致内存泄漏或访问空指针。 五、选择 char[] 作为替代方案 与 std::string 的动态内存分配机制不同，char[] 是一个简单的字符数组，直接存储字符数据，不依赖堆内存。因此，char[] 更适合在共享内存中使用。\n5.1 固定内存位置 当你使用 char[] 时，字符数组可以直接分配在共享内存中。每个进程都能够通过共享内存访问相同的物理内存，避免了堆内存的复杂性和不一致性问题。\n1 2 3 struct SharedData { char text[256]; // 固定大小的字符数组 }; 在此示例中，char[] 数组的内容完全存储在共享内存中，每个进程都能安全地读取和修改该数组的数据，且数据在所有进程中的内存位置一致。\n5.2 简单而高效 相比 std::string，char[] 没有动态分配的复杂性，字符数组的大小是固定的，所有数据都存储在共享内存中。使用 char[] 时，所有进程都共享相同的物理地址，避免了指针不一致的问题。\n六、实际开发中的建议 在多进程编程中，使用共享内存时应选择适当的数据结构，避免使用涉及动态分配内存的类型，如 std::string。为了确保数据一致性和进程间通信的可靠性，char[] 是更安全的选择。\n6.1 使用 char[] 的场景 简单字符串交换：当需要在多个进程间交换简单的文本数据时，使用 char[] 作为存储结构，可以保证字符串在所有进程间的一致性。 固定大小的数据块：如果数据量相对固定，使用 char[] 来代替 std::string 既能保证性能，又能避免内存泄漏等问题。 6.2 考虑数据大小的限制 使用 char[] 需要提前确定字符串的最大长度。如果字符串长度不确定，可以通过额外的协议或消息传递机制来处理变长数据。这是使用 char[] 时唯一需要考虑的限制。\n七、总结 在共享内存中使用 std::string 可能导致严重的内存管理问题，因为每个进程的堆内存是独立的，std::string 的动态内存分配会导致指针在不同进程间失效，进而引发未定义行为。相比之下，使用简单的 char[] 数组可以有效避免这些问题，保证进程间共享数据的一致性和安全性。\n通过理解共享内存的基本原理和 std::string 的内存管理机制，开发者可以避免常见的陷阱，选择正确的数据类型来构建稳定、可靠的多进程程序。在多进程通信中，char[] 是一个高效且安全的选择。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%BA%E5%95%A5%E8%A6%81%E9%81%BF%E5%85%8Dstring%E5%AF%B9%E8%B1%A1/","summary":"在多进程编程中，共享内存是一种常用的进程间通信机制，允许多个进程访问同一块物理内存。这种方式不仅能够提高效率，还可以减少数据在进程间拷贝的开","title":"CPP中共享内存的使用：为啥要避免string对象"},{"content":"\r在 C++ 编程中，仿函数（Function Objects, Functors）是一种强大的工具，它不仅可以像普通函数那样调用，还可以携带状态、使用类的继承和多态来实现更加复杂的逻辑。在很多情况下，仿函数比普通函数和函数指针更灵活、功能更强大，因此在现代 C++ 中得到了广泛的应用，尤其是在标准模板库（STL）中。\n一、什么是仿函数？ 仿函数是通过重载函数调用运算符 operator() 的类的对象，使得这些对象可以像函数一样被调用。仿函数的关键在于它可以携带状态，与普通函数不同，仿函数既具备函数的调用方式，又具备对象的持久性和灵活性。\n1.1 仿函数的基本实现 下面是一个简单的仿函数示例，定义了一个可以计算两个数乘积的类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; class Multiply { public: int operator()(int a, int b) const { return a * b; } }; int main() { Multiply multiply; // 创建仿函数对象 int result = multiply(3, 4); // 像调用函数一样使用仿函数 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; // 输出 12 return 0; } 在这个例子中，Multiply 类重载了 operator() 运算符，使其对象可以像普通函数那样被调用。multiply(3, 4) 直接返回两个整数的乘积。\n二、仿函数的优势 仿函数相较于普通函数或者函数指针，提供了更强大的功能。在 C++ 的实际开发中，仿函数具备以下几大优势：\n2.1 状态持久性 普通函数通常是无状态的，每次调用后都不会保存任何信息，而仿函数可以通过类的成员变量保存状态。举个例子，我们可以实现一个计数器仿函数，每次调用它都会递增计数值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; class Counter { private: int count; public: Counter() : count(0) {} int operator()(int increment) { count += increment; return count; } }; int main() { Counter counter; std::cout \u0026lt;\u0026lt; counter(1) \u0026lt;\u0026lt; std::endl; // 输出 1 std::cout \u0026lt;\u0026lt; counter(1) \u0026lt;\u0026lt; std::endl; // 输出 2 std::cout \u0026lt;\u0026lt; counter(5) \u0026lt;\u0026lt; std::endl; // 输出 7 return 0; } 这里的 Counter 仿函数在每次调用时，都会更新内部的 count 状态，保持了调用之间的累积信息。普通函数无法做到这一点，除非通过全局变量或静态变量来辅助。\n2.2 可继承性与多态性 仿函数不仅仅是一个函数调用，它实际上是一个类，因此可以使用 C++ 的面向对象特性。通过继承和多态，仿函数可以在不同场景下实现不同的行为。例如，我们可以定义不同的策略类，并使用仿函数在运行时灵活选择不同的行为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; class Strategy { public: virtual int operator()(int a, int b) const = 0; }; class Add : public Strategy { public: int operator()(int a, int b) const override { return a + b; } }; class Multiply : public Strategy { public: int operator()(int a, int b) const override { return a * b; } }; void executeStrategy(const Strategy\u0026amp; strategy, int a, int b) { std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; strategy(a, b) \u0026lt;\u0026lt; std::endl; } int main() { Add add; Multiply multiply; executeStrategy(add, 3, 4); // 输出 7 executeStrategy(multiply, 3, 4); // 输出 12 return 0; } 通过这种方式，仿函数不仅实现了不同的逻辑，还可以通过多态灵活扩展功能，使得程序更加灵活和可维护。\n2.3 性能优化 在 C++ 中，仿函数通常是内联的，这意味着编译器可以在编译时将仿函数直接展开，减少函数调用的开销。相比函数指针，仿函数在性能敏感的场景中更具优势，特别是在大规模循环或 STL 算法中频繁调用时，仿函数能带来显著的性能提升。\n三、仿函数在 STL 中的应用 仿函数在 C++ 的标准模板库（STL）中被广泛应用，特别是在算法和容器中。STL 中许多算法，如 std::sort、std::for_each 等，支持将仿函数作为参数传递，从而使算法更加灵活。\n3.1 自定义排序规则 STL 的 std::sort 可以接受一个仿函数作为参数，用来定义自定义的排序规则。以下示例展示了如何使用仿函数实现降序排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; class Compare { public: bool operator()(int a, int b) const { return a \u0026gt; b; // 降序 } }; int main() { std::vector\u0026lt;int\u0026gt; vec = {3, 1, 4, 1, 5, 9}; std::sort(vec.begin(), vec.end(), Compare()); // 使用仿函数进行排序 for (int n : vec) { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 输出 9 5 4 3 1 1 } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，Compare 仿函数定义了一个降序排序规则，并传递给 std::sort 进行排序操作。仿函数提供了一种灵活的方式来控制 STL 算法的行为。\n3.2 在回调机制中的应用 仿函数也可以用作回调函数，尤其在事件驱动编程模型或异步操作中，仿函数可以携带所需的状态，并在需要时执行相应的逻辑。\n四、高级仿函数：与模板和可变参数的结合 C++ 中的仿函数可以结合模板和可变参数，从而实现更加通用和灵活的功能。以下是一个支持任意数量参数的仿函数示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; class Printer { public: template\u0026lt;typename... Args\u0026gt; void operator()(Args... args) const { (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; args) \u0026lt;\u0026lt; std::endl; // 展开参数包并输出 } }; int main() { Printer print; print(1, 2, 3); // 输出 123 print(\u0026#34;Hello\u0026#34;, \u0026#34;, \u0026#34;, \u0026#34;world!\u0026#34;); // 输出 Hello, world! return 0; } 这个 Printer 仿函数可以接受任意数量的参数，并通过 C++17 的折叠表达式将参数输出到控制台。这展示了仿函数的灵活性和扩展性。\n五、总结 仿函数（Functors）在 C++ 中结合了函数调用的简单性和类的灵活性，具有状态保持、可继承性、多态性以及性能优化等诸多优势。它们广泛应用于标准模板库中的算法、回调机制以及高级模板编程中。\n状态保持：通过仿函数可以在调用之间保存状态，避免使用全局变量或静态变量。 可继承与多态：仿函数可以结合类的继承和多态，轻松实现不同的策略模式。 性能优化：由于仿函数通常是内联的，它们在性能上比函数指针更加高效，特别是在 STL 算法中频繁调用时。 掌握仿函数的使用，不仅能提高代码的灵活性，还能优化性能，是 C++ 高效编程的利器。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0functors/","summary":"在 C++ 编程中，仿函数（Function Objects, Functors）是一种强大的工具，它不仅可以像普通函数那样调用，还可以携带状态、使用类的继承和多态来","title":"CPP中的仿函数（Functors）"},{"content":"\r在 C++ 编程中，结构体（struct）是一种常用的数据结构，尤其是在需要组织和管理多个相关数据时。然而，当结构体中包含指向动态分配内存的指针时，如何正确使用 sizeof 和 memset 变得至关重要。误用这两个工具可能导致程序的潜在错误，甚至引发内存泄漏问题。\n一、结构体中的动态内存分配问题 我们可以从一个包含指针的简单结构体开始：\n1 2 3 4 struct Data { int* ptr; int size; }; 在这个结构体中，ptr 是一个指向动态内存的指针，而 size 用于表示分配的内存大小。典型的使用方式如下：\n1 2 3 Data d; d.size = 10; d.ptr = new int[d.size]; // 动态分配内存 在这个例子中，ptr 指向了堆中的一块动态内存，而 d 本身则存储在栈中或堆中（取决于其声明方式）。尽管这看起来简单，但在内存管理上隐藏着诸多陷阱。\n二、使用 sizeof 的陷阱 2.1 sizeof 的工作原理 sizeof 是一个用于获取变量或类型占用内存大小的运算符。在使用结构体时，它会返回结构体中所有成员的总和，例如：\n1 std::cout \u0026lt;\u0026lt; \u0026#34;Size of Data: \u0026#34; \u0026lt;\u0026lt; sizeof(Data) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; 在这个例子中，假设指针大小为 8 字节，int 为 4 字节，那么 sizeof(Data) 可能会返回 12 字节（或在某些系统上，由于内存对齐可能是 16 字节）。\n2.2 为什么 sizeof 可能没有意义 在涉及动态分配的情况下，sizeof 只能计算结构体中指针的大小，而无法计算指针所指向的内存的大小。换句话说，sizeof 返回的结果并不包含 ptr 指向的动态内存，我们可以看下面的例子：\n1 2 3 4 5 Data d; d.size = 10; d.ptr = new int[d.size]; std::cout \u0026lt;\u0026lt; \u0026#34;Size of Data: \u0026#34; \u0026lt;\u0026lt; sizeof(d) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; 尽管此时 d.ptr 指向了 10 个 int 的数组，但 sizeof(d) 仍然只会返回结构体本身的大小（即 12 或 16 字节），而不是包含动态分配的内存。因此，使用 sizeof 来估计包含动态分配内存的结构体的大小是没有意义的。\n三、使用 memset 的风险 3.1 memset 的工作原理 memset 是 C 标准库中的函数，用于将内存区域设置为指定的值，通常用于初始化或清除内存：\n1 memset(\u0026amp;d, 0, sizeof(d)); 在这个例子中，memset 将 d 的整个内存区域都设置为 0。这包括 ptr 和 size，然而这带来了潜在的风险。\n3.2 memset 导致内存泄漏的原因 当结构体中包含动态分配的指针时，直接对结构体使用 memset 可能导致内存泄漏和未定义行为。为啥？因为：\n指针被覆盖：memset 操作将 ptr 也设置为 0（NULL），导致指针原本指向的动态内存丢失，而这些内存无法再被释放，进而引发内存泄漏。 错误释放内存：在 memset 操作后，ptr 指针不再指向有效的内存，因此后续的 delete[] d.ptr 操作将产生未定义行为，程序可能崩溃。 1 2 3 4 5 6 7 Data d; d.size = 10; d.ptr = new int[d.size]; memset(\u0026amp;d, 0, sizeof(d)); // 覆盖整个结构体的内存 delete[] d.ptr; // 未定义行为，ptr 已经被设置为 NULL 在这个例子中，由于 memset 覆盖了 ptr，它不再指向有效的内存地址，因此 delete[] 操作的行为未定义，可能导致程序崩溃或内存泄漏。\n四、正确的初始化与内存管理方式 那么，我们咋个整嘞？为了避免 sizeof 和 memset 带来的问题，我们应采用更安全的内存管理方式，特别是在结构体中包含动态内存时。\n4.1 使用构造函数和析构函数 C++ 提供了构造函数和析构函数来安全地管理动态内存。我们可以通过将结构体转为类，并定义构造函数和析构函数来确保内存正确分配和释放。\n1 2 3 4 5 6 7 8 9 10 11 12 struct Data { int* ptr; int size; // 构造函数 Data(int s) : size(s), ptr(new int[s]) {} // 析构函数 ~Data() { delete[] ptr; } }; 在这个例子中，Data 类的构造函数会自动为 ptr 分配内存，而析构函数确保了内存被正确释放。这样可以有效避免内存泄漏和未定义行为。\n4.2 手动释放动态内存 如果你必须使用 memset 来清除结构体，在调用 memset 之前必须手动释放动态分配的内存。\n1 2 delete[] d.ptr; // 首先释放动态内存 memset(\u0026amp;d, 0, sizeof(d)); // 然后初始化结构体 通过先释放 ptr 指向的内存，再调用 memset，可以避免内存泄漏。\n五、使用智能指针 为了进一步简化内存管理，避免手动调用 new 和 delete，可以使用 C++11 引入的智能指针，例如 std::unique_ptr 或 std::shared_ptr。\n1 2 3 4 5 6 7 8 #include \u0026lt;memory\u0026gt; struct Data { std::unique_ptr\u0026lt;int[]\u0026gt; ptr; int size; Data(int s) : size(s), ptr(std::make_unique\u0026lt;int[]\u0026gt;(s)) {} }; 在这个例子中，std::unique_ptr 会自动管理内存的释放，避免内存泄漏，即使发生异常，智能指针也能够确保内存被正确释放。\n六、总结 在 C++ 中使用 sizeof 和 memset 操作包含指针的结构体时，开发者应当格外小心。sizeof 只能返回结构体本身的大小，而不包括动态内存的大小，因此对于包含指针的结构体使用 sizeof 是没有意义的。同样，memset 会覆盖结构体中的指针，导致指向动态内存的地址丢失，进而引发内存泄漏。\n为了避免这些问题，建议使用 C++ 提供的构造函数、析构函数来管理内存，或者使用智能指针来简化内存分配和释放。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86sizeof%E4%B8%8Ememset%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1/","summary":"在 C++ 编程中，结构体（struct）是一种常用的数据结构，尤其是在需要组织和管理多个相关数据时。然而，当结构体中包含指向动态分配内存的指针时，","title":"CPP中结构体的内存管理：sizeof与memset的使用陷阱"},{"content":"\r在 C++ 开发中，执行外部程序（如二进制文件、系统命令或 Shell 脚本）是一个常见的需求，尤其是在 Linux 系统中。C++ 提供了多种方式来实现这一功能，其中最常用的是 system() 函数和 exec 函数族。今天，我们一起来唠一唠。\n一、system() 函数：简单但有风险的解决方案 system() 是标准 C 库中的一个函数，用于执行系统命令。它通过调用系统的 Shell 来执行传递给它的命令，是一种相对简单的调用方式。尽管方便易用，但也存在一些潜在的安全隐患，特别是在处理不受信任的用户输入时。\n1.1 system() 的函数声明 1 int system(const char *command); 参数：command 是一个字符串，表示要执行的系统命令。 返回值：如果 Shell 能被正确执行，system() 返回 Shell 进程的返回值。如果出现错误（如没有可用的 Shell），它将返回一个非零值。 1.2 示例 执行一个简单的 Linux 命令，比如列出当前目录下的文件：\n1 system(\u0026#34;ls -la\u0026#34;); 这个调用会在 Shell 中执行 ls -la，并显示结果。\n1.3 system() 的优缺点 优点：\n简单易用：system() 非常直观，你只需提供一个字符串作为命令，系统会帮你处理余下的操作。 兼容性：由于 system() 是标准 C 函数，它可以跨平台工作，尽管不同平台上的细节可能会有所不同。 缺点：\n安全问题：system() 的最大问题是安全性，特别是在处理用户输入时。如果用户输入的命令直接传递给 system()，攻击者可能注入恶意代码。例如，用户输入 \u0026quot;; rm -rf /\u0026quot; 就可能会删除整个文件系统。因此，建议不要将用户输入直接传递给 system()，除非做了严格的验证。 性能开销：system() 会启动一个新的 Shell 进程来执行命令，这意味着每次调用都有额外的性能开销，特别是在需要频繁执行命令的场景下，这种开销可能会变得显著。 1.4 使用场景 system() 适用于一些简单的、非频繁的命令执行任务，例如在程序结束时调用 system(\u0026quot;pause\u0026quot;) 来暂停终端。 但是，在安全和性能要求较高的场景中，尽量避免使用 system()，而是选择更安全的替代方案。 二、exec 函数族：更灵活和安全的替代方案 与 system() 不同，exec 函数族提供了更直接、底层的方式来执行外部程序。它们不会创建新的进程，而是用新程序替换当前进程的映像。exec 函数族中的函数会立即将当前进程的代码和数据替换为新执行的程序，除非调用失败，否则它不会返回到原来的程序。\n2.1 exec 函数族的常见函数 exec 函数家族有多个变体，最常用的两个是：\nexecl()：将程序路径和参数作为变长参数传递。 execv()：传递程序路径和参数数组。 2.2 execl() 和 execv() 的函数声明 1 2 int execl(const char *path, const char *arg0, ..., NULL); int execv(const char *path, char *const argv[]); path：要执行的程序的路径。 arg0, ... / argv[]：要传递给新程序的参数。execl() 接受一系列变长参数，而 execv() 则接受一个指针数组。 2.3 示例 执行 ls -la 命令，使用 execl() 和 execv() 的等效代码如下：\n使用 execl()：\n1 execl(\u0026#34;/bin/ls\u0026#34;, \u0026#34;ls\u0026#34;, \u0026#34;-la\u0026#34;, NULL); 这里 /bin/ls 是要执行的命令路径，\u0026quot;ls\u0026quot; 是命令名，\u0026quot;-la\u0026quot; 是参数，最后一个 NULL 表示参数列表的结束。\n使用 execv()：\n1 2 char *args[] = {\u0026#34;ls\u0026#34;, \u0026#34;-la\u0026#34;, NULL}; execv(\u0026#34;/bin/ls\u0026#34;, args); execv() 的参数通过数组传递，最后一个元素必须为 NULL，以表示参数的结束。\n2.4 exec 的返回值 exec 函数只有在执行失败时才返回 -1，并设置 errno 来指示错误原因。如果成功执行，当前进程的代码将被新程序替换，且不会返回。\n2.5 exec 的优缺点 优点：\n灵活性：exec 函数族允许程序直接替换当前进程映像，这是 system() 无法做到的。这在需要运行一个长期运行的外部程序而不希望产生新进程时非常有用。 安全性：相较于 system()，exec 函数族更加安全，因为它不会经过 Shell 解析命令，减少了命令注入的风险。 缺点：\n使用复杂：exec 函数的调用比 system() 要复杂一些，特别是在处理参数时，需要额外的代码来构造参数数组或变长参数列表。 不会返回：成功调用 exec 后，原来的进程代码段、数据段会被新程序替换，因此调用之后的代码不会被执行。 2.6 使用场景 exec 函数族适合在当前进程中直接调用外部程序的场景，特别是在希望替换当前进程并执行新程序时非常有效，例如在服务器程序中 fork 子进程并通过 exec 执行新的任务。 它常用于需要更细粒度控制外部程序执行的场合，如编写守护进程、任务调度系统等。 三、system() 与 exec 的对比 特性 system() exec() 进程控制 启动一个新的 Shell 进程 替换当前进程 使用复杂度 简单，只需传递命令字符串 较复杂，需要处理参数 安全性 存在命令注入风险 更安全，不经过 Shell 解析 返回值 命令执行的返回值 仅在执行失败时返回 创建新进程 是 否，替换当前进程 参数传递 字符串 参数数组或变长参数 性能 需要创建新进程，开销较大 替换当前进程，开销较小 四、总结 在 C++ 开发中，选择 system() 还是 exec 函数族取决于具体的应用场景：\n如果你需要执行简单的外部命令，并且不太关注性能和安全问题，system() 是一个方便的选择。但要确保命令来源安全，避免命令注入攻击。 如果你需要更灵活和安全的控制，或者希望替换当前进程执行外部程序，exec 函数族则是更好的选择。 ","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/","summary":"在 C++ 开发中，执行外部程序（如二进制文件、系统命令或 Shell 脚本）是一个常见的需求，尤其是在 Linux 系统中。C++ 提供了多种方式来实现这一功能，其中最常用","title":"CPP中执行外部程序"},{"content":"\r在 C++ 开发中，全局变量和静态变量的使用是一个常见且重要的话题。虽然它们有着各自独特的特性，但在实际项目中，合理运用这些变量可以帮助我们提高代码的可读性和维护性，反之则可能带来难以发现的错误和隐患。\n一、全局变量的作用与局限 1.1 优势 全局变量因其在程序各个模块间共享数据的便利性而被广泛使用。它们可以被定义在程序的任意源文件中，并通过 extern 声明在其他源文件中访问。全局变量在以下情况下特别有用：\n状态共享：当多个模块、函数或类需要访问相同的数据时，全局变量可以用作一个共享的状态存储。例如，应用程序的配置参数、日志对象等常常被定义为全局变量，以便全局访问。 减少参数传递：在某些情况下，使用全局变量可以减少函数间大量传递参数的复杂性，特别是在需要在不同模块间传递多个状态时。 1.2 局限与风险 然而，全局变量的使用也带来了不少风险：\n命名冲突：由于全局变量可以在程序的任何地方被访问，如果项目中有多个开发者同时维护不同模块，可能会导致命名冲突，造成无法预期的错误。尽管可以使用命名空间来缓解这个问题，但仍然不能完全避免冲突。 难以维护：全局变量增加了模块之间的耦合度，导致代码维护难度加大。随着项目的复杂度增加，全局变量可能会分散在多个文件中，追踪它们的修改变得更加困难，容易导致意外的行为。 测试不便：全局变量由于在全局范围内可访问，往往难以对单独模块进行单元测试。因为全局状态可能会导致测试之间互相影响，难以保持测试环境的隔离性。 1.3 开发中的最佳实践 在现代C++开发中，尽量减少全局变量的使用是公认的最佳实践。可以通过以下方法替代全局变量：\n单例模式：当需要共享一个全局状态时，可以使用单例模式（Singleton）来保证只有一个实例存在，并且可以通过控制访问权限来减少对全局变量的不必要修改。 依赖注入：通过依赖注入（Dependency Injection）将依赖的对象或数据传递给需要的模块，避免全局状态的共享。 使用常量：对于全局只读的数据，可以使用 const 或 constexpr 来保证全局变量不可被修改，降低风险。 二、 静态变量的优点与使用场景 静态变量提供了与全局变量类似的功能，但作用范围更加局限，可以有效避免全局变量带来的问题。静态变量根据它们的定义位置可以分为局部静态变量和全局静态变量。\n2.1 局部静态变量 局部静态变量定义在函数或代码块内，虽然它们的生命周期与程序相同，但作用域仅限于该函数或代码块内。这使得局部静态变量非常适合用来维护状态，尤其在以下场景中非常有用：\n递归函数中的状态保存：在递归算法中，局部静态变量可以用于保存函数调用之间的状态。例如，在递归计算斐波那契数列时，可以使用静态变量来保存中间计算结果，避免重复计算。 只初始化一次：局部静态变量只会在函数第一次调用时被初始化，这可以避免每次调用函数时重复初始化的开销。在一些性能关键的代码中，这种特性非常有用。 2.2 全局静态变量 全局静态变量则定义在全局作用域中，但与普通全局变量不同，它们的作用域仅限于当前文件。这种限制作用域的特性使得全局静态变量可以用于模块内部的实现细节，避免其他模块误用。例如，某些模块内部的缓存机制或计数器可以使用全局静态变量来实现，而外部模块无法访问这些数据。\n隐藏实现细节：通过将全局静态变量定义在文件内部，可以确保这些变量不会暴露给其他文件，有效减少了模块之间的耦合。 避免命名冲突：由于全局静态变量不能被外部文件访问，因此即使不同文件中定义了相同名字的静态变量，也不会发生冲突。 2.3 静态变量的最佳实践 控制作用域：在使用静态变量时，应该尽可能将它们的作用范围限制在需要的最小范围内。对于局部静态变量，确保它们只在特定的函数中使用；对于全局静态变量，确保它们只在当前文件中有效。 避免滥用：虽然静态变量在保持状态和减少全局依赖上很有用，但也要避免过度使用静态变量。特别是在多线程环境中，静态变量可能引发数据竞争和不可预期的行为。因此，在并发编程中，应该使用锁或其他同步机制来保护静态变量的访问。 三、多线程中的静态与全局变量 在多线程程序中，全局变量和静态变量的使用需要格外小心。如果多个线程同时访问和修改这些变量，可能会导致数据竞争和未定义行为。常见的解决方案是：\n线程安全的访问：在访问全局变量或静态变量时，使用互斥锁（std::mutex）或读写锁来保护共享数据，确保同一时刻只有一个线程可以修改变量。 原子操作：对于简单的全局或静态计数器，可以使用 C++ 提供的原子类型（如 std::atomic）来避免锁的使用，提升性能。 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/","summary":"在 C++ 开发中，全局变量和静态变量的使用是一个常见且重要的话题。虽然它们有着各自独特的特性，但在实际项目中，合理运用这些变量可以帮助我们提高代码","title":"全局变量与静态变量"},{"content":"\r内存，也就是我们常说的内存条，是计算机系统中至关重要的组成部分，它不仅用于存储程序的代码和数据，还负责数据的快速访问和处理。计算机内部以字节为单位存储信息。当我们在程序中声明某种类型的变量时，实际上是在向系统申请一定数量的内存空间（以字节为单位）来存储数据。在本质上，所有与程序相关的内容都是关于内存中信息的表示和管理。\n在程序运行时，内存被划分为不同的区域，每个区域有其特定的用途和管理方式。以下是C++程序中常见的内存分区及其详细介绍：\n代码区（Code Segment） 代码区，也称为 .text 段，是存储程序的执行代码的区域。这个区域是只读的，以防止程序在运行过程中被意外修改。例如，编译后的 main 函数的逻辑存放在代码区。代码区还可能包含一些只读的常量，例如字符串字面量。\n1 2 3 4 5 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 全局/静态存储区（Global/Static Storage） 全局变量和静态变量存放在全局/静态存储区。C++ 中，全局变量和静态变量通常存放在同一块内存区，不再区分初始化的和未初始化的部分。而在 C 语言中，全局变量被分为 .data 段（初始化）和 .bss 段（未初始化），但在 C++ 中，它们共同占用全局/静态存储区。\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; int globalVar = 0; // 全局变量 void function() { static int staticVar = 0; // 静态变量 staticVar++; std::cout \u0026lt;\u0026lt; staticVar \u0026lt;\u0026lt; std::endl; } int main() { function(); function(); return 0; } 栈区（Stack） 栈区用于存储函数调用时的局部变量、函数参数以及返回地址。栈区的内存分配和释放由编译器自动管理，遵循后进先出（LIFO）原则。当函数调用完成后，分配给该函数的栈空间会被释放。\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; void function(int a, int b) { int localVar = a + b; std::cout \u0026lt;\u0026lt; localVar \u0026lt;\u0026lt; std::endl; } int main() { function(3, 4); return 0; } 在上面的例子中，a、b 和 localVar 都是局部变量，存放在栈区。函数调用结束后，栈区中对应的内存空间会被回收。\n堆区（Heap） 堆区用于动态内存分配。当使用 new（在C++中）或者 malloc（在C中）分配内存时，这些内存块会位于堆区。与栈区不同，堆区的内存分配和释放需要程序员手动管理，否则可能导致内存泄漏。\n1 2 3 4 5 6 7 #include \u0026lt;iostream\u0026gt; int main() { int* dynamicArray = new int[10]; // 动态分配内存 // 使用动态数组... delete[] dynamicArray; // 释放内存 return 0; } 常量区（Constant Storage） 常量区用于存储编译时确定的常量数据，例如字符串字面量和其他常量。这些数据通常是只读的，以确保它们在程序运行过程中不会被修改。\n1 2 3 4 5 #include \u0026lt;iostream\u0026gt; int main() { char* c = \u0026#34;abc\u0026#34;; // \u0026#34;abc\u0026#34; 在常量区，c 在栈上。 return 0; } ","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","summary":"内存，也就是我们常说的内存条，是计算机系统中至关重要的组成部分，它不仅用于存储程序的代码和数据，还负责数据的快速访问和处理。计算机内部以字节","title":"CPP内存模型"},{"content":"\r在 C/C++ 中，new/delete 与 malloc/free 的使用涉及内存分配和释放的机制，虽然它们的功能表面上类似，但在使用上存在许多本质上的区别，使用时务必配对使用，不可混用。\n一、new/delete 与 malloc/free 的对比分析 1.1 内存分配的来源 new/delete：内存从“自由存储区”（Free Store）分配。自由存储区是专门为 C++ 中对象管理的内存区域，它的管理由 C++ 的内存分配机制决定。new 分配的内存适合构造对象，因为它会自动调用构造函数。\nmalloc/free：内存从“堆”（Heap）分配。这是 C 语言标准中的内存分配机制，malloc 只知道要分配的字节数，不会涉及到对象的构造和析构。\n说到这里，不得不简单谈一下内存分区。事实上，内存分区没有一个统一的定义，根据 CSAPP 这本书，我们可以将内存分为：代码区、全局/静态存储区、堆区、栈区以及常量区。我们可以将前述的 ”自由存储区“ 视为堆区，但其不仅可以是堆区，还可以是静态存储区，这由 operator new 的具体实现决定。\n1.2 返回类型 new/delete：new 返回一个完全类型化的指针，即指向特定类型的对象，因此不需要手动进行类型转换。如果分配失败，new 会抛出异常（std::bad_alloc），这与返回 NULL 的方式不同。当然，我们也可使用关键字 std::nothrow 使其在分配失败时返回 nullptr。\nmalloc/free：malloc 返回 void* 指针，意味着需要手动将其转换为所需的类型。并且当 malloc 分配失败时，它会返回 NULL，这要求使用者在每次分配时检查返回值。\n1.3 内存大小的计算 new/delete：编译器在编译时根据类型自动计算所需的内存大小，因此不需要手动提供内存的大小。尤其在处理类对象时，编译器会根据对象的类型自动分配所需的空间。\nmalloc/free：调用 malloc 时，必须明确指定要分配的字节数，这意味着开发人员需要自己计算复杂类型的大小。这在处理数组或结构体时显得尤其繁琐。\n1.4 数组分配 new/delete：C++ 提供了 new[] 和 delete[] 来专门分配和释放数组，这些操作会调用每个对象的构造函数和析构函数，确保数组中每个元素被正确初始化和销毁。\nmalloc/free：malloc 分配数组时，需要开发者自己手动计算总的字节大小，而 free 不会调用析构函数，因此需要开发者手动管理数组元素的初始化和销毁。\n1.5 对象的构造与析构 new/delete：new 会自动调用对象的构造函数来初始化分配的内存，delete 则会调用析构函数来清理对象的资源。这一点对需要进行资源管理（如动态内存、文件句柄等）的类尤为重要。\nmalloc/free：malloc 仅仅分配内存，不会调用构造函数，因此对象不会自动初始化。同样，free 也不会调用析构函数，仅仅是释放分配的内存。\n1.6 内存重新分配 new/delete：new 没有提供重新分配内存的机制。对于重新分配，需要手动管理复制和删除旧的对象。这在处理复杂类型时会涉及拷贝构造函数和析构函数的调用。\nmalloc/free：malloc 可以与 realloc 一起使用，实现更大的内存块分配，而无需担心对象的构造和析构。对于简单的内存块操作，realloc 更为直观和方便。\n1.7 内存不足处理 new/delete：C++ 提供了 std::set_new_handler，可以自定义内存不足时的处理方式，这允许开发者在内存不足时采取一些措施（如释放内存或记录日志）。\nmalloc/free：malloc 没有类似的机制来处理低内存情况。当系统内存不足时，malloc 直接返回 NULL，用户无法在这一点插入自己的代码来进行处理。\n1.8 是否可以重载 new/delete：C++ 允许用户重载 operator new 和 operator delete，这样可以自定义内存分配和释放的行为。例如，可以实现自定义的内存池或内存跟踪机制。\nmalloc/free：malloc 和 free 是标准库函数，不能被合法重载，因此不支持自定义内存管理行为。\n","permalink":"https://oheyu.github.io/zh/posts/tech/free%E4%B8%8Emalloc%E4%BB%A5%E5%8F%8Anew%E4%B8%8Edelete/","summary":"在 C/C++ 中，new/delete 与 malloc/free 的使用涉及内存分配和释放的机制，虽然它们的功能表面上类似，但在使用上存在许多本质上的区别，使用时务必配对使用","title":"Free与malloc以及new与delete"},{"content":"\r在处理文本特别是涉及东亚语言时，对于 “半角” 和 “全角“ 这两个术语，使用计算机这么多年，我们也疑惑了这么多年。事实上，它们主要与字符在屏幕或页面上所占用的宽度有关。\n一、什么是半角字符？ 半角字符指的是那些占用标准字符宽度的字符。通常，这个宽度指的是一个英文字母或数字在单字节编码（如ASCII）中的显示宽度。半角字符广泛用于英文文本、数字以及常见的标点符号。例如：\n半角字母：A 半角数字：1 半角标点：. 二、什么是全角字符？ 全角字符则占用两个标准字符宽度。这种字符常用于显示汉字、日文假名、韩文字符以及特定的标点符号。全角字符在视觉上比半角字符宽，常用于中文、日文、韩文等东亚语言的文本中。例如：\n全角汉字：你 全角数字：１ 全角标点：， 三、半角与全角的比较 宽度：半角字符的宽度为一个单位，而全角字符的宽度为两个单位。 字符集：半角字符多见于ASCII字符集，而全角字符多见于Unicode字符集中。 应用场景：半角字符常用于英文文本，全角字符则多用于中文、日文、韩文等文本中。 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%8D%8A%E8%A7%92%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%85%A8%E8%A7%92%E5%AD%97%E7%AC%A6/","summary":"在处理文本特别是涉及东亚语言时，对于 “半角” 和 “全角“ 这两个术语，使用计算机这么多年，我们也疑惑了这么多年。事实上，它们主要与字符在屏幕或页","title":"半角字符与全角字符"},{"content":"\r在操作系统中，符号链接（Symbolic Link）是一种常用的文件系统功能，它允许用户通过快捷方式访问其他文件或目录。\n一、什么是符号链接？ 符号链接是一种特殊的文件类型，它包含了指向另一个文件或目录的路径。你可以将其视为指向目标文件或目录的快捷方式或别名。在 Unix/Linux 系统中，符号链接的文件类型标记为 l，例如 lrwxrwxrwx。\n我们可以从以下四个方面来了解符号链接：\n独立性：符号链接本身是一个独立的文件，与它指向的目标文件或目录相分离。它仅仅包含目标的路径信息。\n路径：符号链接存储的是目标文件的路径，这个路径可以是相对的或绝对的。\n文件类型：符号链接的文件类型是 symlink，这是文件系统支持的一种特殊文件类型。\n创建：可以使用 ln -s 命令在 Unix/Linux 系统中创建符号链接。例如：\n1 ln -s /path/to/targetfile linkname 假设我们有一个名为 linkfile 的符号链接，它指向文件 targetfile。可以使用如下命令查看符号链接：\n1 2 $ ls -l linkfile lrwxrwxrwx 1 user group 12 Jul 29 15:00 linkfile -\u0026gt; /path/to/targetfile 在这个示例中，linkfile 是符号链接，指向 /path/to/targetfile。\n二、什么是符号链接所引用的文件？ 符号链接所引用的文件是符号链接指向的实际文件或目录。它是符号链接的目标，包含了真实的数据或内容。\n符号链接所引用的文件包含实际的数据或内容。这是磁盘上存储的真正文件。\n假设 linkfile 指向 /path/to/targetfile，那么 /path/to/targetfile 就是符号链接所引用的文件。这个文件可以是文本文件、二进制文件、目录等。\n三、符号链接与符号链接所引用的文件的区别 在定义方面：\n符号链接：一个特殊的文件，它包含了指向另一个文件或目录的路径。 符号链接所引用的文件：符号链接指向的实际文件或目录，包含真实的数据或内容。 在功能方面：\n符号链接：作为快捷方式，让用户通过符号链接访问实际文件或目录。 符号链接所引用的文件：实际存储数据或文件内容。 在实际操作方面：\n符号链接：对符号链接本身的操作（如删除、移动）不会影响目标文件的内容，除非它影响了路径。 符号链接所引用的文件：对目标文件的操作（如修改、删除）会影响文件内容。 ","permalink":"https://oheyu.github.io/zh/posts/tech/linux%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E6%89%80%E5%BC%95%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6/","summary":"在操作系统中，符号链接（Symbolic Link）是一种常用的文件系统功能，它允许用户通过快捷方式访问其他文件或目录。 一、什么是符号链接？ 符","title":"Linux中的符号链接与符号链接所引用的文件"},{"content":"\rfg 命令是 Unix 和类 Unix 操作系统中的一个重要命令，用于将后台运行的任务（进程）恢复到前台。它的全称是 \u0026ldquo;foreground\u0026rdquo;。下面将全面介绍 fg 命令，包括所有可能的使用场景和具体示例。\n一、fg 命令概述 fg 命令主要用于以下场景：将后台任务恢复到前台、恢复被挂起的任务以及管理多任务环境中的任务优先级。\n二、基本语法 1 fg [job_spec] 其中 job_spec 是任务的标识符，可以是任务编号、命令名等。job_spec 的常见格式包括：\n%n：任务编号，例如 %1。 %string：任务名，以 string 开头的任务。 %?string：任务名，包含 string 的任务。 三、使用场景及具体例子 3.1 将最近的后台任务恢复到前台 当你有一个或多个任务在后台运行时，可以使用 fg 命令将最近的一个任务恢复到前台。\n1 2 3 4 5 sleep 100 \u0026amp; # 任务 sleep 100 在后台运行 fg # 将最近的后台任务恢复到前台 3.2 将指定的后台任务恢复到前台 你可以通过任务编号或任务名来指定要恢复到前台的任务。\n1 2 3 4 5 6 7 8 9 10 sleep 100 \u0026amp; sleep 200 \u0026amp; # 两个任务在后台运行 jobs # [1]+ Running sleep 100 \u0026amp; # [2]- Running sleep 200 \u0026amp; fg %1 # 将任务编号为 1 的任务（sleep 100）恢复到前台 3.3 恢复包含特定字符串的任务 如果你有多个任务，并且不记得具体编号，可以通过任务名的一部分来恢复任务。\n1 2 3 4 5 6 vi file1 \u0026amp; vi file2 \u0026amp; # 两个 vi 编辑器任务在后台运行 fg %?file2 # 将包含 \u0026#39;file2\u0026#39; 的任务恢复到前台 3.4 恢复被挂起的任务 有时，你可能会挂起一个正在前台运行的任务，然后将其恢复。\n1 2 3 4 5 6 7 8 sleep 1000 # 按下 Ctrl+Z 挂起任务 jobs # [1]+ Stopped sleep 1000 fg %1 # 将挂起的任务恢复到前台 3.5 在多任务环境中管理任务 在复杂的多任务环境中，可以通过 fg 命令来管理不同任务的优先级。\n1 2 3 4 5 6 7 8 9 10 # 启动几个长时间运行的任务 sleep 1000 \u0026amp; sleep 2000 \u0026amp; sleep 3000 \u0026amp; jobs # 列出所有后台任务 fg %3 # 将任务编号为 3 的任务恢复到前台 四、补充说明 任务编号：\n可以使用 jobs 命令查看所有后台和挂起的任务及其编号。 任务编号在当前 shell 会话中是唯一的，但在不同的 shell 会话中可能会重复。 任务状态：\nRunning：任务正在后台运行。 Stopped：任务被挂起。 Done：任务已完成。 组合使用：\nfg 命令通常与 \u0026amp;（后台运行符）、jobs（查看后台任务）和 bg（将任务放到后台）等命令一起使用，以实现灵活的任务管理。 ","permalink":"https://oheyu.github.io/zh/posts/tech/fg%E5%91%BD%E4%BB%A4/","summary":"fg 命令是 Unix 和类 Unix 操作系统中的一个重要命令，用于将后台运行的任务（进程）恢复到前台。它的全称是 \u0026ldquo;foreground\u0026rdquo;","title":"Fg命令"},{"content":"\r在网络编程中，特别是在使用套接字编程时，地址解析和管理是一个关键问题。为了简化这个过程，POSIX 标准定义了 addrinfo 结构体和相关函数。\n一、addrinfo 结构体简介 addrinfo 结构体用于存储地址信息，getaddrinfo 函数通过解析主机名和服务名生成这个结构体的链表。以下是 addrinfo 结构体的定义：\n1 2 3 4 5 6 7 8 9 10 struct addrinfo { int ai_flags; // 输入标志 int ai_family; // 地址簇（如 AF_INET、AF_INET6） int ai_socktype; // 套接字类型（如 SOCK_STREAM、SOCK_DGRAM） int ai_protocol; // 协议（如 IPPROTO_TCP、IPPROTO_UDP） socklen_t ai_addrlen; // 套接字地址的长度 struct sockaddr *ai_addr; // 套接字地址 char *ai_canonname; // 规范名 struct addrinfo *ai_next; // 指向下一个 addrinfo 结构的指针 }; 二、成员变量详细解析 （1）ai_flags：指定 getaddrinfo 函数的行为，可以是以下标志的组合：\nAI_PASSIVE: 如果设置了该标志，表示返回的套接字地址用于绑定（绑定到 INADDR_ANY 或 in6addr_any）。\nAI_CANONNAME: 返回主机的规范名称，通过 ai_canonname 成员指向。\nAI_NUMERICHOST: 以数字字符串形式返回主机地址，而不是名称。\nAI_NUMERICSERV: 以数字字符串形式返回服务地址，而不是名称。\nAI_V4MAPPED: 如果没有找到 IPv6 地址，则返回 IPv4 映射的 IPv6 地址。\nAI_ALL: 返回 IPv4 和 IPv6 地址。\nAI_ADDRCONFIG: 仅在系统中配置的地址类型上返回地址。\n1 2 3 struct addrinfo hints; memset(\u0026amp;hints, 0, sizeof hints); hints.ai_flags = AI_PASSIVE | AI_CANONNAME; （2）ai_family：指定地址簇，可以是以下值：\nAF_INET: IPv4 协议 AF_INET6: IPv6 协议 AF_UNSPEC: 未指定（既可以是 IPv4 也可以是 IPv6） 1 hints.ai_family = AF_INET; // 仅返回 IPv4 地址 （3）ai_socktype：指定套接字类型，可以是以下值：\nSOCK_STREAM: 流套接字（如 TCP） SOCK_DGRAM: 数据报套接字（如 UDP） SOCK_RAW: 原始套接字 其他类型根据系统而定 1 hints.ai_socktype = SOCK_STREAM; // 返回流套接字地址 （4）ai_protocol：指定协议，可以是以下值：\nIPPROTO_TCP: TCP 协议 IPPROTO_UDP: UDP 协议 其他协议根据系统而定 1 hints.ai_protocol = IPPROTO_TCP; // 返回 TCP 协议地址 （5）ai_addrlen：指定套接字地址的长度。\n这个成员变量一般由 getaddrinfo 函数设置，无需手动设置。\n（6）ai_addr：指向套接字地址的指针。\n同样的，这个成员变量一般由 getaddrinfo 函数设置，无需手动设置。\n（7）ai_canonname：指向主机的规范名称的指针。\n仅在设置 AI_CANONNAME 标志时返回。\n（8）ai_next：指向下一个 addrinfo 结构的指针，形成一个链表。\n也是啦，这个一般由 getaddrinfo 函数设置，无需手动设置。\n三、示例程序 以下是一个示例程序，展示如何使用 getaddrinfo 解析域名，并通过 addrinfo 结构体访问地址信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void resolveDomain(const std::string\u0026amp; domain, const std::string\u0026amp; service) { struct addrinfo hints, *res, *p; char ipstr[INET6_ADDRSTRLEN]; int status; memset(\u0026amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; // 支持IPv4和IPv6 hints.ai_socktype = SOCK_STREAM; // TCP hints.ai_flags = AI_PASSIVE | AI_CANONNAME; // 设置标志 if ((status = getaddrinfo(domain.c_str(), service.c_str(), \u0026amp;hints, \u0026amp;res)) != 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;getaddrinfo: \u0026#34; \u0026lt;\u0026lt; gai_strerror(status) \u0026lt;\u0026lt; std::endl; return; } std::cout \u0026lt;\u0026lt; \u0026#34;IP addresses for \u0026#34; \u0026lt;\u0026lt; domain \u0026lt;\u0026lt; \u0026#34; on service \u0026#34; \u0026lt;\u0026lt; service \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; std::endl; for (p = res; p != nullptr; p = p-\u0026gt;ai_next) { void *addr; std::string ipver; // 获取地址 if (p-\u0026gt;ai_family == AF_INET) { // IPv4 struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-\u0026gt;ai_addr; addr = \u0026amp;(ipv4-\u0026gt;sin_addr); ipver = \u0026#34;IPv4\u0026#34;; } else { // IPv6 struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-\u0026gt;ai_addr; addr = \u0026amp;(ipv6-\u0026gt;sin6_addr); ipver = \u0026#34;IPv6\u0026#34;; } // 转换IP为字符串 inet_ntop(p-\u0026gt;ai_family, addr, ipstr, sizeof ipstr); std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ipver \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; ipstr \u0026lt;\u0026lt; std::endl; if (hints.ai_flags \u0026amp; AI_CANONNAME \u0026amp;\u0026amp; p-\u0026gt;ai_canonname) { std::cout \u0026lt;\u0026lt; \u0026#34; Canonical name: \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;ai_canonname \u0026lt;\u0026lt; std::endl; } } freeaddrinfo(res); } int main(int argc, char *argv[]) { if (argc != 3) { std::cerr \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;domain\u0026gt; \u0026lt;port\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } std::string domain = argv[1]; std::string service = argv[2]; resolveDomain(domain, service); return 0; } 3.1 运行示例 编译：\n1 g++ -o resolveDomain resolveDomain.cpp 运行：\n1 ./resolveDomain example.com 80 示例输出\n1 2 3 4 5 IP addresses for example.com on service 80: IPv4: 93.184.216.34 Canonical name: example.com IPv6: 2606:2800:220:1:248:1893:25c8:1946 Canonical name: example.com ","permalink":"https://oheyu.github.io/zh/posts/tech/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90addrinfo%E7%BB%93%E6%9E%84%E4%BD%93/","summary":"在网络编程中，特别是在使用套接字编程时，地址解析和管理是一个关键问题。为了简化这个过程，POSIX 标准定义了 addrinfo 结构体和相关函数。 一、addr","title":"深入剖析addrinfo结构体"},{"content":"\r一、什么是监听描述符（Listening Descriptor）？ 监听描述符主要用于等待和接受传入的客户端连接请求。它在服务器启动时被创建和配置，但它不参与实际的数据传输。\n1.1 监听描述符的基本功能 监听描述符的主要作用是等待并接受传入的客户端连接请求。它不会直接处理数据，而是管理和控制连接的建立过程。\n1.2 监听描述符的创建和配置 创建套接字：通过调用 socket() 函数创建新的套接字。 绑定地址和端口：使用 bind() 函数将套接字绑定到特定的地址和端口。 进入监听状态：调用 listen() 函数使套接字进入监听状态，准备接受客户端的连接请求。 1.3 监听描述符的状态和行为 监听描述符始终处于被动监听状态，等待客户端发起连接请求。当有客户端尝试连接时，监听描述符将连接请求排入等待队列，等待进一步处理。\n1.4 应用场景 监听描述符通常用于服务器应用程序的初始化阶段，定义服务器在哪些网络接口和端口上等待连接。这一过程确保了服务器能够接收到来自客户端的连接请求。\n二、什么是已连接描述符（Connected Descriptor）？ 已连接描述符用于实际的客户端-服务器通信。它是在服务器接受到客户端的连接请求后，通过调用 accept() 函数生成的新的套接字描述符。\n2.1 基本功能 已连接描述符负责处理与特定客户端的所有数据传输操作，包括读取客户端发送的数据和向客户端发送数据。\n2.2 创建和配置 当监听描述符检测到一个传入的连接请求时，通过调用 accept() 函数生成一个新的已连接描述符。这个新的描述符与特定的客户端关联。\n2.3 状态和行为 已连接描述符处于活跃状态，可以进行双向数据传输操作。每个已连接描述符都是独立的，与单个客户端连接关联，直到连接关闭。\n2.4 应用场景 已连接描述符在服务器接收到连接请求后立即生成，用于处理该请求后的所有数据传输。每个客户端连接都会对应一个独立的已连接描述符，使服务器能够同时处理多个客户端连接。\n三、监听描述符与已连接描述符的区别 角色和职责：\n监听描述符：负责监听和接受新的连接请求，不处理实际的数据传输。 已连接描述符：负责处理已建立连接的实际数据传输，与特定客户端进行通信。 生命周期：\n监听描述符：在服务器的整个运行期间通常是持久的，一直在监听新的连接请求。 已连接描述符：生命周期相对较短，从连接建立到连接结束，处理完客户端通信后即关闭。 数量和管理：\n监听描述符：一个服务器通常只有一个监听描述符，负责监听特定的端口。 已连接描述符：服务器会有多个已连接描述符，每个客户端连接对应一个，这些描述符由监听描述符生成并管理。 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%9B%91%E5%90%AC%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E5%B7%B2%E8%BF%9E%E6%8E%A5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%9C%A8%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"一、什么是监听描述符（Listening Descriptor）？ 监听描述符主要用于等待和接受传入的客户端连接请求。它在服务器启动时被创建和配","title":"监听描述符与已连接描述符在网络编程中的区别"},{"content":"\r在软件开发过程中，组织和管理项目文件是一项至关重要的任务。一个良好的目录结构可以提高开发效率、简化项目维护、促进团队协作。在 C++ 项目中，目录结构的设计尤为重要，因为 C++ 项目通常包含多个源文件、头文件、库文件等。一个清晰、高效的 C++ 工程项目目录结构究竟是个什么样子？\n一、目录结构概述 一个典型的 C++ 项目目录结构可能如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 project_root/ ├── src/ │ ├── main.cpp │ ├── myclass.cpp │ └── utilities.cpp ├── include/ │ ├── myclass.h │ └── utilities.h ├── lib/ │ └── some_library.a ├── bin/ │ └── my_project_executable ├── CMakeLists.txt └── README.md 上述的项目目录结构算是最常见、最基础的。下面，让我们来逐一解析这些目录和文件的用途。\n二、src/：源代码文件夹 src 文件夹用于存放项目的源代码文件（通常是 .cpp 或 .cxx 文件）。这些文件包含项目的实现代码。通过将源代码文件集中存放在 src 文件夹中，可以清晰地组织和管理项目的核心逻辑。假设，我们有以下三个 .cpp 文件：\n（1）示例文件：main.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026#34;myclass.h\u0026#34; #include \u0026#34;utilities.h\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { MyClass obj; obj.doSomething(); utilityFunction(); return 0; } （2）示例文件：myclass.cpp\n1 2 3 4 5 6 #include \u0026#34;myclass.h\u0026#34; #include \u0026lt;iostream\u0026gt; void MyClass::doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Doing something!\u0026#34; \u0026lt;\u0026lt; std::endl; } （3）示例文件：utilities.cpp\n1 2 3 4 5 6 #include \u0026#34;utilities.h\u0026#34; #include \u0026lt;iostream\u0026gt; void utilityFunction() { std::cout \u0026lt;\u0026lt; \u0026#34;Utility function!\u0026#34; \u0026lt;\u0026lt; std::endl; } 二、include/：头文件文件夹 include 文件夹用于存放项目的头文件（通常是 .h 或 .hpp 文件）。头文件包含类、函数的声明和接口定义。将头文件和源文件分开存放有助于模块化开发，便于代码重用和维护。\n对应于 src/ 文件夹中的 myclass.cpp 以及 utilities.cpp，我们有以下头文件：\n（1）示例文件：myclass.h\n1 2 3 4 5 6 7 8 9 #ifndef MYCLASS_H #define MYCLASS_H class MyClass { public: void doSomething(); }; #endif // MYCLASS_H （2）示例文件：utilities.h\n1 2 3 4 5 6 #ifndef UTILITIES_H #define UTILITIES_H void utilityFunction(); #endif // UTILITIES_H 三、lib/：库文件文件夹 lib 文件夹用于存放项目依赖的库文件（通常是 .a、.so 或 .dll 文件）。这些库文件在编译和链接阶段会被使用。通过将库文件集中存放，可以更方便地管理和更新项目依赖。\n四、bin/：可执行文件文件夹 bin 文件夹用于存放编译生成的可执行文件或二进制文件。通过将生成的二进制文件集中存放，可以更容易地运行和测试项目。\n五、CMakeLists.txt：构建配置文件 CMakeLists.txt 是 CMake 构建系统的配置文件，用于定义项目的构建流程。CMake 是一个跨平台的自动化构建工具，能够生成各种构建系统的配置文件（如 Makefile、Visual Studio 工程文件等）。\n示例文件：CMakeLists.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 cmake_minimum_required(VERSION 3.10) # 设置项目名称和版本 project(MyProject VERSION 1.0) # 设置 C++ 标准 set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) # 包含头文件目录 include_directories(include) # 添加源文件 set(SOURCES src/main.cpp src/myclass.cpp src/utilities.cpp ) # 添加可执行文件 add_executable(MyProject ${SOURCES}) 六、README.md：项目说明文件 README.md 是项目的说明文件，通常使用 Markdown 语法编写。它包含项目的描述、安装使用说明、开发环境要求等信息。一个详细的 README 文件有助于其他开发者快速了解和上手项目。\n示例文件：README.md\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # MyProject This is a simple C++ project demonstrating a typical project directory structure. ## Getting Started ### Prerequisites - C++11 or higher - CMake 3.10 or higher ### Building the Project 1. Clone the repository: git clone https://github.com/yourusername/myproject.git cd myproject 2. Create a build directory and navigate into it: mkdir build cd build 3. Generate the build files using CMake: cmake .. 4. Build the project: make 5. Run the executable: ./MyProject 结论 一个良好的 C++ 项目目录结构可以显著提高开发效率、简化项目维护和促进团队协作。通过将源代码文件、头文件、库文件和可执行文件分开存放，并使用构建系统工具如 CMake，可以更好地组织和管理项目。希望本文介绍的典型 C++ 项目目录结构和示例代码能够帮助你更好地构建和维护 C++ 项目。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3%E5%92%8C%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84c++%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","summary":"在软件开发过程中，组织和管理项目文件是一项至关重要的任务。一个良好的目录结构可以提高开发效率、简化项目维护、促进团队协作。在 C++ 项目中，目录结","title":"理解和构建一个高效的C++工程项目目录结构"},{"content":"\rLinux 手册页（man pages）是每个 Linux 用户和开发者的重要资源。它们提供了关于各种命令、系统调用、库函数、文件格式等的详细信息。手册页分为多个章节，每个章节涵盖特定类型的内容。\n一. 用户命令（User Commands） 章节编号：1\n内容：普通用户可以运行的命令和程序。\n适用场景：查找和学习日常使用的命令，如 ls、cp、grep 等。\n示例：\n1 man 1 ls 二. 系统调用（System Calls） 章节编号：2\n内容：操作系统内核提供的系统调用。\n适用场景：编写与操作系统内核直接交互的低级程序，例如涉及文件操作、进程控制等。\n示例：\n1 man 2 open 三. 库函数（Library Functions） 章节编号：3\n内容：C 标准库（libc）函数及其他库函数。\n适用场景：使用 C 语言编程时，查找标准库函数的用法和参数，例如字符串处理、数学函数等。\n示例：\n1 man 3 printf 四. 特殊文件（Special Files） 章节编号：4\n内容：设备文件和驱动程序。\n适用场景：与硬件设备交互或开发驱动程序时，查找设备文件的详细信息。\n示例：\n1 man 4 tty 五. 文件格式（File Formats and Conventions） 章节编号：5\n内容：各种文件格式、配置文件和协议描述。\n适用场景：编写或解析特定格式的文件时，了解文件格式的细节。\n示例：\n1 man 5 passwd 六. 游戏和杂项（Games and Screensavers） 章节编号：6\n内容：游戏和屏幕保护程序。\n适用场景：查找和了解系统上安装的游戏或屏幕保护程序。\n示例：\n1 man 6 snake 七. 杂项（Miscellaneous） 章节编号：7\n内容：与系统相关的杂项信息，包括宏包、惯例和协议。\n适用场景：查找与网络协议、文件系统、进程间通信等相关的高级主题。\n示例：\n1 man 7 socket 八. 系统管理命令（System Administration Commands） 章节编号：8\n内容：系统管理员使用的命令。\n适用场景：进行系统维护、配置和管理时，查找管理员级别的命令。\n示例：\n1 man 8 mount 九. 内核例程（Kernel Routines） 章节编号：9\n内容：内核开发和模块编程相关的函数和宏。\n适用场景：进行 Linux 内核开发或编写内核模块时，查找内核函数和数据结构的详细信息。\n示例：\n1 man 9 printk 总结 用户命令：日常使用的命令和工具。 系统调用：与操作系统内核交互的函数。 库函数：标准库和其他库提供的函数。 特殊文件：设备文件和驱动程序信息。 文件格式：配置文件和文件格式描述。 游戏和杂项：系统上的游戏和屏幕保护程序。 杂项：高级主题和系统相关信息。 系统管理命令：管理员使用的命令。 内核例程：内核开发相关的信息。 ","permalink":"https://oheyu.github.io/zh/posts/tech/linux%E6%89%8B%E5%86%8C%E9%A1%B5%E6%8C%87%E5%8D%97%E4%BA%86%E8%A7%A3%E5%90%84%E7%AB%A0%E8%8A%82%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","summary":"Linux 手册页（man pages）是每个 Linux 用户和开发者的重要资源。它们提供了关于各种命令、系统调用、库函数、文件格式等的详细信息。手册页分为多个章","title":"Linux手册页指南：了解各章节及其使用场景"},{"content":"\r在使用 PyTorch 进行模型训练时，为什么需要设置训练模式？如何计算每个 epoch 的平均损失？今天，我们来唠一唠。\n一、模型的训练模式 在训练神经网络模型时，特别是在使用 PyTorch 框架时，我们通常会看到类似如下的代码：\n1 model.train() 这行代码将模型设置为训练模式。这对于一些特定的层，如 Dropout 和 Batch Normalization，尤为重要。让我们深入了解一下原因。\n1.1 Dropout 层 Dropout 是一种正则化技术，旨在防止过拟合。在训练过程中，Dropout 会随机地将一部分神经元的输出设为零，从而防止模型对训练数据过拟合。然而，在测试和评估模型时，我们希望使用所有的神经元。因此，Dropout 层在训练和测试时的行为有所不同：\n训练模式：随机屏蔽部分神经元。 评估模式：使用所有神经元，不进行屏蔽。 1.2 Batch Normalization 层 Batch Normalization 通过在每个小批次上标准化输入来加速训练和提高稳定性。在训练和测试时，它的行为也不同：\n训练模式：使用当前批次的数据计算均值和方差进行标准化。 评估模式：使用在训练过程中积累的全局均值和方差进行标准化。 因此，将模型设置为训练模式（model.train()）确保了这些层在训练时表现正确。如果忘记了这一步，可能会导致训练效果不佳或者评估结果不准确。\n二、计算每个 epoch 的平均损失 在训练过程中，我们需要跟踪模型的性能，其中一个常用的指标是损失（loss）。损失函数用于衡量模型预测值与实际值之间的误差。在每个 epoch 结束时，计算其平均损失是一个常见做法。以下是计算每个 epoch 平均损失的代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def train(model, device, trainloader, criterion, optimizer, num_epochs): model.train() train_losses = [] for epoch in range(num_epochs): running_loss = 0.0 for inputs, labels in tqdm(trainloader, desc=f\u0026#34;Epoch [{epoch+1}/{num_epochs}]\u0026#34;): inputs, labels = inputs.to(device), labels.to(device) optimizer.zero_grad() outputs = model(inputs) loss = criterion(outputs, labels) loss.backward() optimizer.step() running_loss += loss.item() epoch_loss = running_loss / len(trainloader) train_losses.append(epoch_loss) print(f\u0026#34;Epoch [{epoch+1}/{num_epochs}], Loss: {epoch_loss:.4f}\u0026#34;) return train_losses 2.1 详细解释： Epoch：一个 epoch 表示模型完整地遍历一次训练数据集。在一个 epoch 内，模型会处理多个批次（batch）的数据。\nBatch：为了处理大型数据集，训练数据通常被分割成多个小批次。每个批次中的数据量称为 batch size。\n在每个 epoch 的训练过程中，我们会累加每个批次的损失到 running_loss 中。running_loss 记录了当前 epoch 中所有批次的总损失。\nlen(trainloader) 表示训练数据加载器中批次的数量。为了计算当前 epoch 的平均损失，我们将 running_loss 除以批次的数量 len(trainloader)。这种方法提供了一个衡量标准，表示在整个训练周期内，模型在所有训练数据上的平均损失。\n2.2 代码解析： 1 epoch_loss = running_loss / len(trainloader) 这行代码计算当前 epoch 的平均损失。running_loss 是所有批次的总损失，将其除以批次数量，得到每个批次的平均损失。这有助于监控训练过程中损失的变化，判断模型是否在逐渐收敛。\n总结 在训练模式下，Dropout 和 Batch Normalization 层的行为与评估模式不同，确保这些层在训练过程中表现正确至关重要。\n","permalink":"https://oheyu.github.io/zh/posts/tech/pytorch%E4%B8%AD%E7%9A%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8D%9F%E5%A4%B1%E8%AE%A1%E7%AE%97/","summary":"在使用 PyTorch 进行模型训练时，为什么需要设置训练模式？如何计算每个 epoch 的平均损失？今天，我们来唠一唠。 一、模型的训练模式 在训练神经网络模型时，特别是","title":"PyTorch中的训练模式和损失计算"},{"content":"\r在 C++ 中，逗号运算符 , 是一个有趣且常见的运算符，它允许在一个语句中计算多个表达式。虽然它的使用相对简单，但在某些情况下可能会引起混淆。\n逗号运算符的基本原理 逗号运算符 , 会依次计算其左侧和右侧的表达式，整个表达式的结果是右侧表达式的值。其基本用法如下：\n1 expression1, expression2 步骤 1：计算 expression1 并丢弃其结果。 步骤 2：计算 expression2 并返回其结果。 考虑以下例子：\n1 int x = (1, 024); 其中，\n逗号运算符 (1, 024) 会首先计算 1，然后计算 024。 024 是一个八进制数（因为前导零），其值为 2*8 + 4 = 20（十进制）。 最终，int x = (1, 024); 等效于 int x = 20;。 此外，我们也可以使用逗号运算符进行赋值：\n1 2 int y; y = 1,024; 其中：\n赋值运算符 = 的优先级高于逗号运算符，因此 y = 1,024; 实际上等效于 (y = 1), 024;。 首先计算 (y = 1)，将 1 赋值给 y。 然后计算 024，其值为八进制的 20，但其结果被丢弃。 最终，y 的值是 1。\n总结 逗号运算符 , 在 C++ 中允许在一个语句中计算多个表达式，并返回右侧表达式的结果。其主要用途包括：\n在循环中进行多变量操作。 在赋值或初始化语句中对多个表达式进行计算。 在赋值语句中使用逗号运算符时，需要注意赋值运算符的优先级以及表达式的计算顺序，以避免意外结果。例如：\n1 2 int y; y = (1, 024); // y 将被初始化为 20（八进制） 1 2 int y; y = 1,024; // y 将被赋值为 1 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3cpp%E4%B8%AD%E7%9A%84%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E5%9C%A8%E8%B5%8B%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","summary":"在 C++ 中，逗号运算符 , 是一个有趣且常见的运算符，它允许在一个语句中计算多个表达式。虽然它的使用相对简单，但在某些情况下可能会引起混淆。 逗号运算","title":"理解CPP中的逗号运算符及其在赋值中的应用"},{"content":"\r在C语言编程中，NULL字符（通常表示为 \\0）是一个关键的概念，尤其在处理字符串时。它标志着字符串的结束，并在许多函数和算法中起着至关重要的作用。本篇博客将详细解释NULL字符的作用、典型使用场景以及需要注意的事项。\n一、什么是 NULL 字符？ NULL字符是一个值为零的字符，表示字符串的终止。在C语言中，字符串实际上是一个字符数组，而NULL字符的存在是为了标志这个字符数组的结尾。\n1 char str[] = \u0026#34;Hello, world!\u0026#34;; 上面这个字符串数组str在内存中实际存储如下：\n1 H e l l o , w o r l d ! \\0 这里的\\0就是NULL字符，它表示字符串的结束。\n二、NULL 字符的作用 2.1 标志字符串的结束 NULL字符用于标识字符串的结尾，使得C语言中的字符串处理函数（如strlen、strcpy、printf等）能够正确地处理字符串。\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026#34;Hello\u0026#34;; printf(\u0026#34;Length of string: %zu\\n\u0026#34;, strlen(str)); // 输出 5 return 0; } 2.2 避免缓冲区溢出 在处理输入输出时，通过限定字符串长度并添加NULL字符，可以有效防止缓冲区溢出等安全问题。\n1 2 3 char buffer[10]; strncpy(buffer, \u0026#34;This is a long string\u0026#34;, sizeof(buffer) - 1); buffer[sizeof(buffer) - 1] = \u0026#39;\\0\u0026#39;; // 确保以 NULL 结尾 2.3 方便字符串操作 大多数C标准库函数都依赖NULL字符来确定字符串的长度和边界，使用NULL字符能够简化字符串操作。\n三、使用场景 3.1 字符串初始化 在定义和初始化字符串时，编译器会自动在末尾添加NULL字符。\n1 char str[] = \u0026#34;Hello\u0026#34;; // 实际大小是 6, 包括末尾的 NULL 字符 3.2 字符串操作函数 函数如strcpy、strcat等都会处理NULL字符，确保字符串正确终止。\n1 2 3 4 char dest[20]; strcpy(dest, \u0026#34;Hello\u0026#34;); strcat(dest, \u0026#34;, world!\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, dest); // 输出 Hello, world! 3.3 读取和写入字符串 在读取用户输入或从文件中读取字符串时，需要确保输入数据以NULL字符结尾。\n1 2 3 char buffer[100]; fgets(buffer, sizeof(buffer), stdin); buffer[strcspn(buffer, \u0026#34;\\n\u0026#34;)] = \u0026#39;\\0\u0026#39;; // 用 NULL 字符替换换行符 四、注意事项 4.1 确保NULL字符存在 在字符串操作时，务必确保字符串以NULL字符结尾，否则可能导致未定义行为或内存访问错误。\n4.2 防止越界写入 在写入字符串数据时，要注意缓冲区大小，防止越界写入，确保不会覆盖NULL字符。\n4.3 正确处理多字节字符 在处理多字节字符（如UTF-8编码）时，要特别注意字符边界和NULL字符的位置。\n总结 NULL字符在C语言中起着重要作用，它标志着字符串的结束，使得字符串处理变得可靠和简便。通过理解NULL字符的作用和使用场景，并注意相关的安全问题，可以更好地编写健壮的C代码。希望这篇博客能帮助你更好地理解和使用NULL字符。\n代码示例 以下是一个结合所有上述概念的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAX_LEN 100 int main() { char buffer[MAX_LEN]; printf(\u0026#34;Enter a string: \u0026#34;); if (fgets(buffer, MAX_LEN, stdin) != NULL) { buffer[strcspn(buffer, \u0026#34;\\n\u0026#34;)] = \u0026#39;\\0\u0026#39;; // 确保以 NULL 结尾 printf(\u0026#34;You entered: %s\\n\u0026#34;, buffer); printf(\u0026#34;Length of string: %zu\\n\u0026#34;, strlen(buffer)); } else { printf(\u0026#34;Error reading input.\\n\u0026#34;); } return 0; } 这个示例从用户读取一个字符串，确保其以NULL字符结尾，并输出字符串及其长度。通过这种方式，可以安全地处理用户输入，避免常见的字符串操作错误。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84null%E5%AD%97%E7%AC%A6/","summary":"在C语言编程中，NULL字符（通常表示为 \\0）是一个关键的概念，尤其在处理字符串时。它标志着字符串的结束，并在许多函数和算法中起着至关重要的","title":"理解C语言中的NULL字符"},{"content":"\r在系统编程中，尤其是文件 I/O 操作中，我们经常需要处理大量数据的读取和写入。为了提高效率，常常使用缓冲机制。本文将详细探讨缓冲性质函数和非缓冲性质函数的区别，以及为何不能在同一文件描述符上交替使用这两种类型的函数。\n一、什么是缓冲性质函数？ 缓冲性质函数是指那些在内部维护一个缓冲区，用于存储从文件描述符读取的数据的函数。这些函数一次读取多个字节的数据到缓冲区中，然后根据用户的请求从缓冲区中返回所需的数据。这种机制可以减少系统调用的次数，从而提高 I/O 操作的效率。\n例如，假设我们有一个 rio_readnb 函数，其功能是从文件描述符 rp 读取最多 n 字节的数据到内存位置 usrbuf。该函数可能会如下实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ssize_t rio_readnb(int fd, void *usrbuf, size_t n) { // 内部维护一个缓冲区 static char buffer[BUFFER_SIZE]; static size_t buffer_count = 0; static char *buffer_ptr = buffer; size_t nleft = n; ssize_t nread; char *bufp = usrbuf; while (nleft \u0026gt; 0) { if (buffer_count == 0) { // 缓冲区为空，从文件描述符读取数据填充缓冲区 if ((nread = read(fd, buffer, sizeof(buffer))) \u0026lt; 0) { if (errno == EINTR) { continue; // 处理信号中断，重试读取 } else { return -1; // 读取错误 } } else if (nread == 0) { break; // 文件结束 } buffer_ptr = buffer; buffer_count = nread; } // 从缓冲区读取数据到用户缓冲区 size_t cnt = (nleft \u0026lt; buffer_count) ? nleft : buffer_count; memcpy(bufp, buffer_ptr, cnt); bufp += cnt; buffer_ptr += cnt; buffer_count -= cnt; nleft -= cnt; } return (n - nleft); // 返回读取的字节数 } 二、什么是非缓冲性质函数？ 非缓冲性质函数则不维护任何内部缓冲区，而是每次调用时直接从文件描述符读取数据并返回给用户。这些函数每次调用都触发系统调用，从而直接从文件描述符读取数据。\n例如，假设我们有一个 rio_readn 函数，其功能是直接从文件描述符读取 n 字节的数据到内存位置 usrbuf，可能会如下实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ssize_t rio_readn(int fd, void *usrbuf, size_t n) { size_t nleft = n; ssize_t nread; char *bufp = usrbuf; while (nleft \u0026gt; 0) { if ((nread = read(fd, bufp, nleft)) \u0026lt; 0) { if (errno == EINTR) { nread = 0; // 处理信号中断，重新读取 } else { return -1; // 读取错误 } } else if (nread == 0) { break; // 文件结束 } nleft -= nread; bufp += nread; } return (n - nleft); // 返回读取的字节数 } 三、缓冲性质函数与非缓冲性质函数为何不能交替使用？ 缓冲性质函数和非缓冲性质函数在同一文件描述符上交替使用会导致数据读取的不一致和错误。这是因为这两种类型的函数在处理文件描述符时的内部机制不同。\n3.1 数据不一致的问题 缓冲性质函数在读取数据时，会一次性从文件描述符读取多个字节的数据到内部缓冲区，然后再从缓冲区返回数据给用户。这意味着文件描述符的读指针会因为读取操作而移动到缓冲区数据的末尾位置。\n如果接着调用非缓冲性质函数，由于它不维护缓冲区，会直接从文件描述符的当前位置读取数据。这会导致以下问题：\n跳过数据：缓冲性质函数已经读取但尚未处理的数据会被非缓冲性质函数跳过，导致数据丢失。 重复读取：非缓冲性质函数移动了文件描述符的读指针，缓冲性质函数的缓冲区数据可能重复被读取。 3.2 示例说明 假设文件内容如下（每个字母代表一个字节）：\n1 abcdef 缓冲性质函数 rio_readnb 读取 4 个字节：\n内部缓冲区读取 abcd，并返回 abcd。 缓冲区现在可能还包含剩余的 ef。 接着调用非缓冲性质函数 rio_readn 读取 2 个字节：\n直接从文件描述符当前位置（即 ef）读取。 返回 ef。 再次调用 rio_readnb 读取 2 个字节：\n缓冲区已失效或被跳过，因为 rio_readn 直接从文件描述符读取，缓冲区未更新。 可能导致数据不一致或错误读取。 3.3 正确的使用方法 为了避免上述问题，应该遵循以下原则：\n保持一致性：在处理同一文件描述符时，要么始终使用缓冲性质函数，要么始终使用非缓冲性质函数。 避免交替使用：不要在同一文件描述符上交替使用这两种类型的函数，以确保数据读取的准确性和一致性。 结论 缓冲性质函数和非缓冲性质函数在处理文件描述符时的内部机制不同，交替使用可能导致数据不一致和错误。因此，在编写系统 I/O 操作时，应注意选择一致的函数类型，以确保数据读取的正确性和程序的稳定性。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%BC%93%E5%86%B2%E6%80%A7%E8%B4%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%9E%E7%BC%93%E5%86%B2%E6%80%A7%E8%B4%A8%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E4%BA%A4%E6%9B%BF%E4%BD%BF%E7%94%A8/","summary":"在系统编程中，尤其是文件 I/O 操作中，我们经常需要处理大量数据的读取和写入。为了提高效率，常常使用缓冲机制。本文将详细探讨缓冲性质函数和非缓冲性","title":"缓冲性质函数与非缓冲性质函数：为何不能交替使用"},{"content":"\rUbuntu 系统快照是一种用于捕捉和保存系统当前状态的技术。这种技术允许用户在将来某个时间点恢复到快照创建时的系统状态。这对于备份、系统更新前的保护、故障恢复以及测试环境的创建非常有用。\n一、系统快照定义 系统快照是操作系统在某个特定时间点上的完整状态，包括所有文件、配置和当前运行状态的副本。通过快照技术，可以快速地恢复系统到之前的某个状态。\n二、原理 系统快照的原理是基于写时复制（Copy-On-Write, COW）技术。当创建一个快照时，系统不会立即复制整个文件系统的数据，而是记录当前所有数据的元数据。只有在数据发生变化时，系统才会将变更部分的数据写入一个新的位置，并更新元数据指向新位置。这种方法节省了大量的存储空间和时间。\n三、实现方式 在 Ubuntu 中，实现系统快照的常见方法有以下几种：\n3.1 使用 LVM（Logical Volume Manager） LVM 提供了逻辑卷管理功能，允许创建卷组、逻辑卷和快照。\n（1）创建快照\n1 lvcreate --size 1G --snapshot --name snap /dev/vg0/lv0 --size：指定快照卷的大小。 --snapshot：指示创建快照。 --name：指定快照卷的名称。 /dev/vg0/lv0：原始逻辑卷的路径。 （2）恢复快照：\n1 lvconvert --merge /dev/vg0/snap --merge：将快照恢复到原始逻辑卷。 3.2 使用 Btrfs 文件系统 Btrfs 是一种现代的 CoW 文件系统，内置了快照功能。\n（1）创建快照：\n1 btrfs subvolume snapshot /path/to/source /path/to/snapshot /path/to/source：源子卷的路径。 /path/to/snapshot：快照的存储路径。 （2）恢复快照：\n1 2 btrfs subvolume delete /path/to/source btrfs subvolume snapshot /path/to/snapshot /path/to/source delete：删除源子卷。 snapshot：从快照创建新的子卷。 3.3 使用 Timeshift Timeshift 是一个专门用于桌面系统的快照工具，提供了图形用户界面（GUI）和命令行界面（CLI）。\n（1）安装 Timeshift：\n1 sudo apt install timeshift （2）创建快照：\n1 sudo timeshift --create --comments \u0026#34;My first snapshot\u0026#34; （3）恢复快照：\n1 sudo timeshift --restore --snapshot \u0026#34;My first snapshot\u0026#34; 四、应用场景 系统备份与恢复：\n在进行系统更新、安装新软件或进行重大配置更改之前创建快照，以便在出现问题时能够快速恢复系统。 测试环境：\n开发人员可以创建系统快照，以便在测试新功能或应用时，能够快速恢复到初始状态，节省重新配置环境的时间。 灾难恢复：\n快照技术可以用于灾难恢复，在系统遭受故障或数据损坏时，能够快速恢复到稳定状态。 虚拟化环境：\n在虚拟化环境中，快照可以用于保存虚拟机的状态，便于在虚拟机出问题时进行快速恢复。 五、优点与局限性 5.1 优点： 快速恢复：可以在几分钟内将系统恢复到之前的状态。 节省空间：通过 CoW 技术，仅保存变更的数据，节省存储空间。 自动化：可以设置定期快照，自动化备份过程。 5.2 局限性： 快照大小限制：快照卷的大小可能受到原始卷的限制，特别是在 LVM 中。 性能影响：频繁创建和恢复快照可能会对系统性能产生影响。 数据一致性：在系统繁忙时创建快照，可能会导致数据不一致，需要确保快照时的数据一致性。 总结 Ubuntu 系统快照是维护系统稳定性和数据安全性的重要工具，通过捕捉系统的当前状态，用户可以在需要时快速恢复到之前的状态。\n","permalink":"https://oheyu.github.io/zh/posts/tech/ubuntu%E7%B3%BB%E7%BB%9F%E5%BF%AB%E7%85%A7%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E7%8E%A9%E6%84%8F%E5%84%BF/","summary":"Ubuntu 系统快照是一种用于捕捉和保存系统当前状态的技术。这种技术允许用户在将来某个时间点恢复到快照创建时的系统状态。这对于备份、系统更新前的保护、","title":"Ubuntu系统快照是个什么玩意儿"},{"content":"\r在 Vim 中，我们可以使用重复上一次输入内容的命令来提高编辑效率。以下是几种常用的方法：\n一. 使用 . 命令 . 命令是 Vim 中最常用的重复命令。它可以重复上一次的普通模式命令。例如，如果在普通模式下删除了一个单词（dw），我们可以按 . 来重复这个操作。\n二. 使用 @: 命令 @: 命令可以重复上一次的命令行模式命令。例如，如果在命令行模式下输入了 :s/foo/bar/ 进行替换，我们可以按 @: 来重复这个替换操作。\n三. 使用 q 和 @ 命令记录和播放宏 我们也可以使用 q 命令开始录制宏，然后使用 @ 命令来播放宏，重复执行录制的命令序列，以下是详细步骤：\n录制宏：\n按 q 开始录制宏，后跟一个寄存器名（例如 a），即 qa。 执行你想录制的命令序列。 按 q 结束录制。 播放宏：\n按 @a 播放存储在寄存器 a 中的宏。 以重复删除某个单词为例：\n1 2 3 4 qa \u0026#34; 开始录制宏，寄存器名为 a dw \u0026#34; 删除一个单词 q \u0026#34; 结束录制 @a \u0026#34; 播放寄存器 a 中的宏 四. 使用 @@ 命令 @@ 命令可以重复上一次的宏。例如，如果我们刚刚使用了 @a 播放了宏，你可以按 @@ 来再次播放该宏。\n总结 在 Vim 中，有多种方法可以重复上一次的输入内容：\n使用 . 来重复上一次的普通模式命令。 使用 @: 来重复上一次的命令行模式命令。 使用宏（q 和 @）来录制和重复复杂的命令序列。 使用 @@ 来重复上一次播放的宏。 ","permalink":"https://oheyu.github.io/zh/posts/tech/vim%E9%87%8D%E5%A4%8D%E4%B8%8A%E4%B8%80%E6%AC%A1%E5%91%BD%E4%BB%A4/","summary":"在 Vim 中，我们可以使用重复上一次输入内容的命令来提高编辑效率。以下是几种常用的方法： 一. 使用 . 命令 . 命令是 Vim 中最常用的重复命令。它可以重复上一","title":"Vim重复上一次命令"},{"content":"\r梯度下降是一种核心优化算法，广泛应用于机器学习、深度学习和强化学习中。本文将详细介绍这三者的关系，以及梯度下降在这些领域中的具体应用和实现方式。\n一、机器学习、深度学习和强化学习的关系 1.1 机器学习（Machine Learning, ML） 机器学习是人工智能的一个分支，致力于开发算法和技术，使计算机能够从数据中学习和做出预测或决策，而无需明确的编程指令。其主要类别有：\n监督学习（Supervised Learning）：算法从标记数据中学习，进行分类和回归任务。 无监督学习（Unsupervised Learning）：算法从未标记数据中学习，进行聚类和降维任务。 半监督学习（Semi-supervised Learning）：结合少量标记数据和大量未标记数据进行学习。 强化学习（Reinforcement Learning）：算法通过与环境的互动，从奖励和惩罚中学习最佳策略。 1.2 深度学习（Deep Learning, DL） 深度学习是机器学习的一个子领域，使用多层神经网络（即深度神经网络）来学习复杂数据的表示和模式。其主要特点为：\n层次结构：通过多个隐藏层来提取数据的特征。 自动特征提取：无需人工设计特征，网络能够自动学习数据的表示。 大规模数据处理：适用于处理大量数据，如图像、语音和自然语言处理。 目前而言，最常见架构有两种：\n卷积神经网络（Convolutional Neural Networks, CNNs）：主要用于图像处理。 循环神经网络（Recurrent Neural Networks, RNNs）：主要用于处理序列数据。 1.3 强化学习（Reinforcement Learning, RL） 强化学习是机器学习的一个方法，通过智能体与环境的交互，从反馈信号（奖励或惩罚）中学习最佳行为策略，以最大化累积奖励。其主要特点：\n探索与利用：智能体需要在探索新策略和利用已知最佳策略之间进行平衡。 延迟奖励：动作的效果可能不是立即显现，而是经过一段时间后才表现出来。 策略学习：学习的是一个策略（policy），即在不同状态下采取不同动作的规则。 二、梯度下降在机器学习中的应用 在传统的机器学习中，梯度下降主要用于优化线性回归、逻辑回归和支持向量机等模型的参数。\n2.1 线性回归 线性回归旨在找到一条最佳拟合线来预测目标变量。目标是最小化损失函数（如均方误差）。梯度下降用于更新模型的权重，以逐渐逼近最优解。一般的，线性回归的损失函数可定义为如下形式：\n$$ J(\\theta) = \\frac{1}{2m} \\sum_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)})^2， $$\n梯度更新公式则为：\n$$ \\theta := \\theta - \\eta \\frac{1}{m} \\sum_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)}。 $$\n2.2 逻辑回归 逻辑回归用于分类任务，目标是最大化对数似然函数。梯度下降用于优化模型参数，使得模型能够更准确地进行分类。一般的，逻辑回归的损失函数（以交叉熵损失函数为例）可定义为如下形式：\n$$ J(\\theta) = -\\frac{1}{m} \\sum_{i=1}^{m} [y^{(i)} \\log(h_\\theta(x^{(i)})) + (1 - y^{(i)}) \\log(1 - h_\\theta(x^{(i)}))]， $$\n梯度更新公式则为：\n$$ \\theta := \\theta - \\eta \\frac{1}{m} \\sum_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)}。 $$\n三、梯度下降在深度学习中的应用 在深度学习中，梯度下降通过反向传播算法（backpropagation）来更新神经网络的权重和偏置。深度学习中的梯度下降有多种变体，如随机梯度下降（SGD）、动量梯度下降（Momentum）、自适应学习率方法（如Adam、RMSprop等）。\n3.1 反向传播（Backpropagation） 反向传播是一种计算梯度的高效算法，通过链式法则逐层计算损失函数对每个参数的梯度。其一般步骤为：\n前向传播：计算网络的输出，并根据目标计算损失。 反向传播：从输出层开始，逐层计算损失函数对各层参数的梯度。 参数更新：使用梯度下降算法更新每层的权重和偏置。梯度更新公式为 $\\theta := \\theta - \\eta \\nabla_\\theta J(\\theta)$。 3.2 优化算法 SGD（随机梯度下降）：每次更新只使用一个训练样本的梯度。 Momentum（动量）：在更新中加入前几次梯度的动量项，加速收敛并减小震荡。 $v_t = \\beta v_{t-1} + (1 - \\beta) \\nabla_\\theta J(\\theta)$ $\\theta := \\theta - \\eta v_t$ Adam：结合动量和自适应学习率的优化算法。 $m_t = \\beta_1 m_{t-1} + (1 - \\beta_1) \\nabla_\\theta J(\\theta)$ $v_t = \\beta_2 v_{t-1} + (1 - \\beta_2) (\\nabla_\\theta J(\\theta))^2$ $\\hat{m}_t = \\frac{m_t}{1 - \\beta_1^t}$ $\\hat{v}_t = \\frac{v_t}{1 - \\beta_2^t}$ $\\theta := \\theta - \\eta \\frac{\\hat{m}_t}{\\sqrt{\\hat{v}_t} + \\epsilon}$ 四、梯度下降在强化学习中的应用 在强化学习中，梯度下降主要用于策略优化和价值函数逼近。具体应用包括策略梯度方法和深度强化学习。\n4.1 策略梯度方法（Policy Gradient Methods） 策略梯度方法直接优化策略，通过最大化预期累积奖励来更新策略参数。这里有个策略梯度定理（放在这里，供了解）：\n$$ \\nabla_\\theta J(\\theta) = \\mathbb{E}{\\tau \\sim \\pi\\theta} \\left[ \\sum_{t=0}^{T} \\nabla_\\theta \\log \\pi_\\theta(a_t|s_t) R(\\tau) \\right] $$\n以及 REINFORCE 算法：\n$$ \\theta := \\theta + \\eta \\sum_{t=0}^{T} \\nabla_\\theta \\log \\pi_\\theta(a_t|s_t) R_t $$\n4.2 价值函数逼近（Value Function Approximation） 使用函数逼近方法（如神经网络）来估计价值函数或动作价值函数，通过梯度下降优化这些函数逼近的参数。主要代表是深度 Q 网络（DQN）：\n$$ L(\\theta) = \\mathbb{E}{(s, a, r, s\u0026rsquo;)} \\left[ \\left( r + \\gamma \\max{a\u0026rsquo;} Q(s\u0026rsquo;, a\u0026rsquo;; \\theta^-) - Q(s, a; \\theta) \\right)^2 \\right] $$\n这里，梯度下降用于最小化这个损失函数，从而更新 Q 网络的参数：\n$$ \\theta := \\theta - \\eta \\nabla_\\theta L(\\theta) $$\n4.3 Actor-Critic 方法 Actor-Critic 方法结合了策略梯度和价值函数逼近，将策略（Actor）和价值函数（Critic）分开学习。Actor 使用策略梯度方法更新策略参数：\n$$ \\theta_{\\pi} := \\theta_{\\pi} + \\eta \\nabla_\\theta \\log \\pi_\\theta(a|s) \\delta $$\n而 Critic 则使用 TD 方法或其他价值函数逼近方法更新价值函数参数：\n$$ \\theta_{V} := \\theta_{V} + \\beta \\delta \\nabla_\\theta V(s) $$\n总结 机器学习：梯度下降用于优化传统机器学习模型的参数，如线性回归和逻辑回归。 深度学习：梯度下降通过反向传播优化深层神经网络的权重和偏置，常用的变体包括 SGD、Momentum 和Adam 等。 强化学习：梯度下降用于策略优化和价值函数逼近，通过策略梯度、深度 Q 网络和 Actor-Critic 方法等实现。 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","summary":"梯度下降是一种核心优化算法，广泛应用于机器学习、深度学习和强化学习中。本文将详细介绍这三者的关系，以及梯度下降在这些领域中的具体应用和实现方","title":"理解梯度下降在机器学习、深度学习和强化学习中的应用"},{"content":"\r在机器学习和深度学习中，梯度下降是一种广泛使用的优化算法，用于最小化模型的损失函数，从而优化模型参数。梯度下降的三种主要变体是批量梯度下降、随机梯度下降和小批量梯度下降。本文将详细介绍这三种方法的定义、优缺点，以及它们在损失函数（准确度）曲线上的整体表现。\n一、批量梯度下降（Batch Gradient Descent） 1.1 定义 批量梯度下降（Batch Gradient Descent）在每次迭代时，使用整个训练集计算损失函数的梯度，并基于这个梯度来更新模型参数。损失函数 $J(\\theta)$ 通常是所有样本损失的平均值。例如，如果训练集中有 $N$ 个样本，则损失函数可以表示为：\n$$ J(\\theta) = \\frac{1}{N} \\sum_{i=1}^{N} L(f(x^{(i)}; \\theta), y^{(i)})。 $$\n其中，$f(x^{(i)}; \\theta)$ 是模型的预测，$y^{(i)}$ 是第 $i$ 个样本的真实标签，$L$ 是损失函数（例如均方误差或交叉熵损失）。每次迭代的参数更新公式为：\n$$ \\theta := \\theta - \\eta \\cdot \\nabla_\\theta J(\\theta)。 $$\n1.2优点 稳定性高：每次参数更新使用整个训练集的梯度，梯度估计准确，更新稳定。 收敛性好：更容易接近全局最优解。 1.3 缺点 计算成本高：每次迭代都需要计算整个训练集的梯度，尤其对于大型数据集，计算成本非常高。 内存消耗大：需要在内存中存储整个训练集，内存消耗大。 二、随机梯度下降（Stochastic Gradient Descent, SGD） 2.1定义 随机梯度下降在每次迭代时，仅使用一个样本计算损失函数的梯度，并基于这个梯度来更新模型参数。损失函数 $J(\\theta; x^{(i)}, y^{(i)})$ 是第 $i$ 个样本的损失函数。每次迭代的参数更新公式为：\n$$ \\theta := \\theta - \\eta \\cdot \\nabla_\\theta J(\\theta; x^{(i)}, y^{(i)}) $$\n2.2优点 计算成本低：每次迭代只需计算一个样本的梯度，计算成本低。 快速更新：由于每次迭代计算量小，参数更新频繁，初期收敛速度快。 2.3 缺点 梯度估计噪声大：每次更新的梯度波动大，导致优化路径不稳定。 收敛性差：容易在局部最优解附近震荡，难以收敛到全局最优解。 三、小批量梯度下降（Mini-batch Gradient Descent） 3.1 定义 小批量梯度下降是批量梯度下降和随机梯度下降的折中方案。每次迭代时，使用一个小批量样本（mini-batch）计算梯度，并基于这个梯度来更新模型参数。损失函数 $J(\\theta; B)$ 是一个小批量 $B$ 样本的平均损失。每次迭代的参数更新公式为：\n$$ \\theta := \\theta - \\eta \\cdot \\nabla_\\theta J(\\theta; B) $$\n3.2 优点 计算效率高：相比批量梯度下降，每次迭代计算的小批量样本梯度减少了计算成本。 收敛速度快：相比随机梯度下降，更新更加稳定，减少了震荡。 硬件效率：可以利用 GPU 加速计算，提高计算效率。 3.3 缺点 需要调参：需要选择合适的小批量大小，影响性能。 复杂度增加：相对于随机梯度下降和批量梯度下降，算法实现复杂度增加。 四、三者之间的联系与区别 4.1 联系 目标一致：三种方法都旨在通过梯度下降优化损失函数，以找到模型参数的最优值。 基本原理相同：三种方法的核心都是基于梯度下降，即使用损失函数的梯度来更新模型参数。 4.2 区别 数据使用方式： 批量梯度下降：使用整个训练集计算梯度。 随机梯度下降：每次迭代只使用一个样本计算梯度。 小批量梯度下降：每次迭代使用一个小批量样本计算梯度。 计算成本： 批量梯度下降：计算成本最高，因为每次迭代计算整个训练集的梯度。 随机梯度下降：计算成本最低，因为每次迭代只计算一个样本的梯度。 小批量梯度下降：计算成本介于两者之间。 收敛速度与稳定性： 批量梯度下降：更新稳定，收敛速度较慢。 随机梯度下降：初期收敛速度快，但更新不稳定，容易震荡。 小批量梯度下降：折中了两者的优点，更新较稳定，收敛速度较快。 内存消耗： 批量梯度下降：需要在内存中存储整个训练集。 随机梯度下降：内存消耗最小，只需存储一个样本。 小批量梯度下降：内存消耗介于两者之间，只需存储一个小批量样本。 五、反映在损失函数曲线和准确度曲线上的表现 5.1 批量梯度下降 损失函数曲线：曲线平滑，稳步下降，趋向于全局最优解。 准确度曲线：曲线平滑，准确度稳步上升，最终趋于收敛。 5.2 随机梯度下降 损失函数曲线：曲线波动大，总体趋势下降，但存在震荡和噪声。 准确度曲线：曲线波动大，总体上升，但有时会明显下降。 5.3 小批量梯度下降 损失函数曲线：曲线相对平滑，但有一些波动，介于批量和随机之间。 准确度曲线：曲线相对平稳，但有一些波动，总体上升。 总结 批量梯度下降、随机梯度下降和小批量梯度下降是机器学习和深度学习中常见的优化算法。它们在计算成本、收敛速度和更新稳定性上各有优缺点。相比较批量梯度下降与随机梯度下降，小批量梯度下降通过结合两者的优点，广泛应用于实际深度学习任务中。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%89%B9%E9%87%8F%E9%9A%8F%E6%9C%BA%E4%B8%8E%E5%B0%8F%E6%89%B9%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94/","summary":"在机器学习和深度学习中，梯度下降是一种广泛使用的优化算法，用于最小化模型的损失函数，从而优化模型参数。梯度下降的三种主要变体是批量梯度下降、","title":"理解梯度下降：批量、随机与小批量的对比"},{"content":"\r在 Vim 的普通模式下，我们可以将光标放在括号内的任意位置输入如下命令快速删除括号（圆括号()、方括号[]、花括号{}）里的内容：\ndi(：删除当前括号对内的内容（但不删除括号本身）。其中，d 是删除命令，i( 表示括号 () 内的内容（i 表示 “inner”，内层）。 da(：删除当前括号对以及括号内的内容。其中，d 是删除命令，a( 表示括号 () 内的内容（a 表示 “around”，包括括号本身）。 对于方括号 [] 、花括号 {} 以及其他配对符号，如\u0026quot;\u0026quot;、''、\u0026lt;\u0026gt;等，使用方法与前述类似。 此外，在 Vim 的普通模式下，可以使用 vi* 或 va* 选择括号内的内容，并进入可视模式。\n","permalink":"https://oheyu.github.io/zh/posts/tech/vim%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%A0%E9%99%A4%E6%8B%AC%E5%8F%B7%E9%87%8C%E7%9A%84%E5%86%85%E5%AE%B9/","summary":"在 Vim 的普通模式下，我们可以将光标放在括号内的任意位置输入如下命令快速删除括号（圆括号()、方括号[]、花括号{}）里的内容： di(：删除当前","title":"Vim如何快速删除括号里的内容"},{"content":"\r大端序（Big-endian） 数据的高字节存储在低地址，低字节存储在高地址。即，大端序是从“最高有效字节（Most Significant Byte, MSB）”到“最低有效字节（Least Significant Byte, LSB）”按序排列的。\n小端序（Little-endian） 数据的低字节存储在低地址，高字节存储在高地址。即，小端序是从“最低有效字节”到“最高有效字节”按序排列的。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%AB%AF%E5%BA%8F/","summary":"大端序（Big-endian） 数据的高字节存储在低地址，低字节存储在高地址。即，大端序是从“最高有效字节（Most Significant Byte, MSB）”到“最低有效","title":"大端序与小端序"},{"content":"\r结构体（Struct） 结构体是一种用户定义的数据类型，允许将不同类型的变量组合在一起作为一个单一的实体进行处理。结构体常用于组织和管理不同类型的数据，使代码更具可读性和可维护性。结构体有如下三个关键特性：\n成员独立：结构体中的每个成员都有自己的内存空间，不同成员之间互不干扰；\n顺序存储：结构体中的成员按照声明的顺序依次存储在内存中，但可能存在字节填充（padding）以满足对齐要求；\n类型混合：结构体中可以包含不同类型的数据成员，例如整型、浮点型和字符数组等。\n以下是一个简短的代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; struct Person { char name[50]; int age; float height; }; int main() { Person person = {\u0026#34;Alice\u0026#34;, 30, 1.75}; std::cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; person.name \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; person.age \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Height: \u0026#34; \u0026lt;\u0026lt; person.height \u0026lt;\u0026lt; std::endl; return 0; } 联合体（Union） 同样的，联合体也是一种用户自定义的数据类型，允许将多个不同类型的变量存储在同一个内存位置。它常用于节省内存，尤其在需要处理多种数据类型但某一时刻只会使用其中一种的情况下。联合体有如下三个关键特性：\n共享内存：联合体中的所有成员共享同一块内存，某一时刻只能有一个成员是有效的；\n节省空间：联合体的大小等于其最大成员的大小；\n类型混合：同样可以包含不同类型的数据成员，但某一时刻只能使用某一个成员变量。\n以下是一个简短的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; union Data { int intValue; float flaotValue; char charValue; }; int main() { Data data; data.intValue = 10; std::cout \u0026lt;\u0026lt; \u0026#34;Integer: \u0026#34; \u0026lt;\u0026lt; data.intValue \u0026lt;\u0026lt; std::endl; data.floatValue = 3.14; std::cout \u0026lt;\u0026lt; \u0026#34;Float: \u0026#34; \u0026lt;\u0026lt; data.floatValue \u0026lt;\u0026lt; std::endl; data.charValue = \u0026#39;A\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Char: \u0026#34; \u0026lt;\u0026lt; data.charValue \u0026lt;\u0026lt; std::endl; return 0; } 结构体与联合体的对比分析 结构体 联合体 内存管理 每个成员都有独立的内存空间 所有成员共享同一内存空间 大小 所有成员大小之和（加上可能的填充字节） 最大成员的大小 数据有效性 结构体变量有效期中，所有成员始终有效 某一时刻，只能有一个成员有效 用途 数据记录、函数返回多个值 嵌入式系统节省内存、硬件寄存器访问 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E8%81%94%E5%90%88%E4%BD%93/","summary":"结构体（Struct） 结构体是一种用户定义的数据类型，允许将不同类型的变量组合在一起作为一个单一的实体进行处理。结构体常用于组织和管理不同类","title":"结构体与联合体"},{"content":"\r解释型语言 解释型语言是被解释器逐行解释和执行源代码的语言。这意味着程序代码在运行时将被直接翻译为机器代码并执行。\n解释型语言有以下三个优点以及一个缺点：\n即时执行：代码在运行时被逐行解释，没有预编译的过程； 跨平台：解释器有不同平台的发行版本，同样的代码可以在多个操作系统上被执行； 调试友好：由于代码是被逐行解释和执行，调试和测试过程相对简单，可以即时查看和修改代码的效果； 速度较慢：由于每次运行都需要解释代码，执行速度通常比编译型语言慢。 常见的解释型语言有：Python、JavaScript、Ruby等。\n编译型语言 编译型语言有以下特点：\n预编译：代码在运行前需要经过编译器完成编译，生成独立的可执行文件； 执行速度快：由于编译后的代码时机器代码，可以直接由硬件执行，运行速度通常比解释型语言快； 平台依赖性：编译后的可执行文件通常与特定的平台和操作系统绑定，跨平台需要重新编译源代码； 调试复杂：由于代码在编译前不能运行，调试过程复杂，需要依赖编译器提供的调试工具。 常见的编译型语言有：C、C++、Rust、Go等\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80/","summary":"解释型语言 解释型语言是被解释器逐行解释和执行源代码的语言。这意味着程序代码在运行时将被直接翻译为机器代码并执行。 解释型语言有以下三个优点以及","title":"解释型语言与编译型语言"},{"content":"\r在C、C++语言中，将源代码文件转换成可执行文件涉及多个步骤，主要包括预处理、编译、汇编和链接。\n源代码（Source code）文件 源代码文件包含了一系列人类可读的计算机语言指令。在 C 语言规范中，源代码文件通常以 .c 为拓展名；而在 C++ 语言规范中，源代码文件通常以 .cpp 为拓展名。\n预处理（Preprocessing） 预处理是编译过程的第一步。在这个过程中，预处理器处理源代码文件中以 # 开头的指令。这些指令包括头文件 #include、宏定义 #define 替换、条件编译 #ifdef 等。预处理的结果是一个 “拓展源代码” 文件，通常以 .i 为拓展名。具体来说，“拓展源代码” 是在原始源代码的基础上，展开所有的宏，插入所有头文件的内容，处理所有的条件编译。\n假设有如下的C++源代码文件 “main.cpp” ：\n1 2 3 4 5 6 7 8 // main.cpp #include \u0026lt;iostream\u0026gt; #define PI 3.1415926 int main() { std::cout \u0026lt;\u0026lt; \u0026#34;PI value is \u0026#34; \u0026lt;\u0026lt; PI \u0026lt;\u0026lt; std::endl; return 0; } 预处理后的代码将不包含 “#include” 和 “#define” 指令，而是包含了 “iostream” 的全部内容并替换 “PI” 的值：\n1 2 3 4 5 6 7 // main.i // iostream 内容展开 // 例如 std::ostream, std::cout等的定义 int main() { std::cout \u0026lt;\u0026lt; \u0026#34;PI value is \u0026#34; \u0026lt;\u0026lt; 3.1415926 \u0026lt;\u0026lt; std::endl; return 0; } 编译（Compilation） 编译器将预处理后的代码转换为目标平台的汇编语言。这一步涉及语法分析、语义分析与优化等。编译器输出的是汇编代码，通常以 .s 为拓展名，这些汇编指令是平台相关的，表示如何在特定的硬件上执行程序。编译后的汇编代码可能看起来像这样（以x86平台为例）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .section .rodata .LC0: .string \u0026#34;PI value is %f\\n\u0026#34; .text .globl main main: pushq %rbp movq %rsp, %rbp subq $16, %rsp movss $0x40490fdb, -4(%rbp) // PI value as float movq $LC0, %rdi leaq -4(%rbp), %rsi call printf movl $0, %eax leave ret 汇编（Assembly） 汇编器将汇编代码转换为机器代码，即二进制指令，这些指令可以由计算机的 CPU 直接执行。汇编器生成的是对象文件（Object file），通常以 .o（Unix/Linux系统）或 .obj（Windows系统）为拓展名。对象文件包含了编译后的代码的机器语言版本，但这些代码还未进行地址绑定。对象文件是二进制文件，通常不可读，但它包含了函数和数据的二进制表示。\n为什么汇编阶段不完成地址绑定? 在汇编阶段，代码被转换成机器可执行的指令。然而，指令中引用的函数和全局变量的具体内存地址通常尚未确定。这些引用被暂时标记为“待定”，直到链接阶段才会被解析和绑定。出现这种情况的原因如下：\n多模块程序：一个大型程序通常由多个源代码文件组成。经过 “预处理、编译、汇编” 这三个步骤后，每个源代码文件会被独立地转换成对象文件。在这个过程中，汇编器仅能处理当前模块中的符号（如函数、全局变量等），而无法得知其他模块中定义的符号的具体地址。因此，在汇编时，这些跨模块的引用会被标记为待定。 库连接：程序可能依赖于多个外部库，这些库在编译和汇编时也是被独立处理的。因此，库函数的具体内存地址在汇编阶段是未知的，汇编器无法将这些地址填入生成的指令中。这些库函数的地址同样会在链接阶段由链接器解析和绑定。 对于上述问题，汇编器和链接器通过重定位解决这一问题：\n重定位记录：汇编器生成的对象文件中包括机器指令和一些符号表，其中符号表记录了未解析的符号及其引用位置。对于同一模块内定义和使用的符号（例如局部变量），汇编器可以直接将地址填入机器指令中；而对于跨模块引用的符号（例如其他源文件或库中的函数和全局变量），汇编器会生成 “重定位表”，标记这些符号为未解析，并记录它们在目标文件中的位置。 链接：在链接阶段，链接器将所有对象文件和库文件合并成一个可执行文件。链接器首先扫描所有目标文件的符号表，构建全局符号表（Global Symbol Table），该表包含了所有模块中定义的符号及其相对地址。接着，链接器通过重定位表，将未解析的符号地址替换为它们在最终可执行文件中的实际地址。链接器将所有模块的代码和数据段重定位到最终的内存地址空间中，这样每个符号都能正确地被引用。 链接（Linking） 链接器处理一个或多个对象文件，解决外部符号引用，可能还会链接运行时库等。链接器将所有对象文件及所需的库文件集合在一起，生成最终的可执行文件（在Windows上是 .exe，在Unix/Linux上通常没有扩展名）。链接器生成的可执行文件包含了所有必要的程序代码、数据和运行时库的引用，这些都已经是准备好可以被操作系统加载和执行的格式。最终的可执行文件实现了特定平台上的 “一次编译，多次运行”。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/","summary":"在C、C++语言中，将源代码文件转换成可执行文件涉及多个步骤，主要包括预处理、编译、汇编和链接。 源代码（Source code）文件 源代码文件","title":"源文件到可执行文件的过程"}]