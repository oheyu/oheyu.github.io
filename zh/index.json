[{"content":"\rC++11 为多线程编程提供了标准化的线程库，通过 std::thread 类封装了底层操作系统的线程库。然而，不同的操作系统具有各自的线程管理功能，有时我们需要直接访问这些功能，而 C++ 标准库并不提供这些系统特定的操作。为了弥补这一不足，C++11 提供了 native_handle() 成员函数，允许我们访问与操作系统相关的原生线程句柄，进而利用操作系统的线程 API 来进行更多的控制。\n一、为什么需要 native_handle()？ 虽然 C++11 的 std::thread 类为多线程编程提供了统一的接口，但它封装了操作系统的线程库，限制了我们对线程的底层操作。有时我们可能需要直接使用操作系统提供的线程控制功能，例如取消线程、设置线程优先级、绑定线程到特定 CPU 核心等。这些操作在 C++ 标准库中是无法实现的，但通过 native_handle()，我们可以获取操作系统的原生线程句柄，从而使用底层线程库完成这些操作。\n二、native_handle() 的用法 native_handle() 是 std::thread 类的一个成员函数，它返回与操作系统相关的线程句柄。这个句柄可以用来调用操作系统提供的线程管理函数。\n在 Linux 系统中，native_handle() 返回的是 pthread_t 类型的线程句柄，这个句柄可以用于调用 POSIX 线程库（pthread）的函数。 在 Windows 系统中，它返回的是 HANDLE 类型的句柄，供 Windows API 使用。 1 pthread_t native_handle() noexcept; // Linux 系统上的函数签名 三、使用 native_handle() 操作线程 下面的代码展示了如何使用 native_handle() 获取 Linux 操作系统的原生线程句柄，并通过 pthread_cancel() 取消线程的执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;pthread.h\u0026gt; // Linux 的 pthread 线程库头文件。 #include \u0026lt;chrono\u0026gt; // 处理休眠时间 using namespace std; void func() { // 线程任务函数 for (int ii = 1; ii \u0026lt;= 10; ii++) { cout \u0026lt;\u0026lt; \u0026#34;ii = \u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::seconds(1)); // 每次循环休眠 1 秒 } } int main() { // 创建线程，执行 func 函数 thread tt(func); // 主线程休眠 5 秒 this_thread::sleep_for(chrono::seconds(5)); // 获取 Linux 原生的线程句柄 pthread_t thid = tt.native_handle(); // 使用 pthread_cancel 取消线程 pthread_cancel(thid); // 等待线程结束 tt.join(); return 0; } 3.1 代码分析 线程创建：thread tt(func); 创建了一个执行 func() 函数的线程，线程开始运行，并输出 ii 的值。 主线程休眠：this_thread::sleep_for(chrono::seconds(5)); 主线程休眠 5 秒，给子线程一些时间运行。 获取原生句柄：pthread_t thid = tt.native_handle(); 通过 native_handle() 获取了线程的原生 pthread_t 句柄。 取消线程：pthread_cancel(thid); 调用 POSIX 的 pthread_cancel() 函数来取消正在执行的线程。 等待线程结束：tt.join(); 主线程等待子线程完成。即使线程被取消，我们依然需要调用 join() 来正确回收线程的资源。 3.2 输出结果 1 2 3 4 5 ii = 1 ii = 2 ii = 3 ii = 4 ii = 5 在主线程休眠 5 秒后，调用 pthread_cancel() 取消子线程。由于子线程在 5 秒后被取消，只有前 5 次的 ii 输出被打印。\n四、使用 native_handle() 的注意事项 平台依赖性：native_handle() 返回的线程句柄类型是操作系统相关的。例如在 Linux 系统上，它返回 pthread_t，而在 Windows 系统上返回的是 HANDLE。因此，使用 native_handle() 时要确保代码针对不同操作系统进行适配。\n线程安全性：当调用操作系统的线程函数时，要确保线程的状态和生命周期是安全的。例如，在调用 pthread_cancel() 取消线程之前，应确保线程已经正确启动。\n异常处理：在多线程环境中，异常处理非常重要。特别是在使用系统原生的线程 API 时，需要注意处理可能的错误，例如取消失败、权限问题等。\n五、应用场景 native_handle() 主要用于以下场景：\n线程优先级控制：通过原生线程句柄，可以设置线程的调度优先级，以确保关键任务线程能够优先获得 CPU 资源。 线程取消：在某些情况下，必须强制取消正在运行的线程，标准 C++ 线程库不提供此功能，但通过 native_handle() 可以调用底层操作系统提供的取消函数。 线程绑定：有时需要将线程绑定到特定的 CPU 核心，以提高多线程程序的性能，特别是在多核 CPU 的环境中。这可以通过操作系统的线程库实现。 六、总结 C++11 的 std::thread 为跨平台的多线程编程提供了便利，但它隐藏了底层的许多细节，限制了我们对线程的精细控制。通过 native_handle()，我们能够访问操作系统提供的原生线程句柄，从而利用操作系统的线程库来执行更多特定的操作。\n虽然 native_handle() 提供了灵活性，但使用时需要谨慎，特别是在跨平台开发中，需要针对不同系统编写适配代码。\n","permalink":"https://oheyu.github.io/zh/posts/tech/native_handle%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%94%9F%E7%BA%BF%E7%A8%8B%E5%8F%A5%E6%9F%84/","summary":"C++11 为多线程编程提供了标准化的线程库，通过 std::thread 类封装了底层操作系统的线程库。然而，不同的操作系统具有各自的线程管理功能，有时我们需要直接访问这些","title":"Native_handle访问系统原生线程句柄"},{"content":"\r在 C++ 中，所有可以像函数一样被调用的实体，统称为可调用对象（Callable Objects）。这些对象不仅仅局限于普通函数，还包括类的静态成员函数、仿函数（Functors）、lambda 表达式、类的非静态成员函数以及可转换为函数指针的类对象。本文将详细介绍这些不同的可调用对象，并探讨它们的使用场景及特点。嗯，语气比较严肃。!_!\n一、普通函数 普通函数是最常见的可调用对象。在 C++ 中，普通函数可以通过函数指针和函数引用来存储和调用。\n1.1 普通函数的定义与调用 普通函数的声明非常简单，我们可以为普通函数类型定义别名，并声明函数指针或函数引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; using namespace std; using Fun = void (int, const string\u0026amp;); // 定义普通函数类型的别名 // 函数声明 Fun show; int main() { show(1, \u0026#34;我是普通函数调用。\u0026#34;); void(*fp1)(int, const string\u0026amp;) = show; // 函数指针 void(\u0026amp;fr1)(int, const string\u0026amp;) = show; // 函数引用 fp1(2, \u0026#34;使用函数指针调用。\u0026#34;); fr1(3, \u0026#34;使用函数引用调用。\u0026#34;); Fun* fp2 = show; // 使用别名创建函数指针 Fun\u0026amp; fr2 = show; // 使用别名创建函数引用 fp2(4, \u0026#34;使用别名的函数指针。\u0026#34;); fr2(5, \u0026#34;使用别名的函数引用。\u0026#34;); } // 函数定义 void show(int bh, const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;编号\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } 1.2 注意事项 普通函数可以通过函数指针和函数引用来调用。 函数的类型可以通过 using 来定义别名，以简化代码。 C++ 中不能用函数类型定义函数的实体，函数类型只能用于声明。 二、类的静态成员函数 类的静态成员函数与普通函数本质上相同。它们与类的实例无关，因此可以直接通过类名或函数指针进行调用。\n2.1 静态成员函数的定义与调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; struct MyClass { static void show(int bh, const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;编号\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } }; int main() { MyClass::show(1, \u0026#34;直接调用静态成员函数。\u0026#34;); void(*fp1)(int, const string\u0026amp;) = MyClass::show; // 函数指针指向静态成员函数 fp1(2, \u0026#34;使用函数指针调用静态成员函数。\u0026#34;); using Fun = void (int, const string\u0026amp;); Fun* fp2 = MyClass::show; fp2(3, \u0026#34;使用别名的函数指针调用静态成员函数。\u0026#34;); } 2.2 特点 静态成员函数不依赖于对象实例，可以像普通函数一样调用。 与普通函数类似，静态成员函数也可以使用函数指针和函数引用来存储和调用。 三、仿函数（Functor） 仿函数本质上是一个重载了 operator() 运算符的类。通过这种运算符重载，类的对象可以像函数一样被调用。\n3.1 仿函数的定义与调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; using namespace std; struct Functor { void operator()(int bh, const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;编号\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } }; int main() { Functor fun; fun(1, \u0026#34;调用仿函数。\u0026#34;); Functor()(2, \u0026#34;调用匿名对象的仿函数。\u0026#34;); } 3.2 特点 仿函数是通过 operator() 运算符来模拟函数调用的类对象。 仿函数常用于 STL 算法中，它们可以存储状态，比普通函数更灵活。 四、Lambda表达式 Lambda 表达式本质上是一个匿名的仿函数。它是 C++11 引入的一个特性，用于简洁地定义内联函数。\n4.1 Lambda表达式的定义与调用 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { auto lambda = [](int bh, const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;编号\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; }; lambda(1, \u0026#34;调用Lambda表达式。\u0026#34;); auto\u0026amp; lambda_ref = lambda; // 引用Lambda表达式 lambda_ref(2, \u0026#34;引用Lambda表达式调用。\u0026#34;); } 4.2 特点 Lambda 表达式是一种简洁的匿名函数对象，通常用于一次性操作。 Lambda 表达式的类型是匿名的，因此只能通过 auto 或模板进行类型推导。 五、类的非静态成员函数 类的非静态成员函数不同于普通函数和静态成员函数，它只能通过类的实例进行调用。其指针类型特殊，不能通过引用调用。\n5.1 非静态成员函数的定义与调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; struct MyClass { void show(int bh, const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;编号\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } }; int main() { MyClass obj; obj.show(1, \u0026#34;直接调用非静态成员函数。\u0026#34;); void (MyClass::* fp)(int, const string\u0026amp;) = \u0026amp;MyClass::show; (obj.*fp)(2, \u0026#34;通过成员函数指针调用。\u0026#34;); } 对于普通函数，你可以直接写函数名来获取它的地址，但对于成员函数，由于它依赖于类和对象，必须通过 \u0026amp; 明确表示你是在获取地址，而不是在引用或声明函数。\n5.2 特点 非静态成员函数必须通过对象调用，不能像普通函数一样通过函数指针直接调用。 只能使用成员函数指针来调用非静态成员函数。 六、可转换为函数指针的类对象 通过重载 operator() 或重载类型转换运算符，类对象可以被转换为函数指针，使得类的对象也能像函数一样调用。这个，我认为仅作了解吧，我不是很理解。\n6.1 可转换为函数指针的类对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; void show(int bh, const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;编号\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } struct CallableClass { using Fun = void(*)(int, const string\u0026amp;); operator Fun() { return show; } }; int main() { CallableClass callable; callable(1, \u0026#34;调用可转换为函数指针的类对象。\u0026#34;); } 6.2 特点 这种方式允许将类对象隐式转换为函数指针，调用方式类似函数对象。 在实际开发中，这种技巧较为少见，但可以用于某些特殊需求场景。 总结 C++中的可调用对象种类丰富且灵活，包括普通函数、静态成员函数、仿函数、lambda 表达式、非静态成员函数以及可转换为函数指针的类对象。每种可调用对象都有其特定的使用场景与优点，在编写泛型代码、设计类接口以及高效处理函数调用时，这些可调用对象能够极大地提升代码的灵活性与可扩展性。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/","summary":"在 C++ 中，所有可以像函数一样被调用的实体，统称为可调用对象（Callable Objects）。这些对象不仅仅局限于普通函数，还包括类的静态成员","title":"CPP中的可调用对象"},{"content":"\rstd::function 是一种通用的模板类，用于封装不同类型的可调用对象并通过统一的接口调用它们，使得处理这些可调用对象变得更加简洁、灵活。\n一、什么是 std::function？ std::function 是 C++ 标准库中的一个通用包装器，用于存储、传递和调用任何可调用对象。无论是函数、Lambda 表达式、函数对象（仿函数）还是成员函数，都可以通过 std::function 进行包装和调用。它的主要特性包括：\n通用性：能够封装不同类型的可调用对象。 一致性：通过统一的接口调用不同类型的可调用对象。 类型安全：通过模板机制，保证调用时的类型安全。 std::function 的原型如下：\n1 2 template\u0026lt;class _Fty\u0026gt; class function; _Fty 是可调用对象的类型，通常格式为：返回类型(参数列表)。 为了使用 std::function，你需要包含头文件：\n1 #include \u0026lt;functional\u0026gt; 二、std::function 的基本用法 std::function 的使用非常简单，它可以包裹不同类型的可调用对象。下面我们看一看如何将普通函数、静态成员函数、仿函数、Lambda 表达式以及类的成员函数都包装进 std::function 对象中，并进行调用。\n2.1 包装普通函数 普通函数是最常见的可调用对象。我们可以用 std::function 来包装普通函数，并通过包装器对象进行调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; // 普通函数 void show(int bh, const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;亲爱的 \u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;，\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } int main() { // 使用 std::function 包装普通函数 std::function\u0026lt;void(int, const string\u0026amp;)\u0026gt; fn = show; // 通过 std::function 调用普通函数 fn(1, \u0026#34;我是一只傻傻鸟。\u0026#34;); return 0; } 2.2 包装类的静态成员函数 类的静态成员函数本质上与普通函数类似，因此也可以通过 std::function 进行包装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct AA { static void show(int bh, const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;亲爱的 \u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;，\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } }; int main() { // 使用 std::function 包装静态成员函数 std::function\u0026lt;void(int, const string\u0026amp;)\u0026gt; fn = AA::show; // 通过 std::function 调用静态成员函数 fn(2, \u0026#34;我是一只傻傻鸟。\u0026#34;); return 0; } 2.3 包装仿函数（函数对象） 仿函数是通过重载 operator() 操作符的类对象。它们在需要自定义行为时非常有用，也可以通过 std::function 进行包装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct BB { void operator()(int bh, const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;亲爱的 \u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;，\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } }; int main() { // 包装仿函数 std::function\u0026lt;void(int, const string\u0026amp;)\u0026gt; fn = BB(); // 通过 std::function 调用仿函数 fn(3, \u0026#34;我是一只傻傻鸟。\u0026#34;); return 0; } 2.4 包装 Lambda 表达式 Lambda 表达式是 C++11 引入的一种简洁的函数定义方式，特别适合用于短小的函数逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { // 定义 Lambda 表达式 auto lambda = [](int bh, const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;亲爱的 \u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;，\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; }; // 使用 std::function 包装 Lambda 表达式 std::function\u0026lt;void(int, const string\u0026amp;)\u0026gt; fn = lambda; // 通过 std::function 调用 Lambda 表达式 fn(4, \u0026#34;我是一只傻傻鸟。\u0026#34;); return 0; } 2.5 包装类的非静态成员函数 包装非静态成员函数略显复杂，因为非静态成员函数只能通过对象来调用。因此，std::function 在包装非静态成员函数时，必须将对象和成员函数一起传递。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct CC { void show(int bh, const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;亲爱的 \u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;，\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } }; int main() { CC cc; // 使用 std::function 包装非静态成员函数 std::function\u0026lt;void(CC\u0026amp;, int, const string\u0026amp;)\u0026gt; fn = \u0026amp;CC::show; // 通过 std::function 调用非静态成员函数 fn(cc, 5, \u0026#34;我是一只傻傻鸟。\u0026#34;); return 0; } 2.6 包装可转换为函数指针的类对象 如果一个类可以通过类型转换运算符转换为函数指针，它的对象也可以被 std::function 包装。同样的，这个方面仅作了解吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct DD { using Fun = void (*)(int, const string\u0026amp;); operator Fun() { return show; // 转换为普通函数指针 } }; int main() { DD dd; // 使用 std::function 包装可转换为函数指针的对象 std::function\u0026lt;void(int, const string\u0026amp;)\u0026gt; fn = dd; // 通过 std::function 调用普通函数 fn(6, \u0026#34;我是一只傻傻鸟。\u0026#34;); return 0; } 三、std::function 的异常处理 当 std::function 未包装任何可调用对象时，使用它将抛出 std::bad_function_call 异常。我们可以通过重载的 bool 运算符来检测 std::function 是否有效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { std::function\u0026lt;void(int, const string\u0026amp;)\u0026gt; fn; try { if (fn) { fn(7, \u0026#34;这是一个有效的调用。\u0026#34;); } else { cout \u0026lt;\u0026lt; \u0026#34;未包装任何可调用对象。\u0026#34; \u0026lt;\u0026lt; endl; } } catch (std::bad_function_call\u0026amp; e) { cout \u0026lt;\u0026lt; \u0026#34;抛出了 std::bad_function_call 异常。\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 四、总结 std::function 是一个强大的工具，能够统一处理各种类型的可调用对象。无论是普通函数、静态成员函数、仿函数、Lambda 表达式，还是类的非静态成员函数，std::function 都能通过统一的接口进行管理和调用，从而简化了 C++ 编程中的函数对象管理。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8/","summary":"std::function 是一种通用的模板类，用于封装不同类型的可调用对象并通过统一的接口调用它们，使得处理这些可调用对象变得更加简洁、灵活。 一、什么是 std::f","title":"CPP中的可调用对象包装器"},{"content":"\rC++ 中，通用的函数适配器 std::bind 是一个强大而灵活的工具。它允许将可调用对象及其参数进行绑定，并生成一个新的可调用对象。在涉及回调机制、延迟函数执行、函数参数部分绑定等场景中，std::bind 的作用尤为突出。\n一、什么是 std::bind？ std::bind 是 C++ 标准库中的一个模板函数，用来将可调用对象（如普通函数、成员函数、Lambda 函数、仿函数等）与参数绑定在一起，生成一个新的函数对象或 std::function 对象。\n其核心函数原型如下：\n1 2 template\u0026lt; class Fx, class... Args \u0026gt; function\u0026lt;\u0026gt; bind(Fx\u0026amp;\u0026amp; fx, Args\u0026amp;\u0026amp;... args); Fx：可调用对象的类型，可以是普通函数、成员函数、Lambda 表达式、仿函数，甚至是另一个 std::function 对象。 Args：可变参数模板，表示要绑定的参数，可以是值、引用或占位符 std::placeholders::_n。 返回值：std::bind 返回一个新的可调用对象，通常为 std::function 类型的实例，可以像调用普通函数一样使用。\n二、std::bind 的基本用法 2.1 普通函数的绑定 普通函数是 std::bind 支持的最基本的可调用对象。通过 std::bind，我们可以将部分参数绑定，从而生成一个新的函数对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; void show(int bh, const std::string\u0026amp; message) { std::cout \u0026lt;\u0026lt; \u0026#34;编号 \u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } int main() { using namespace std::placeholders; // 绑定普通函数，生成一个新的可调用对象 std::function\u0026lt;void(int, const std::string\u0026amp;)\u0026gt; fn1 = std::bind(show, _1, _2); fn1(1, \u0026#34;我是一只傻傻鸟。\u0026#34;); // 调用绑定后的函数对象 // 调整参数顺序的绑定 std::function\u0026lt;void(const std::string\u0026amp;, int)\u0026gt; fn2 = std::bind(show, _2, _1); fn2(\u0026#34;我是一只傻傻鸟。\u0026#34;, 2); // 交换参数位置后调用 } 在这个例子中：\n_1 和 _2 是占位符，表示我们可以在调用 fn1 和 fn2 时指定这些参数。 std::bind 返回了一个新的函数对象 fn1 和 fn2，它们可以接受相应的参数并调用原函数 show。 三、支持多种可调用对象 std::bind 可以绑定多种类型的可调用对象，包括普通函数、成员函数、Lambda 表达式、仿函数等。\n3.1 绑定静态成员函数 静态成员函数的本质与普通函数类似，因此可以直接通过 std::bind 进行绑定。\n1 2 3 4 5 6 7 8 9 10 11 12 struct AA { static void show(int bh, const std::string\u0026amp; message) { std::cout \u0026lt;\u0026lt; \u0026#34;编号 \u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; int main() { using namespace std::placeholders; std::function\u0026lt;void(int, const std::string\u0026amp;)\u0026gt; fn3 = std::bind(AA::show, _1, _2); fn3(2, \u0026#34;我是一只傻傻鸟。\u0026#34;); } 3.2 绑定仿函数 仿函数（即重载了 operator() 的类）也可以通过 std::bind 进行绑定。仿函数常用于自定义函数对象或策略模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct BB { void operator()(int bh, const std::string\u0026amp; message) { std::cout \u0026lt;\u0026lt; \u0026#34;编号 \u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; int main() { using namespace std::placeholders; BB bb; std::function\u0026lt;void(int, const std::string\u0026amp;)\u0026gt; fn4 = std::bind(bb, _1, _2); fn4(3, \u0026#34;我是一只傻傻鸟。\u0026#34;); } 3.3 绑定 Lambda 表达式 Lambda 表达式是 C++11 引入的一种轻量级可调用对象，也可以通过 std::bind 进行部分参数绑定。\n1 2 3 4 5 6 7 8 int main() { auto lambda = [](int bh, const std::string\u0026amp; message) { std::cout \u0026lt;\u0026lt; \u0026#34;编号 \u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; }; std::function\u0026lt;void(int, const std::string\u0026amp;)\u0026gt; fn5 = std::bind(lambda, std::placeholders::_1, std::placeholders::_2); fn5(4, \u0026#34;我是一只傻傻鸟。\u0026#34;); } 3.4 绑定类的非静态成员函数 绑定非静态成员函数时，必须传递类实例的指针或引用，确保调用时有具体的对象来操作。\n1 2 3 4 5 6 7 8 9 10 11 struct CC { void show(int bh, const std::string\u0026amp; message) { std::cout \u0026lt;\u0026lt; \u0026#34;编号 \u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; int main() { CC cc; std::function\u0026lt;void(int, const std::string\u0026amp;)\u0026gt; fn6 = std::bind(\u0026amp;CC::show, \u0026amp;cc, std::placeholders::_1, std::placeholders::_2); fn6(5, \u0026#34;我是一只傻傻鸟。\u0026#34;); } 在绑定非静态成员函数时，\u0026amp;CC::show 表示成员函数指针，而 \u0026amp;cc 表示该成员函数操作的实例。\n3.5 绑定可转换为函数指针的类对象 通过类型转换操作符，类的实例也可以被转换为函数指针，从而通过 std::bind 进行绑定。\n1 2 3 4 5 6 7 8 9 10 11 12 struct DD { using Fun = void (*)(int, const std::string\u0026amp;); operator Fun() const { return show; } }; int main() { DD dd; std::function\u0026lt;void(int, const std::string\u0026amp;)\u0026gt; fn7 = std::bind(dd, std::placeholders::_1, std::placeholders::_2); fn7(6, \u0026#34;我是一只傻傻鸟。\u0026#34;); } 四、std::bind 的参数占位符与参数绑定 在使用 std::bind 进行绑定时，我们可以选择哪些参数在绑定时固定，哪些参数在调用时动态传入。这里需要使用 std::placeholders::_n 占位符。\n_1, _2, _3 等占位符用于表示调用时的参数。 非占位符参数将在绑定时固定。 1 2 3 4 5 6 7 int main() { using namespace std::placeholders; // 将第一个参数固定为 3，只需传递剩余的参数 std::function\u0026lt;void(const std::string\u0026amp;)\u0026gt; fn8 = std::bind(show, 3, _1); fn8(\u0026#34;我是一只傻傻鸟。\u0026#34;); } 五、总结 std::bind 是 C++ 中极其强大的函数适配器，它通过绑定可调用对象及其参数生成新的函数对象，从而提供了灵活的参数绑定和调用方式。无论是处理普通函数、成员函数，还是仿函数和 Lambda 表达式，std::bind 都能够简化代码并提高可读性。理解 std::bind 的用法，能够帮助开发者编写更为简洁和通用的代码，尤其是在需要延迟执行、回调函数或函数适配器的场景中。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8/","summary":"C++ 中，通用的函数适配器 std::bind 是一个强大而灵活的工具。它允许将可调用对象及其参数进行绑定，并生成一个新的可调用对象。在涉及回调机制、延迟函数执行、","title":"CPP中的函数适配器"},{"content":"\r在异步编程中，回调函数是一种非常常见的设计模式，尤其是在消息队列或网络库中。它允许我们在接收到消息（或事件）时，调用预先注册的用户自定义处理逻辑，并将消息或事件参数传递给回调函数。通过这种机制，系统能够灵活地处理不同的消息类型，而无需硬编码每种消息的处理逻辑。\n今天，我们详细解析如何通过 C++ 实现一个带有回调机制的消息队列，并探讨回调函数的注册、消息生产与消费，以及多线程环境下如何有效处理并发。\n一、回调函数的概念 回调函数是一种函数指针或函数对象，它在特定的事件发生时被调用。在消息队列系统中，回调函数可以用来处理接收到的消息。例如，当一个消息被消费者线程取出队列时，系统会调用之前注册的回调函数，并将该消息传递给它进行处理。\n二、示例描述 我们将通过一个简单的消息队列框架来演示回调机制：\n消息生产者会将消息（字符串）放入消息队列。 消费者线程会从队列中取出消息，并调用预先注册的回调函数来处理这些消息。 回调函数可以是普通函数、类的成员函数或其他可调用对象（如 std::function 或 Lambda 函数）。 三、代码结构设计 3.1 主要模块 消息队列（AA 类）：负责存储消息，并通过条件变量和互斥锁确保线程安全。 回调注册与调用：通过 std::function 包装回调函数，支持普通函数、成员函数等。 生产者与消费者模型：多个消费者线程会并发地从队列中取消息并处理。 四、代码实现 以下代码展示了如何实现一个带回调机制的消息队列系统：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; // 线程类头文件。 #include \u0026lt;mutex\u0026gt; // 互斥锁类的头文件。 #include \u0026lt;deque\u0026gt; // deque容器的头文件。 #include \u0026lt;queue\u0026gt; // queue容器的头文件。 #include \u0026lt;condition_variable\u0026gt; // 条件变量的头文件。 #include \u0026lt;functional\u0026gt; // 函数对象及回调机制 using namespace std; // 普通函数，用于处理消息 void show(const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;处理数据：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } // 类BB，包含一个成员函数用于处理消息 struct BB { void show(const string\u0026amp; message) { cout \u0026lt;\u0026lt; \u0026#34;处理表白数据：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } }; // 消息队列类，负责生产与消费消息 class AA { mutex m_mutex; // 互斥锁，确保多线程访问时的安全性。 condition_variable m_cond; // 条件变量，消费者等待消息到来。 queue\u0026lt;string, deque\u0026lt;string\u0026gt;\u0026gt; m_q; // 消息队列，存储生产的数据。 function\u0026lt;void(const string\u0026amp;)\u0026gt; m_callback; // 回调函数，用于处理消息。 public: // 注册回调函数，回调函数可以是普通函数、成员函数或Lambda等 template\u0026lt;typename Fn, typename ...Args\u0026gt; void callback(Fn\u0026amp;\u0026amp; fn, Args\u0026amp;\u0026amp;...args) { // 绑定回调函数，使用 std::bind 实现可调用对象的绑定 m_callback = bind(forward\u0026lt;Fn\u0026gt;(fn), forward\u0026lt;Args\u0026gt;(args)..., std::placeholders::_1); } // 生产数据，将消息放入队列 void incache(int num) { lock_guard\u0026lt;mutex\u0026gt; lock(m_mutex); // 申请锁 for (int i = 0; i \u0026lt; num; ++i) { static int bh = 1; // 消息编号 string message = to_string(bh++) + \u0026#34;号超女\u0026#34;; // 生成消息 m_q.push(message); // 将消息放入队列 } m_cond.notify_all(); // 通知所有等待的消费者 } // 消费者线程，从队列中取消息并调用回调函数处理 void outcache() { while (true) { unique_lock\u0026lt;mutex\u0026gt; lock(m_mutex); // 加锁 m_cond.wait(lock, [this] { return !m_q.empty(); }); // 等待有消息到来 string message = m_q.front(); // 获取队列中的消息 m_q.pop(); // 将消息出队 lock.unlock(); // 解锁，允许生产者继续添加消息 cout \u0026lt;\u0026lt; \u0026#34;线程：\u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;，消息：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; if (m_callback) m_callback(message); // 调用回调函数处理消息 } } }; 五、代码解析 5.1 普通函数与类成员函数 show(const string\u0026amp;) 是一个普通的处理函数，用于打印消息。 类 BB 包含了一个成员函数 show，用于处理消息。 5.2 消息队列类 AA AA 类中包含了以下主要部分：\n回调函数注册：通过 callback() 函数注册回调函数，使用 std::bind 绑定任意可调用对象（普通函数、成员函数等），并存储在 std::function 对象 m_callback 中。 生产数据：incache() 函数用于将指定数量的消息生成并放入队列，并通过条件变量唤醒等待的消费者线程。 消费数据：outcache() 函数是消费者线程的任务函数，它从队列中取出消息，并调用预先注册的回调函数处理消息。 5.3 生产者与消费者 main() 函数展示了如何创建多个消费者线程，并注册不同的回调函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int main() { AA aa; // 注册普通函数为回调函数 // aa.callback(show); // 注册类成员函数为回调函数 BB bb; aa.callback(\u0026amp;BB::show, \u0026amp;bb); // 创建多个消费者线程 thread t1(\u0026amp;AA::outcache, \u0026amp;aa); thread t2(\u0026amp;AA::outcache, \u0026amp;aa); thread t3(\u0026amp;AA::outcache, \u0026amp;aa); this_thread::sleep_for(chrono::seconds(2)); // 模拟主线程的其他操作 aa.incache(2); // 生产2条消息 this_thread::sleep_for(chrono::seconds(3)); aa.incache(5); // 生产5条消息 // 等待消费者线程完成 t1.join(); t2.join(); t3.join(); return 0; } 六、关键技术点 6.1 std::function 与 std::bind std::function：是一个通用的可调用对象的包装器，能够存储任意的函数、Lambda 表达式或成员函数，并将其统一处理。 std::bind：用于将函数与参数绑定，并生成一个新的可调用对象。结合占位符 std::placeholders::_1 等，可以灵活地将参数传递给回调函数。 6.2 多线程同步与互斥 互斥锁（std::mutex）：确保多线程访问共享资源时的安全性。 条件变量（std::condition_variable）：用于在消费者线程等待数据时阻塞，直到有新数据被放入队列。 七、总结 本文实现了一个带有回调机制的消息队列框架，通过 std::function 和 std::bind，我们可以灵活地注册不同的回调函数（包括普通函数、成员函数等），并在消息到达时自动调用回调函数处理消息。在多线程环境中，通过互斥锁和条件变量，我们确保了消息生产与消费过程的同步和线程安全。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","summary":"在异步编程中，回调函数是一种非常常见的设计模式，尤其是在消息队列或网络库中。它允许我们在接收到消息（或事件）时，调用预先注册的用户自定义处理","title":"消息队列中的回调函数"},{"content":"\r对于 C++ 编程，多态是面向对象编程的核心特性之一。虚函数是实现多态性的主要工具，它允许通过基类指针或引用来调用派生类的成员函数，从而实现动态的行为。然而，由于虚表（vtable）机制的存在，虚函数调用涉及两次指令跳转，可能导致性能下降。本次讨论，我将深入探讨虚函数的执行原理、性能影响，并通过回调函数的方式实现类似的多态性，以避免虚函数的开销。\n一、虚函数的工作原理 在 C++ 中，当一个类声明了虚函数时，编译器为该类生成一个虚函数表（vtable）。这个表包含了该类所有虚函数的指针。每个包含虚函数的对象还拥有一个隐藏的指针，指向它所属类的虚表。调用虚函数时，会发生以下步骤：\n查找虚表：首先，程序查找对象的虚表指针。 跳转到函数指针：然后，从虚表中找到对应的虚函数指针。 执行函数：最后，跳转到虚函数的实际地址执行。 虽然虚表机制在支持多态性方面非常灵活，但每次调用虚函数时都需要两次跳转：一次查找虚表，另一次跳转到函数的实际地址。这种多次跳转会导致 CPU 的指令预取（prefetch）失效，从而降低程序的执行效率。\n相比之下，普通函数只需一次跳转，执行效率更高。因此，在性能敏感的场景下，避免虚函数的开销是一个值得考虑的问题。（严肃的语气）\n二、回调函数：一种替代虚函数的方式 为了避免虚函数带来的性能损失，可以使用回调函数来实现类似的多态性。回调函数允许我们在运行时动态地指定要调用的函数，而不需要依赖虚表机制。\n在 C++ 中，std::function 是一个通用的函数对象包装器，它可以存储任何可调用对象（如普通函数、lambda、仿函数、成员函数等）。结合 std::bind，我们可以灵活地将不同的派生类成员函数注册为回调函数，从而实现类似于虚函数的动态调用机制，但避免了虚表查找的额外开销。\n三、示例：用回调函数实现多态性 以下是一个通过回调函数实现多态性的示例。假设我们有两个英雄类 XS（西施）和 HX（韩信），每个类都有自己的 show 函数来展示不同的技能。我们使用回调函数代替虚函数来动态调用这些派生类的函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; // 英雄基类 struct Hero { function\u0026lt;void()\u0026gt; m_callback; // 用于绑定子类的成员函数 // 注册子类成员函数，子类成员函数没有参数 template\u0026lt;typename Fn, typename ...Args\u0026gt; void callback(Fn\u0026amp;\u0026amp; fn, Args\u0026amp;\u0026amp;...args) { m_callback = bind(forward\u0026lt;Fn\u0026gt;(fn), forward\u0026lt;Args\u0026gt;(args)...); } // 调用注册的子类成员函数 void show() { if (m_callback) m_callback(); else cout \u0026lt;\u0026lt; \u0026#34;未注册技能。\\n\u0026#34;; } }; // 西施派生类 struct XS : public Hero { void show() { cout \u0026lt;\u0026lt; \u0026#34;西施释放了技能。\\n\u0026#34;; } }; // 韩信派生类 struct HX : public Hero { void show() { cout \u0026lt;\u0026lt; \u0026#34;韩信释放了技能。\\n\u0026#34;; } }; int main() { int id = 0; // 英雄的ID cout \u0026lt;\u0026lt; \u0026#34;请输入英雄（1-西施；2-韩信）：\u0026#34;; cin \u0026gt;\u0026gt; id; // 创建基类指针，用于指向派生类对象 Hero* ptr = nullptr; if (id == 1) { ptr = new XS; ptr-\u0026gt;callback(\u0026amp;XS::show, static_cast\u0026lt;XS*\u0026gt;(ptr)); // 注册子类成员函数 } else if (id == 2) { ptr = new HX; ptr-\u0026gt;callback(\u0026amp;HX::show, static_cast\u0026lt;HX*\u0026gt;(ptr)); // 注册子类成员函数 } // 调用子类的show函数 if (ptr != nullptr) { ptr-\u0026gt;show(); // 动态调用派生类函数 delete ptr; // 释放派生类对象 } return 0; } 四、代码详解 4.1 基类 Hero Hero 是一个基类，包含一个 std::function\u0026lt;void()\u0026gt; 成员 m_callback，用于存储子类的成员函数。 callback 函数使用 std::bind 将子类的 show 函数绑定到 m_callback 中，从而动态注册子类的成员函数。 show 函数通过调用 m_callback 来执行注册的子类函数。 4.2 派生类 XS 和 HX XS 和 HX 是派生类，分别定义了自己的 show 函数，用于展示不同的技能。它们继承了基类 Hero 的 callback 机制，通过基类指针可以动态调用各自的 show 函数。 4.3 主函数 main 用户输入英雄编号 id，根据输入选择 XS 或 HX。 使用基类指针 ptr 指向派生类对象，并通过 callback 注册派生类的 show 函数。 调用 ptr-\u0026gt;show()，通过回调机制动态执行派生类的函数，达到类似虚函数的多态性效果。 五、回调函数与虚函数的对比 特性 虚函数 回调函数（std::function） 调用开销 两次跳转，较慢 一次跳转，较快 实现机制 依赖虚表（vtable） 使用 std::function 和 std::bind 适用场景 需要动态绑定成员函数时 需要灵活、高效的多态性时 支持的可调用对象类型 仅支持成员函数 支持普通函数、成员函数、lambda、仿函数等 多态性 是，通过继承和重写实现 是，通过回调函数绑定实现 六、总结 虚函数是 C++ 实现多态性的传统方式，但由于虚表查找和多次跳转的开销，性能相对较低。在性能敏感的场景中，使用回调函数（std::function 和 std::bind）可以作为虚函数的替代方案，通过动态绑定不同的子类成员函数，达到类似多态性的效果，同时减少性能开销。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%9B%BF%E4%BB%A3%E5%93%81/","summary":"对于 C++ 编程，多态是面向对象编程的核心特性之一。虚函数是实现多态性的主要工具，它允许通过基类指针或引用来调用派生类的成员函数，从而实现动态的行","title":"CPP的虚函数及其替代品"},{"content":"\r在并发环境中，如何保证数据在多个线程之间的同步与一致性是一个关键问题。传统的同步方式使用互斥锁（mutex）来保护共享数据，但锁的使用带来了额外的开销。为了解决这个问题，C++11 提供了 atomic\u0026lt;T\u0026gt; 模板类，它允许在不使用锁的情况下安全地进行多线程编程。atomic\u0026lt;T\u0026gt; 提供了对基础数据类型的原子操作支持，能够有效避免竞争条件，提升并发性能。\n一、什么是 atomic\u0026lt;T\u0026gt;？ atomic\u0026lt;T\u0026gt; 是 C++11 提供的一个模板类，用于在多线程环境中安全地操作基础数据类型。它通过底层 CPU 提供的指令集，保证了对变量的操作是原子性的，即每个操作要么完整地执行，要么根本不执行，不会因为线程切换导致数据不一致。\n支持的类型 atomic\u0026lt;T\u0026gt; 模板类支持以下类型：\n基础整型（如 int、long、unsigned int） 布尔类型（bool） 指针类型 值得注意的是，atomic\u0026lt;T\u0026gt; 不支持浮点类型和自定义数据类型。\n二、atomic\u0026lt;T\u0026gt; 的常用操作 atomic\u0026lt;T\u0026gt; 提供了一组线程安全的操作，用于读取、修改、比较交换等。其主要操作函数包括：\n构造函数\natomic() noexcept：默认构造函数，初始化一个原子变量。 atomic(T val) noexcept：使用初始值 val 初始化原子变量。 atomic(const atomic\u0026amp;) = delete：禁用拷贝构造函数，防止原子变量被复制。 赋值操作\natomic\u0026amp; operator=(const atomic\u0026amp;) = delete：禁用赋值操作，防止赋值导致的竞争问题。 常用方法\nvoid store(const T val) noexcept：存储一个值 val 到原子变量。 T load() noexcept：读取原子变量的值。 T fetch_add(const T val) noexcept：将原子变量的值与 val 相加，并返回原值。 T fetch_sub(const T val) noexcept：将原子变量的值减去 val，并返回原值。 T exchange(const T val) noexcept：将原子变量的值替换为 val，并返回原值。 bool compare_exchange_strong(T \u0026amp;expect, const T val) noexcept：比较原子变量的值与 expect，如果相等则将其替换为 val，并返回 true；否则将原子变量的值更新为 expect，并返回 false。 性能查询\nbool is_lock_free()：查询某原子类型的操作是否是无锁的。如果返回 true，表示操作由 CPU 原生指令直接支持；如果返回 false，表示编译器使用了内部的锁机制来保证操作的安全性。 三、原子操作示例 以下是一些 atomic\u0026lt;T\u0026gt; 操作的示例，展示了如何在多线程环境中安全地使用原子变量。\n示例 1：基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;atomic\u0026gt; // 引入原子类型头文件 int main() { std::atomic\u0026lt;int\u0026gt; a = 3; // 初始化原子变量 a std::cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a.load() \u0026lt;\u0026lt; std::endl; // 输出当前值：3 a.store(8); // 存储新值 8 std::cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a.load() \u0026lt;\u0026lt; std::endl; // 输出更新后的值：8 int old = a.fetch_add(5); // a 的值加 5，返回原值 std::cout \u0026lt;\u0026lt; \u0026#34;old = \u0026#34; \u0026lt;\u0026lt; old \u0026lt;\u0026lt; \u0026#34;，a = \u0026#34; \u0026lt;\u0026lt; a.load() \u0026lt;\u0026lt; std::endl; // 输出：old = 8，a = 13 old = a.fetch_sub(2); // a 的值减去 2，返回原值 std::cout \u0026lt;\u0026lt; \u0026#34;old = \u0026#34; \u0026lt;\u0026lt; old \u0026lt;\u0026lt; \u0026#34;，a = \u0026#34; \u0026lt;\u0026lt; a.load() \u0026lt;\u0026lt; std::endl; // 输出：old = 13，a = 11 } 示例 2：比较交换（CAS） CAS（Compare-And-Swap）是实现无锁算法的基础操作。它允许我们在读取原子变量时，检查其当前值是否与预期值匹配，如果匹配则进行更新。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;atomic\u0026gt; int main() { std::atomic\u0026lt;int\u0026gt; ii = 3; // 原子变量 int expect = 4; // 预期值 int val = 5; // 新的值 // 比较原子变量 ii 的值与 expect // 如果相等则将其替换为 val bool bret = ii.compare_exchange_strong(expect, val); std::cout \u0026lt;\u0026lt; \u0026#34;bret = \u0026#34; \u0026lt;\u0026lt; bret \u0026lt;\u0026lt; std::endl; // 输出比较结果，false 因为 ii != expect std::cout \u0026lt;\u0026lt; \u0026#34;ii = \u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; std::endl; // 输出原子变量的当前值 std::cout \u0026lt;\u0026lt; \u0026#34;expect = \u0026#34; \u0026lt;\u0026lt; expect \u0026lt;\u0026lt; std::endl; // 输出 expect 被更新为 ii 的值 } 在这个例子中，compare_exchange_strong() 尝试将 ii 的值从 3 更新为 5，但由于 expect 是 4，因此操作失败，ii 保持原值 3，同时 expect 被更新为 ii 的当前值。\n四、使用场景 4.1 计数器 原子整型可以用作计数器，在并发环境下安全地递增或递减。\n1 2 3 4 5 std::atomic\u0026lt;int\u0026gt; counter(0); void increment() { counter.fetch_add(1); // 线程安全的递增操作 } 4.2 布尔开关 原子布尔型可以用作线程间的信号传递，用来实现轻量级的开关机制。\n1 2 3 4 5 6 7 8 std::atomic\u0026lt;bool\u0026gt; flag(false); void worker_thread() { while (!flag.load()) { // 等待 flag 被设置为 true } // 开始执行任务 } 4.3 无锁队列 原子操作是实现无锁数据结构的基础，CAS 指令可以保证数据结构的线程安全性，而无需使用互斥锁。无锁队列广泛应用于高性能、多线程场景中。\n总结 atomic\u0026lt;T\u0026gt; 是 C++11 中为多线程编程提供的重要工具。它利用底层硬件的支持，实现了对基础数据类型的无锁访问和修改操作。在适当的场景下使用原子操作，能够避免锁带来的性能开销，并且能够简化代码逻辑。然而，虽然原子操作可以避免锁的使用，但它们也有自己的局限性。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B/","summary":"在并发环境中，如何保证数据在多个线程之间的同步与一致性是一个关键问题。传统的同步方式使用互斥锁（mutex）来保护共享数据，但锁的使用带来了","title":"CPP中的原子类型"},{"content":"\r在多线程编程中，协调线程间的执行顺序和资源共享是一个重要问题。条件变量（condition_variable）是 C++11 提供的一种线程同步机制，允许线程在某些条件满足时被唤醒或阻塞。它通常用于实现生产者-消费者模型或其他需要线程等待特定事件的场景。\n一、条件变量的基础概念 C++11 提供了两个条件变量类：\ncondition_variable：效率更高的条件变量，适合与普通 mutex 一起使用。 condition_variable_any：通用条件变量，可以与任意 mutex 搭配，包括用户自定义的锁类型。 条件变量的工作原理是，当某个条件不满足时，线程会被阻塞，直到满足条件被唤醒。这在生产者-消费者模型中应用广泛。\n常见成员函数 condition_variable()：默认构造函数，初始化条件变量。 notify_one()：唤醒一个被当前条件变量阻塞的线程。 notify_all()：唤醒所有被条件变量阻塞的线程。 wait(unique_lock\u0026lt;mutex\u0026gt; lock)：阻塞当前线程，直到条件变量被通知。 wait(unique_lock\u0026lt;mutex\u0026gt; lock, Pred pred)：阻塞线程，直到条件变量通知且谓词 pred 返回 true。 wait_for(unique_lock\u0026lt;mutex\u0026gt; lock, 时间长度)：阻塞线程，等待指定的时间长度。 wait_until(unique_lock\u0026lt;mutex\u0026gt; lock, 时间点)：阻塞线程，直到指定的时间点。 记不住吧 @_@，我也记不住，且用且查即可。\n二、unique_lock 类 为了配合条件变量，C++11 引入了 unique_lock 类。它是一个 RAII 风格的锁管理类，与 lock_guard 类似，能简化锁的使用。不同之处在于，unique_lock 允许手动控制加锁和解锁，以便配合条件变量的 wait() 函数。\nunique_lock 常见成员函数 lock()：手动加锁。 unlock()：手动解锁。 release()：释放控制，但不解锁。 三、使用条件变量实现生产者-消费者模型 下面的示例展示了如何使用条件变量、互斥锁和 unique_lock 来实现生产者-消费者模型。\n示例 1：简单的生产者-消费者模型 在这个例子中，生产者线程不断生成数据并将其放入队列，而消费者线程则从队列中取出数据进行处理。条件变量用于通知消费者，当队列中有新数据可用时唤醒被阻塞的消费者线程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; // 线程类头文件 #include \u0026lt;mutex\u0026gt; // 互斥锁类的头文件 #include \u0026lt;deque\u0026gt; // 双端队列容器头文件 #include \u0026lt;queue\u0026gt; // 队列容器头文件 #include \u0026lt;condition_variable\u0026gt; // 条件变量头文件 using namespace std; class AA { mutex m_mutex; // 互斥锁 condition_variable m_cond; // 条件变量 queue\u0026lt;string, deque\u0026lt;string\u0026gt;\u0026gt; m_q; // 队列，使用 deque 作为底层容器 public: // 生产数据，参数 num 指定生产的数量 void incache(int num) { lock_guard\u0026lt;mutex\u0026gt; lock(m_mutex); // 自动加锁 for (int ii = 0; ii \u0026lt; num; ++ii) { static int bh = 1; // 数据编号 string message = to_string(bh++) + \u0026#34;号超女\u0026#34;; // 生成数据 m_q.push(message); // 将数据放入队列 } m_cond.notify_one(); // 唤醒一个等待的消费者线程 } // 消费者任务函数 void outcache() { while (true) { string message; { unique_lock\u0026lt;mutex\u0026gt; lock(m_mutex); // 手动控制加锁 // 使用循环判断队列是否为空，防止虚假唤醒 while (m_q.empty()) { m_cond.wait(lock); // 等待生产者通知 } message = m_q.front(); // 获取队列中的数据 m_q.pop(); // 移除已消费的数据 } // 模拟处理数据 this_thread::sleep_for(chrono::milliseconds(1)); // 处理1毫秒 cout \u0026lt;\u0026lt; \u0026#34;线程：\u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;，处理数据：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } } }; int main() { AA aa; // 创建三个消费者线程 thread t1(\u0026amp;AA::outcache, \u0026amp;aa); thread t2(\u0026amp;AA::outcache, \u0026amp;aa); thread t3(\u0026amp;AA::outcache, \u0026amp;aa); this_thread::sleep_for(chrono::seconds(2)); // 休眠2秒，模拟生产者等待 aa.incache(3); // 生产3个数据 this_thread::sleep_for(chrono::seconds(3)); // 再次休眠3秒 aa.incache(5); // 生产5个数据 t1.join(); // 等待线程完成 t2.join(); t3.join(); } 代码解析 生产者线程：通过 incache() 函数向队列中添加数据。每次生产数据后，调用 notify_one() 唤醒一个等待的消费者线程。 消费者线程：通过 outcache() 函数从队列中获取数据。消费者在没有数据时使用 condition_variable 的 wait() 阻塞，直到生产者生产数据并发出通知。 示例 2：唤醒所有消费者线程 在有多个消费者线程时，生产者可以使用 notify_all() 函数来唤醒所有被阻塞的消费者线程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;condition_variable\u0026gt; using namespace std; class AA { mutex m_mutex; // 互斥锁 condition_variable m_cond; // 条件变量 queue\u0026lt;string, deque\u0026lt;string\u0026gt;\u0026gt; m_q; // 队列 public: // 生产数据 void incache(int num) { lock_guard\u0026lt;mutex\u0026gt; lock(m_mutex); // 加锁 for (int ii = 0; ii \u0026lt; num; ++ii) { static int bh = 1; // 数据编号 string message = to_string(bh++) + \u0026#34;号超女\u0026#34;; m_q.push(message); } m_cond.notify_all(); // 唤醒所有被阻塞的线程 } // 消费者任务函数 void outcache() { while (true) { unique_lock\u0026lt;mutex\u0026gt; lock(m_mutex); // 手动加锁 // 使用 lambda 表达式替代循环等待，避免虚假唤醒 m_cond.wait(lock, [this] { return !m_q.empty(); }); // 获取并移除数据 string message = m_q.front(); m_q.pop(); cout \u0026lt;\u0026lt; \u0026#34;线程：\u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;，处理数据：\u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; lock.unlock(); // 手动解锁 // 模拟处理数据 this_thread::sleep_for(chrono::milliseconds(1)); } } }; int main() { AA aa; thread t1(\u0026amp;AA::outcache, \u0026amp;aa); thread t2(\u0026amp;AA::outcache, \u0026amp;aa); thread t3(\u0026amp;AA::outcache, \u0026amp;aa); this_thread::sleep_for(chrono::seconds(2)); // 休眠2秒 aa.incache(2); // 生产2个数据 this_thread::sleep_for(chrono::seconds(3)); // 再次休眠3秒 aa.incache(5); // 生产5个数据 t1.join(); t2.join(); t3.join(); } 代码解析 在这个例子中，生产者通过 notify_all() 唤醒所有被阻塞的消费者线程。消费者线程在被唤醒后，通过条件变量等待数据。m_cond.wait(lock, [this] { return !m_q.empty(); }) 确保只有在队列中有数据时，线程才会被唤醒并继续执行。\n总结 C++11 的条件变量为线程同步提供了非常灵活和高效的方式。在多线程编程中，条件变量可以很好地协调生产者和消费者之间的关系，防止数据竞争和死锁。通过 condition_variable、unique_lock 和 lock_guard 的组合，开发者可以更方便地编写高效、线程安全的代码。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/","summary":"在多线程编程中，协调线程间的执行顺序和资源共享是一个重要问题。条件变量（condition_variable）是 C++11 提供的一种线程同步机制，允","title":"条件变量"},{"content":"\r很久之前，我就相关内容写了一篇博客。今日，重读相关内容，还是觉得自己要就相关内容，再写一篇。不为别的，权当加深印象之用吧。C++11 提供了标准化的多线程支持，其中包含四种不同类型的互斥锁，用于保护共享资源并确保线程安全。这次，我将详细介绍 C++11 提供的四种互斥锁及其使用场景，并附上相关代码示例。\nC++11 提供的四种互斥锁 mutex：标准互斥锁，用于控制对共享资源的独占访问。 timed_mutex：带超时机制的互斥锁，支持在指定时间内尝试加锁。 recursive_mutex：递归互斥锁，允许同一线程多次锁定资源，防止递归函数加锁时发生死锁。 recursive_timed_mutex：带超时机制的递归互斥锁，结合了递归锁和超时机制。 1 2 #include \u0026lt;mutex\u0026gt; // 包含互斥锁类的头文件 #include \u0026lt;thread\u0026gt; // 包含线程类的头文件 一、mutex 类 —— 标准互斥锁 1.1 lock() —— 加锁操作 lock() 函数用于申请互斥锁，线程会尝试获取锁的所有权。如果锁已经被另一个线程持有，则当前线程会阻塞，直到锁可用。\n1.2 unlock() —— 解锁操作 unlock() 函数用于释放锁的所有权，其他等待锁的线程可以继续获取该锁。\n1.3 try_lock() —— 尝试加锁 try_lock() 函数不阻塞，立即尝试获取锁。如果锁是空闲的，则成功加锁并返回 true；如果锁已经被其他线程持有，则返回 false。\n示例代码：使用 mutex 保护共享资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; // 互斥锁类的头文件 using namespace std; mutex mtx; // 创建互斥锁，保护共享资源 cout 对象 // 普通函数，模拟多线程环境下的资源访问 void func(int bh, const string\u0026amp; str) { for (int ii = 1; ii \u0026lt;= 10; ii++) { mtx.lock(); // 加锁，保护共享资源 cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; \u0026#34;次表白：亲爱的\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;号，\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; mtx.unlock(); // 解锁，释放共享资源 this_thread::sleep_for(chrono::seconds(1)); // 休眠 1 秒 } } int main() { // 创建多个线程，每个线程访问共享资源 cout thread t1(func, 1, \u0026#34;我是一只傻傻鸟。\u0026#34;); thread t2(func, 2, \u0026#34;我是一只傻傻鸟。\u0026#34;); thread t3(func, 3, \u0026#34;我是一只傻傻鸟。\u0026#34;); thread t4(func, 4, \u0026#34;我是一只傻傻鸟。\u0026#34;); thread t5(func, 5, \u0026#34;我是一只傻傻鸟。\u0026#34;); // 等待所有线程完成 t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); } 代码解析 在这个例子中，多个线程同时访问共享的 cout 对象输出信息。为了防止多个线程同时访问共享资源而造成数据竞争，使用了 mtx.lock() 加锁和 mtx.unlock() 解锁来保护 cout。\n二、timed_mutex 类 —— 带超时机制的互斥锁 timed_mutex 提供了 try_lock_for() 和 try_lock_until() 两个函数，允许线程在指定的时间段内尝试获取锁。如果超过指定时间锁依然被其他线程持有，则加锁失败。\ntry_lock_for(时间长度)：尝试在指定时间长度内获取锁。 try_lock_until(时间点)：尝试在指定时间点之前获取锁。 示例代码：使用 timed_mutex 超时加锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; timed_mutex tmtx; // 创建带超时机制的互斥锁 void func(int bh, const string\u0026amp; str) { for (int ii = 1; ii \u0026lt;= 5; ii++) { if (tmtx.try_lock_for(chrono::milliseconds(100))) { // 尝试加锁，最多等待 100 毫秒 cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; \u0026#34;次表白：亲爱的\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;号，\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; tmtx.unlock(); // 解锁 } else { cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; \u0026#34;次尝试加锁失败，线程\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;放弃了操作。\u0026#34; \u0026lt;\u0026lt; endl; } this_thread::sleep_for(chrono::milliseconds(150)); // 休眠 150 毫秒 } } int main() { thread t1(func, 1, \u0026#34;我是一只傻傻鸟。\u0026#34;); thread t2(func, 2, \u0026#34;我有一只小小鸟。\u0026#34;); t1.join(); t2.join(); } 代码解析 在此示例中，每个线程尝试使用 timed_mutex 加锁。如果在 100 毫秒内加锁成功，线程会输出信息；如果锁定失败，线程会跳过此次操作，继续执行下一轮。\n三、recursive_mutex 类 —— 递归互斥锁 recursive_mutex 允许同一线程多次获取锁，这在递归函数中非常有用。如果不使用递归互斥锁，同一个线程多次加锁会导致死锁。对于这个递归互斥锁，就我目前的技术水平，我觉得其应用频率不高。\n示例代码：递归互斥锁的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; using namespace std; class AA { recursive_mutex rmtx; // 创建递归互斥锁 public: void func1() { rmtx.lock(); cout \u0026lt;\u0026lt; \u0026#34;调用了 func1()\\n\u0026#34;; rmtx.unlock(); } void func2() { rmtx.lock(); cout \u0026lt;\u0026lt; \u0026#34;调用了 func2()\\n\u0026#34;; func1(); // 在 func2 内部调用 func1 rmtx.unlock(); } }; int main() { AA aa; aa.func2(); // 调用 func2，它会递归调用 func1 } 代码解析 递归互斥锁允许同一线程在不解锁的情况下多次加锁，这对递归调用非常有用。在这个例子中，func2() 调用了 func1()，但两者都使用了相同的递归互斥锁，因此不会导致死锁。\n四、lock_guard 类 —— RAII 风格的加锁管理 lock_guard 是一个模板类，它采用 RAII（资源获取即初始化）思想来简化互斥锁的使用。当 lock_guard 对象被创建时，它自动加锁；当 lock_guard 对象超出作用域时，它会自动解锁，这避免了手动加锁/解锁带来的潜在错误。\n示例代码：使用 lock_guard 简化加锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; using namespace std; mutex mtx; // 创建互斥锁 void func(int bh, const string\u0026amp; str) { for (int ii = 1; ii \u0026lt;= 5; ii++) { lock_guard\u0026lt;mutex\u0026gt; lg(mtx); // 自动加锁，在作用域结束时自动解锁 cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; \u0026#34;次表白：亲爱的\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;号，\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::seconds(1)); // 休眠 1 秒 } } int main() { thread t1(func, 1, \u0026#34;我是一只傻傻鸟。\u0026#34;); thread t2(func, 2, \u0026#34;我有一只小小鸟。\u0026#34;); t1.join(); t2.join(); } 代码解析 在这个示例中，lock_guard 自动处理互斥锁的加锁和解锁，确保每次加锁操作都能被正确管理，从而避免手动解锁时可能出现的错误。\n总结 C++11 提供的四种互斥锁为多线程编程提供了强大的支持。通过使用 mutex、timed_mutex、recursive_mutex 和 lock_guard，开发者能够在多线程环境下有效保护共享资源，防止数据竞争。同时，lock_guard 的 RAII 机制大大简化了锁的使用，减少了手动加锁和解锁的错误风险。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%86%8D%E6%8E%A2cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81/","summary":"很久之前，我就相关内容写了一篇博客。今日，重读相关内容，还是觉得自己要就相关内容，再写一篇。不为别的，权当加深印象之用吧。C++11 提供了标","title":"再探CPP中的互斥锁"},{"content":"\r在多线程编程中，经常会遇到这样的需求：某些函数或操作只能被调用一次，特别是在初始化某些全局或共享资源时。C++11 提供了一个简洁的解决方案：std::call_once()，它能够保证在多线程环境中某个函数仅被执行一次，而不会引发竞争条件（Race Condition）。\n一、为什么需要 std::call_once()？ 在多线程环境中，如果多个线程试图同时初始化某些共享资源，会引发不确定的行为。例如，两个线程可能同时执行初始化逻辑，导致资源被初始化多次，进而引发逻辑错误。为了避免这种情况，我们需要确保初始化逻辑只会被执行一次。传统的加锁机制（如 std::mutex）虽然可以解决这个问题，但它的效率较低，且可能导致线程频繁阻塞。\n为了解决这个问题，C++11 引入了 std::call_once()，它结合了 std::once_flag，能够高效地确保某个函数在多线程环境下只被调用一次。相比于传统的加锁机制，std::call_once() 更轻量，也更适合这种单次初始化的场景。\n二、 std::call_once() 的用法 std::call_once() 是一个模板函数，其原型如下：\n1 2 template\u0026lt; class Callable, class... Args \u0026gt; void call_once( std::once_flag\u0026amp; flag, Callable\u0026amp;\u0026amp; fn, Args\u0026amp;\u0026amp;... args ); flag 是一个 std::once_flag 对象，用于记录某个操作是否已经执行过。 fn 是需要执行的函数或可调用对象（可以是普通函数、lambda、函数对象等）。 args 是传递给 fn 的参数。 当 std::call_once() 被调用时，它会检查 std::once_flag 的状态。如果 flag 的状态表明函数从未执行过，则 fn 会被执行，之后 flag 会被设置为 \u0026ldquo;已执行\u0026rdquo;。即使多个线程同时调用 std::call_once()，也只有一个线程会真正执行 fn。\n三、示例：多线程中的 std::call_once() 下面的例子演示了如何使用 std::call_once() 来保证某个函数只被执行一次。\n示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; // 包含 std::thread。 #include \u0026lt;mutex\u0026gt; // 包含 std::once_flag 和 std::call_once。 #include \u0026lt;chrono\u0026gt; // 包含 std::chrono::seconds。 using namespace std; // 定义 once_flag 对象，用于标记某个操作是否已经执行。 once_flag onceflag; // 打算只被执行一次的函数。 void once_func(const int bh, const string\u0026amp; str) { cout \u0026lt;\u0026lt; \u0026#34;once_func() bh = \u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;, str = \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } // 模拟多个线程执行的函数。 void func(int bh, const string\u0026amp; str) { // 确保 once_func 只被执行一次。 call_once(onceflag, once_func, 0, \u0026#34;各位观众，我要开始表白了。\u0026#34;); // 模拟多次表白的操作。 for (int ii = 1; ii \u0026lt;= 3; ii++) { cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; \u0026#34;次表白：亲爱的\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;号，\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::seconds(1)); // 休眠1秒。 } } int main() { // 创建两个线程，模拟多个线程并发执行。 thread t1(func, 3, \u0026#34;我是一只傻傻鸟。\u0026#34;); thread t2(func, 8, \u0026#34;我有一只小小鸟。\u0026#34;); // 等待线程结束。 t1.join(); t2.join(); } 输出： 1 2 3 4 5 6 7 once_func() bh = 0, str = 各位观众，我要开始表白了。 第1次表白：亲爱的3号，我是一只傻傻鸟。 第1次表白：亲爱的8号，我有一只小小鸟。 第2次表白：亲爱的3号，我是一只傻傻鸟。 第2次表白：亲爱的8号，我有一只小小鸟。 第3次表白：亲爱的3号，我是一只傻傻鸟。 第3次表白：亲爱的8号，我有一只小小鸟。 四、代码解析 once_flag 的使用： 在代码中，我们声明了一个全局变量 onceflag，它用于标记某个操作（即 once_func()）是否已经被执行过。这个对象是 std::call_once() 保证函数只被执行一次的核心。\nstd::call_once()： 在每个线程的执行函数 func() 中，调用了 std::call_once(onceflag, once_func, ...)，其中 onceflag 是用于标记的 once_flag 对象，而 once_func 是需要保证只执行一次的函数。即使有多个线程并发调用 std::call_once()，只有一个线程会真正执行 once_func()，其他线程会跳过该函数的执行。\n线程并发执行： 两个线程 t1 和 t2 被创建并执行，分别调用 func() 函数。尽管两个线程都调用了 std::call_once()，但我们可以看到，once_func() 只被执行了一次。\n确保资源的正确回收： 使用 t1.join() 和 t2.join() 来等待线程完成并确保资源正确回收。\n五、 std::call_once() 的应用场景 std::call_once() 最常见的应用场景是线程安全的单例模式（Singleton Pattern）。在单例模式中，我们希望某个对象只被初始化一次，无论有多少个线程试图访问它。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Singleton { private: static Singleton* instance; static once_flag flag; Singleton() { cout \u0026lt;\u0026lt; \u0026#34;Singleton 构造函数执行\u0026#34; \u0026lt;\u0026lt; endl; } public: static Singleton* getInstance() { call_once(flag, []() { instance = new Singleton(); }); return instance; } }; Singleton* Singleton::instance = nullptr; once_flag Singleton::flag; 在这个例子中，Singleton::getInstance() 使用 std::call_once() 来确保 Singleton 对象只被初始化一次，即使有多个线程同时调用 getInstance()。\n六、总结 std::call_once() 提供了一种高效、安全的方法来保证某个函数在多线程环境下只被执行一次。它结合 std::once_flag，避免了传统锁机制带来的性能开销，简化了代码结构，同时大大提高了并发编程中的安全性。\n无论是在实现单例模式、初始化全局资源，还是处理某些仅需执行一次的操作时，std::call_once() 都是一个非常值得推荐的工具。\n","permalink":"https://oheyu.github.io/zh/posts/tech/call_once%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E6%AC%A1%E6%89%A7%E8%A1%8C/","summary":"在多线程编程中，经常会遇到这样的需求：某些函数或操作只能被调用一次，特别是在初始化某些全局或共享资源时。C++11 提供了一个简洁的解决方案：","title":"Call_once实现线程安全的单次执行"},{"content":"\r在 C++11 中，为了更好地支持并发编程，标准库提供了命名空间 std::this_thread，它专门用于表示当前线程，并提供了一些常用的与线程管理相关的工具和功能。通过这些工具，我们可以更灵活地控制线程的执行顺序、获取当前线程的 ID、休眠线程等操作。\n一、this_thread::get_id() —— 获取当前线程的 ID 函数原型： 1 std::thread::id get_id() noexcept; 该函数用于获取调用它的线程的 ID。在多线程环境中，线程 ID 是非常有用的调试工具，可以帮助开发者标识各个线程的身份。C++11 中，std::thread 类也提供了类似的 get_id() 方法，用于获取某个线程对象的 ID。\n示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std; void func() { cout \u0026lt;\u0026lt; \u0026#34;子线程 ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; } int main() { thread t1(func); cout \u0026lt;\u0026lt; \u0026#34;主线程 ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; t1.join(); // 回收线程资源 } 输出： 1 2 主线程 ID: 140710877099776 子线程 ID: 140710869462784 二、this_thread::sleep_for() —— 线程休眠指定时间 函数原型： 1 2 template \u0026lt;class Rep, class Period\u0026gt; void sleep_for (const chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; rel_time); this_thread::sleep_for() 函数让当前线程休眠指定的一段时间，参数是 chrono::duration 类型。它是一个跨平台的休眠函数，和操作系统提供的 Sleep() 或 sleep() 不同，sleep_for() 提供了更强的跨平台兼容性。\n示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; void func() { for (int i = 1; i \u0026lt;= 3; i++) { cout \u0026lt;\u0026lt; \u0026#34;子线程休眠 \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; 秒...\u0026#34; \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::seconds(1)); } } int main() { thread t1(func); t1.join(); } 输出： 1 2 3 子线程休眠 1 秒... 子线程休眠 2 秒... 子线程休眠 3 秒... 3. this_thread::sleep_until() —— 线程休眠至指定时间 函数原型： 1 2 template \u0026lt;class Clock, class Duration\u0026gt; void sleep_until (const chrono::time_point\u0026lt;Clock,Duration\u0026gt;\u0026amp; abs_time); this_thread::sleep_until() 是一个非常强大的函数，它可以让线程休眠直到某个特定的时间点。这在实现定时任务、调度任务时特别有用。\n示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; int main() { auto now = chrono::system_clock::now(); auto future_time = now + chrono::seconds(5); cout \u0026lt;\u0026lt; \u0026#34;主线程将在 5 秒后继续执行...\u0026#34; \u0026lt;\u0026lt; endl; this_thread::sleep_until(future_time); cout \u0026lt;\u0026lt; \u0026#34;主线程恢复执行。\u0026#34; \u0026lt;\u0026lt; endl; } 输出： 1 2 主线程将在 5 秒后继续执行... 主线程恢复执行。 四、this_thread::yield() —— 让出当前线程的 CPU 时间片 函数原型： 1 void yield() noexcept; this_thread::yield() 函数允许当前线程主动让出其正在使用的 CPU 时间片，以便让其他线程有机会运行。它常用于优化多线程应用中的 CPU 资源分配，避免线程忙等待（busy waiting）。\n示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; void func() { for (int i = 0; i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;子线程执行中，主动让出 CPU...\u0026#34; \u0026lt;\u0026lt; endl; this_thread::yield(); } } int main() { thread t1(func); t1.join(); } 输出： 1 2 3 子线程执行中，主动让出 CPU... 子线程执行中，主动让出 CPU... 子线程执行中，主动让出 CPU... 五、线程类中的其他常用成员函数 5.1 std::thread::swap() swap() 函数用于交换两个线程对象的内部数据和状态。这在某些情况下用于优化线程管理，特别是需要转移线程资源所有权时。\n示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std; void task1() { cout \u0026lt;\u0026lt; \u0026#34;任务1\u0026#34; \u0026lt;\u0026lt; endl; } void task2() { cout \u0026lt;\u0026lt; \u0026#34;任务2\u0026#34; \u0026lt;\u0026lt; endl; } int main() { thread t1(task1); thread t2(task2); t1.swap(t2); // 交换两个线程的任务 t1.join(); t2.join(); } 5.2 std::thread::hardware_concurrency() hardware_concurrency() 返回系统中可供使用的硬件线程数量，这个值表示系统支持的并发执行线程数（通常对应 CPU 核心数）。它只是一个近似值，具体表现与硬件和操作系统有关。\n示例： 1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std; int main() { unsigned int cores = thread::hardware_concurrency(); cout \u0026lt;\u0026lt; \u0026#34;系统支持的并发线程数量: \u0026#34; \u0026lt;\u0026lt; cores \u0026lt;\u0026lt; endl; } 输出： 1 系统支持的并发线程数量: 8 六、综合示例：使用 this_thread 和线程管理函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; void func(int bh, const string\u0026amp; str) { cout \u0026lt;\u0026lt; \u0026#34;子线程：\u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;次表白：亲爱的\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;号，\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::seconds(1)); // 休眠 1 秒 } } int main() { // 创建两个线程执行任务 thread t1(func, 3, \u0026#34;我是一只傻傻鸟。\u0026#34;); thread t2(func, 8, \u0026#34;我有一只小小鸟。\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;主线程：\u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;线程 t1：\u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;线程 t2：\u0026#34; \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; endl; t1.join(); // 等待 t1 完成 t2.join(); // 等待 t2 完成 cout \u0026lt;\u0026lt; \u0026#34;所有线程执行完毕。\u0026#34; \u0026lt;\u0026lt; endl; } 输出： 1 2 3 4 5 6 7 8 9 主线程：140705598822144 线程 t1：140705590429440 线程 t2：140705582036736 子线程：140705590429440 第1次表白：亲爱的3号，我是一只傻傻鸟。 子线程：140705582036736 第1次表白：亲爱的8号，我有一只小小鸟。 ... 所有线程执行完毕。 ","permalink":"https://oheyu.github.io/zh/posts/tech/this_thread/","summary":"在 C++11 中，为了更好地支持并发编程，标准库提供了命名空间 std::this_thread，它专门用于表示当前线程，并提供了一些常用的与线程管理相","title":"This_thread"},{"content":"\r在 C++ 中，线程的使用为我们带来了多任务并发执行的能力，但与此同时，如何管理和回收线程资源也是一个不可忽视的问题。虽然一个进程的所有线程共享同一进程的栈空间，但每个线程拥有自己独立的栈，用来保存其局部变量及函数调用的上下文。因此，在子线程运行完毕后，必须显式或隐式地回收其占用的资源，否则会导致资源泄露。\n一、线程的资源回收方法 C++11 引入了 std::thread 类，并提供了两种主要的方式来管理线程结束后的资源回收：join() 和 detach()。选择哪种方式取决于应用场景以及我们对线程结束时行为的预期。\n1.1 join() 方法 join() 是一种 同步 方法，用于主线程等待子线程的执行结束。当调用 join() 时，主线程会阻塞，直到指定的子线程结束，随后回收该子线程的资源。如果子线程已提前结束，join() 会立即返回。\n优点：\n保证了主线程和子线程之间的同步执行顺序，主线程可以等待子线程的任务完成。 可以确保回收已结束的子线程资源。 缺点：\n如果子线程执行时间较长，主线程会被阻塞，影响主程序的效率。 1.2 detach() 方法 detach() 是一种 异步 方法，它将子线程与主线程分离，意味着子线程将自行运行，主线程不会等待子线程的完成。在调用 detach() 后，子线程独立运行，主线程不再管理它的状态。当子线程完成后，系统会自动回收其资源，分离后的子线程无法再被 join()。\n优点：\n主线程不会阻塞，可以继续执行其他任务。 子线程自动管理自己的生命周期，不需要主线程再干预。 缺点：\n主线程无法确保子线程任务的完成，分离的子线程可能在主线程结束时仍未完成工作。 1.3 joinable() 方法 在 std::thread 中，还提供了 joinable() 方法，用于判断当前线程是否可被 join()。当线程已经被 detach() 或已经被 join() 后，joinable() 返回 false，否则返回 true。\n二、使用 join() 和 detach() 的代码示例 下面的代码展示了如何使用 join() 和 detach() 方法管理线程资源的回收：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; // 线程类头文件。 #include \u0026lt;unistd.h\u0026gt; using namespace std; // 定义一个普通函数作为线程的任务函数。 void func(int bh, const string\u0026amp; str) { for (int ii = 1; ii \u0026lt;= 10; ii++) { cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; \u0026#34;次表白：亲爱的\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;号，\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; sleep(1); // 模拟工作负载，休眠 1 秒。 } } int main() { // 创建两个线程来执行普通函数 func。 thread t1(func, 3, \u0026#34;我是一只傻傻鸟。\u0026#34;); thread t2(func, 8, \u0026#34;我有一只小小鸟。\u0026#34;); // 分离子线程，主线程不再管理它们的状态。 t1.detach(); t2.detach(); // 让主线程睡眠 12 秒，以确保子线程有足够的时间完成任务。 // 否则主线程提前结束，子线程会被强制终止。 sleep(12); // 由于线程已经被分离，无法再调用 join()。 // t1.join(); // 错误：分离后的线程无法再 join // t2.join(); // 错误：分离后的线程无法再 join return 0; } 2.1 join() 示例 如果我们需要确保主线程等待子线程执行完毕后再继续执行主线程任务，我们可以使用 join() 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;unistd.h\u0026gt; using namespace std; void func(int bh, const string\u0026amp; str) { for (int ii = 1; ii \u0026lt;= 10; ii++) { cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; \u0026#34;次表白：亲爱的\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;号，\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; Sleep(1); // 模拟工作负载，休眠 1 秒。 } } int main() { // 创建两个线程执行任务 thread t1(func, 3, \u0026#34;我是一只傻傻鸟。\u0026#34;); thread t2(func, 8, \u0026#34;我有一只小小鸟。\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;等待子线程完成...\\n\u0026#34;; // 使用 join 等待子线程执行完毕 t1.join(); t2.join(); cout \u0026lt;\u0026lt; \u0026#34;所有子线程完成，主线程结束。\\n\u0026#34;; return 0; } 在这个例子中，t1.join() 和 t2.join() 会确保主线程阻塞等待两个子线程结束，然后主线程才会继续执行后续代码。适合需要主线程依赖子线程任务结果的场景。\n3. 何时使用 join() 和 detach() 3.1 使用 join() 当子线程的任务必须在主线程结束之前完成时使用，例如主线程依赖于子线程的结果或资源。 当子线程的任务需要与主线程进行同步时，例如主线程需要等待子线程完成某些工作后再继续。 3.2 使用 detach() 当子线程的任务可以独立运行，不需要主线程干预时使用。 当希望主线程不等待子线程完成，并且让系统自动回收子线程资源时使用。 适合后台执行的任务，如日志写入、定时任务等不需要主线程等待的情况。 四、总结 在 C++11 中，join() 和 detach() 是两种处理线程资源回收的主要方法：\njoin() 确保主线程等待子线程结束，用于需要同步的场景； detach() 分离子线程，使其与主线程无关，适合无需等待的异步场景。 此外，通过 joinable() 方法可以判断线程是否处于可 join() 的状态。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%9B%9E%E6%94%B6/","summary":"在 C++ 中，线程的使用为我们带来了多任务并发执行的能力，但与此同时，如何管理和回收线程资源也是一个不可忽视的问题。虽然一个进程的所有线程共享同一","title":"线程资源的回收"},{"content":"\r在 C++11 之前，C++ 没有原生的线程支持，开发者需要依赖于操作系统提供的线程库，不同平台的实现各不相同，这导致了跨平台开发的复杂性。C++11 引入了标准线程库，使线程的创建和管理变得更加统一、易用且跨平台。\n一、线程的创建 在 C++11 中，可以通过 std::thread 类创建线程。std::thread 类提供了几种不同的构造方式，用于灵活地创建线程并执行任务。以下是几种常见的线程创建方法：\n1.1 头文件与基本概念 使用线程需要包含头文件：\n1 #include \u0026lt;thread\u0026gt; 线程的基本构造函数如下：\n默认构造函数：thread() noexcept 创建一个空线程对象，不执行任何任务，也不创建子线程。\n带参数的构造函数：\n1 2 template\u0026lt; class Function, class... Args \u0026gt; explicit thread(Function\u0026amp;\u0026amp; fx, Args\u0026amp;\u0026amp;... args); 这个构造函数用于创建线程并启动任务。fx 是任务函数，args 是传递给任务函数的参数。fx 可以是普通函数、lambda 表达式、类成员函数等。\n1.2 创建线程的注意事项 不可复制：std::thread 不支持复制，线程对象之间不能拷贝。 任务结束后自动终止：线程的任务函数执行完毕后，线程将自动终止。 主线程退出影响子线程：如果主线程退出，所有尚未完成的子线程会被强行终止。因此在实际编程中，通常需要通过 join() 或 detach() 处理子线程的资源。 二、使用不同方式创建线程的示例 2.1 使用普通函数创建线程 普通函数是最常见的线程任务类型。在下面的例子中，func 是一个普通函数，接收两个参数并通过 std::thread 创建多个线程来执行它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;unistd.h\u0026gt; void func(int bh, const std::string\u0026amp; str) { for (int ii = 1; ii \u0026lt;= 10; ii++) { std::cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; \u0026#34;次表白：亲爱的\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;号，\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; Sleep(1); // 模拟工作负载，休眠1秒 } } int main() { std::thread t1(func, 3, \u0026#34;我是一只傻傻鸟。\u0026#34;); // 创建线程 t1，执行 func std::thread t2(func, 8, \u0026#34;我有一只小小鸟。\u0026#34;); // 创建线程 t2，执行 func t1.join(); // 主线程等待 t1 结束 t2.join(); // 主线程等待 t2 结束 return 0; } 2.2 使用 lambda 表达式创建线程 C++11 提供了 lambda 表达式的支持，简化了函数对象的创建。以下是使用 lambda 表达式创建线程的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { auto f = [](int bh, const std::string\u0026amp; str) { for (int ii = 1; ii \u0026lt;= 10; ii++) { std::cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; \u0026#34;次表白：亲爱的\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;号，\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; Sleep(1); // 模拟工作负载，休眠1秒 } }; std::thread t3(f, 3, \u0026#34;我是一只傻傻鸟。\u0026#34;); // 使用 lambda 表达式创建线程 t3.join(); // 主线程等待 t3 结束 return 0; } 2.3 使用仿函数（Functor）创建线程 仿函数是通过重载 operator() 实现的类，可以像普通函数一样调用。以下是通过仿函数创建线程的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;unistd.h\u0026gt; class MyThread { public: void operator()(int bh, const std::string\u0026amp; str) { for (int ii = 1; ii \u0026lt;= 10; ii++) { std::cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; \u0026#34;次表白：亲爱的\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;号，\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; Sleep(1); // 模拟工作负载，休眠1秒 } } }; int main() { std::thread t4(MyThread(), 3, \u0026#34;我是一只傻傻鸟。\u0026#34;); // 创建线程并使用仿函数执行任务 t4.join(); // 主线程等待 t4 结束 return 0; } 2.4 使用类的静态成员函数创建线程 静态成员函数不依赖于具体的对象，因此可以直接使用类名调用。以下是通过静态成员函数创建线程的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;unistd.h\u0026gt; class MyThread { public: static void func(int bh, const std::string\u0026amp; str) { for (int ii = 1; ii \u0026lt;= 10; ii++) { std::cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; \u0026#34;次表白：亲爱的\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;号，\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; Sleep(1); // 模拟工作负载，休眠1秒 } } }; int main() { std::thread t5(MyThread::func, 3, \u0026#34;我是一只傻傻鸟。\u0026#34;); // 使用静态成员函数创建线程 t5.join(); // 主线程等待 t5 结束 return 0; } 2.5 使用类的非静态成员函数创建线程 非静态成员函数与特定的对象实例关联，调用时需要传递对象指针。以下是通过非静态成员函数创建线程的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;unistd.h\u0026gt; class MyThread { public: void func(int bh, const std::string\u0026amp; str) { for (int ii = 1; ii \u0026lt;= 10; ii++) { std::cout \u0026lt;\u0026lt; \u0026#34;第\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; \u0026#34;次表白：亲爱的\u0026#34; \u0026lt;\u0026lt; bh \u0026lt;\u0026lt; \u0026#34;号，\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; Sleep(1); // 模拟工作负载，休眠1秒 } } }; int main() { MyThread obj; // 创建类的对象 std::thread t6(\u0026amp;MyThread::func, \u0026amp;obj, 3, \u0026#34;我是一只傻傻鸟。\u0026#34;); // 创建线程，并绑定对象成员函数 t6.join(); // 主线程等待 t6 结束 return 0; } 三、总结 C++11 通过 std::thread 类为多线程编程提供了跨平台、统一的接口。开发者可以使用普通函数、lambda 表达式、仿函数、类的静态和非静态成员函数来创建线程。每种方式都有其使用场景和优势，开发者应根据实际需求选择合适的线程创建方法。\n注意事项：\nstd::thread 不支持复制，只能通过移动操作来转移资源。 在使用非静态成员函数时，需要传递类对象的指针，确保对象的生命周期比线程长。 join() 用于阻塞主线程，等待子线程结束；detach() 可以使子线程与主线程分离，独立运行。 ","permalink":"https://oheyu.github.io/zh/posts/tech/cpp11%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81/","summary":"在 C++11 之前，C++ 没有原生的线程支持，开发者需要依赖于操作系统提供的线程库，不同平台的实现各不相同，这导致了跨平台开发的复杂性。C++11 引入","title":"CPP11中的线程支持"},{"content":"\rmemcpy() 函数是 C 标准库中用于内存操作的一个重要函数，它被广泛用于在内存中复制数据块。在系统编程和低级数据操作中，memcpy() 是一个常用且高效的工具。\nmemcpy() 函数的概述 memcpy() 函数用于将指定数量的字节从一个内存位置复制到另一个内存位置。它的操作是直接的、低级的，不会进行任何数据类型的转换或优化。在 string.h 头文件中，memcpy() 的定义如下：\n1 2 3 #include \u0026lt;string.h\u0026gt; void *memcpy(void *dest, const void *src, size_t n); 其中，对于参数而言：\ndest：目标内存地址的指针，表示数据的复制去向。 src：源内存地址的指针，表示数据的复制来源。 n：要复制的字节数。 对于返回值，该函数返回一个通用指针，该指针指向 dest。\n理解 void*。\nvoid* 是一种通用指针（generic pointer）。不同于空指针 NULL 表示一个不指向任何有效内存的特殊指针值，void* 指针可以指向内存中的某个位置，但其指向的数据类型是未确定的（通用的）。\n也正是因为 void* 指针不包含类型信息，所以它是类型不安全的。这意味着我们在使用 void* 时，必须确保正确的将其转换为合适的类型。此外，void* 指针也不能进行指针算术运算（如递增、递减），因为它不包含类型信息，编译器不知道要增加（减少）多少字节。最后，void* 指针也不能被直接解引用，必须将其转换为特定类型的指针。\n为什么 memcpy() 的返回值 void* 指向目标内存地址？\n函数链式调用的便利性：char *copied_data = memcpy(buffer, source, size);，在这条语句中，memcpy() 返回的指针可以直接被用于 copied_data，不需要额外的变量或操作。\nmemcpy() 函数的使用示例 以下是一个使用 memcpy() 函数将一个数组的数据复制到另一个数组的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char src[] = \u0026#34;Hello, World!\u0026#34;; char dest[20]; // 使用 memcpy 函数复制数据 memcpy(dest, src, strlen(src) + 1); // +1 是为了包括字符串的终止符 \u0026#39;\\0\u0026#39; printf(\u0026#34;Source: %s\\n\u0026#34;, src); printf(\u0026#34;Destination: %s\\n\u0026#34;, dest); return 0; } 在这个示例中：\n我们定义了一个源数组 src，其中包含字符串 \u0026quot;Hello, World!\u0026quot;。 我们定义了一个目标数组 dest，大小足以容纳源数组的内容。 我们使用 memcpy() 函数将 src 数组的内容复制到 dest 数组。 复制操作包括了字符串的终止符 '\\0'，以确保目标数组中的字符串正确终止。 memcpy() 函数的工作原理 memcpy() 函数的工作原理是直接在内存级别复制字节数据。它不进行任何类型检查或优化，而是逐字节地将数据从源地址复制到目标地址。\n逐字节复制：\nmemcpy() 从源地址 src 开始，逐字节地读取数据，并将这些数据写入到目标地址 dest。 复制的字节数由参数 n 指定。 指针操作：\n源地址和目标地址通过指针传递，因此函数能够直接操作内存地址。 复制操作是按照内存地址的顺序进行的，从 src 开始依次向后复制 n 个字节到 dest。 不处理重叠：\nmemcpy() 假设源和目标内存区域不会重叠。 如果源和目标区域重叠，memcpy() 的行为未定义，可能会导致数据损坏。在这种情况下，应该使用 memmove() 函数。 memcpy() 函数的使用注意事项 内存重叠问题：\nmemcpy() 假设源和目标区域不重叠。如果内存区域重叠，可能会导致数据复制的过程出现问题，数据可能会被覆盖或损坏。 如果你需要在重叠的内存区域之间复制数据，应该使用 memmove()，它能够正确处理重叠区域。 目标内存大小：\n确保目标内存区域 dest 足够大，能够容纳复制的数据。如果目标内存区域不够大，可能会导致内存越界，造成未定义行为或程序崩溃。 类型不匹配：\nmemcpy() 直接复制字节数据，不关心数据的类型。因此，目标和源数据类型不匹配时，需要小心，确保数据类型和大小一致。 速度与效率：\nmemcpy() 是一个低级别的、直接的内存操作函数，通常比逐个元素复制数据更快，但它不进行任何优化。 在处理大块数据时，memcpy() 通常比手动逐字节复制更高效。 memcpy() 函数与其他内存操作函数的比较 memmove() 函数：\nmemmove() 函数类似于 memcpy() 函数，但它能够正确处理源和目标内存区域重叠的情况。 memmove() 在内部处理重叠区域的数据，确保数据不会在复制过程中被覆盖。 strcpy() 函数：\nstrcpy() 函数专用于复制以 \\0 结尾的字符串。 memcpy() 函数可以复制任意类型的内存数据，而不仅仅是字符串。 memset() 函数：\nmemset() 用于将内存区域中的所有字节设置为指定的值。 memcpy() 用于从一个内存区域复制数据到另一个内存区域。 memcpy() 函数的常见应用场景 数据复制：\nmemcpy() 常用于在内存中复制数据块，例如从一个数组复制到另一个数组。 在网络编程中，memcpy() 可以用于将数据包复制到缓冲区。 结构体复制：\n可以用于将一个结构体的数据复制到另一个相同类型的结构体中。例如，复制一个结构体数组的元素到另一个结构体数组。 内存初始化：\n使用 memcpy() 将初始化数据块复制到目标内存区域，以快速设置内存的初始状态。例如，初始化缓冲区或缓存数据。 文件处理：\n在文件 I/O 操作中，memcpy() 可以用于将文件内容读入到内存缓冲区，或将缓冲区的数据写入到文件。 memcpy() 函数的使用代码示例 以下是使用 memcpy() 函数复制结构体数据的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef struct { int id; char name[20]; float salary; } Employee; int main() { Employee emp1 = {1, \u0026#34;John Doe\u0026#34;, 50000.0}; Employee emp2; // 使用 memcpy 复制结构体数据 memcpy(\u0026amp;emp2, \u0026amp;emp1, sizeof(Employee)); printf(\u0026#34;Employee 2 - ID: %d, Name: %s, Salary: %.2f\\n\u0026#34;, emp2.id, emp2.name, emp2.salary); return 0; } 在这个示例中：\n我们定义了一个 Employee 结构体，并创建了两个 Employee 类型的变量 emp1 和 emp2。 使用 memcpy() 将 emp1 的数据复制到 emp2，包括 id、name 和 salary。 复制后，我们打印 emp2 的数据，验证 memcpy() 的复制效果。 ","permalink":"https://oheyu.github.io/zh/posts/tech/memcpy%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","summary":"memcpy() 函数是 C 标准库中用于内存操作的一个重要函数，它被广泛用于在内存中复制数据块。在系统编程和低级数据操作中，memcpy() 是一个常用且高效的","title":"memcpy()函数详解"},{"content":"\r在网络编程中，IP 地址的转换和表示是一个常见且重要的任务。为了在程序中处理网络地址，需要将人类可读的字符串形式的 IP 地址转换为计算机可处理的二进制形式，反之亦然。inet_pton() 和 inet_ntop() 函数正是用于完成这些转换的强大工具。\n一、inet_pton() 和 inet_ntop() 函数概述 1.1 定义与作用 inet_pton()：将人类可读的 IP 地址（文本形式）转换为网络字节序的二进制形式。 inet_ntop()：将网络字节序的二进制 IP 地址转换为人类可读的文本形式。 1.2 函数原型 1 2 3 4 5 6 7 #include \u0026lt;arpa/inet.h\u0026gt; // inet_pton int inet_pton(int af, const char *src, void *dst); // inet_ntop const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); 二、inet_pton() 函数详解 2.1 参数解析 int af：地址族（Address Family），指定要转换的地址类型。 AF_INET：IPv4 地址。 AF_INET6：IPv6 地址。 const char *src：源地址，指向以 NUL 结尾的字符串，表示要转换的 IP 地址（文本形式）。 void *dst：目标地址，指向一个缓冲区，用于存储转换后的二进制地址。 2.2 返回值 成功：返回 1，表示转换成功。 失败： 返回 0，表示输入的地址不符合指定地址族的格式。 返回 -1，表示发生错误，并设置 errno。 2.3 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main() { const char *ip_str = \u0026#34;192.168.1.1\u0026#34;; struct in_addr ip_addr; if (inet_pton(AF_INET, ip_str, \u0026amp;ip_addr) == 1) { printf(\u0026#34;inet_pton success: %x\\n\u0026#34;, ip_addr.s_addr); } else { fprintf(stderr, \u0026#34;inet_pton failed\\n\u0026#34;); return -1; } return 0; } 三、inet_ntop() 函数详解 3.1 参数解析 int af：地址族，同 inet_pton() 的 af 参数。 const void *src：源地址，指向网络字节序的二进制 IP 地址。 char *dst：目标地址，指向用于存储转换后字符串的缓冲区。 socklen_t size：目标缓冲区的大小（字节数）。 3.2 返回值 成功：返回指向结果字符串的指针，即 dst。 失败：返回 NULL，并设置 errno。 3.3 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main() { struct in_addr ip_addr; ip_addr.s_addr = htonl(0xC0A80101); // 192.168.1.1 in hex char ip_str[INET_ADDRSTRLEN]; if (inet_ntop(AF_INET, \u0026amp;ip_addr, ip_str, sizeof(ip_str)) != NULL) { printf(\u0026#34;inet_ntop success: %s\\n\u0026#34;, ip_str); } else { fprintf(stderr, \u0026#34;inet_ntop failed\\n\u0026#34;); return -1; } return 0; } 四、inet_pton() 和 inet_ntop() 的工作原理 4.1 地址族的支持 IPv4（AF_INET）：\ninet_pton() 将点分十进制的 IPv4 地址转换为 struct in_addr 结构体中的二进制形式。 inet_ntop() 将 struct in_addr 中的二进制地址转换为点分十进制的字符串形式。 IPv6（AF_INET6）：\ninet_pton() 将字符串形式的 IPv6 地址转换为 struct in6_addr 结构体中的二进制形式。 inet_ntop() 将 struct in6_addr 中的二进制地址转换为字符串形式。 4.2 字节序的处理 网络字节序（大端序）：网络传输使用大端序，因此在转换过程中，函数会处理字节序的转换。 主机字节序：在存储和处理 IP 地址时，程序需要考虑主机的字节序。 五、实践中的注意事项 5.1 缓冲区大小 IPv4 地址：使用 INET_ADDRSTRLEN 宏，通常为 16 字节。 IPv6 地址：使用 INET6_ADDRSTRLEN 宏，通常为 46 字节。 建议：在使用 inet_ntop() 时，确保 dst 缓冲区的大小足够大，以避免缓冲区溢出。 5.2 返回值的检查 inet_pton()： 返回 1 才表示成功，0 和 -1 都表示失败，需要区别处理。 inet_ntop()： 返回非 NULL 指针表示成功，NULL 表示失败，需要检查 errno。 5.3 地址格式的正确性 IPv4 地址：必须是合法的点分十进制格式，如 192.168.1.1。 IPv6 地址：支持多种表示形式，如缩略表示，需要确保格式正确。 5.4 兼容性考虑 历史函数：inet_addr()、inet_aton()、inet_ntoa() 是早期用于地址转换的函数，但不支持 IPv6，且线程不安全。 建议：使用 inet_pton() 和 inet_ntop()，以获得更好的兼容性和安全性。 六、易错之处 6.1 忘记检查返回值 问题：未检查函数的返回值，可能导致程序在地址转换失败时继续运行，产生错误。 解决方案：始终检查函数的返回值，根据返回值处理错误情况。 6.2 缓冲区大小不足 问题：inet_ntop() 的目标缓冲区过小，导致字符串截断或缓冲区溢出。 解决方案：使用 INET_ADDRSTRLEN 或 INET6_ADDRSTRLEN 定义的大小，确保缓冲区足够大。 6.3 地址族不匹配 问题：指定的地址族与实际的地址格式不匹配，导致转换失败。 解决方案：确保 af 参数与 IP 地址的版本一致（IPv4 或 IPv6）。 6.4 多线程环境下的安全性 问题：使用线程不安全的函数（如 inet_ntoa()）可能导致数据竞争。 解决方案：使用线程安全的 inet_ntop() 和 inet_pton()。 七、inet_pton() 和 inet_ntop() 的高级用法 7.1 支持多种 IPv6 地址表示 压缩表示：如 2001:db8::1，:: 表示一系列连续的零。 嵌入式 IPv4 地址：如 ::ffff:192.168.1.1，用于 IPv4 映射的 IPv6 地址。 7.2 与套接字地址结构体的结合 struct sockaddr_in（IPv4）：\n1 2 struct sockaddr_in addr; inet_pton(AF_INET, \u0026#34;192.168.1.1\u0026#34;, \u0026amp;(addr.sin_addr)); struct sockaddr_in6（IPv6）：\n1 2 struct sockaddr_in6 addr6; inet_pton(AF_INET6, \u0026#34;2001:db8::1\u0026#34;, \u0026amp;(addr6.sin6_addr)); 7.3 在网络编程中的应用 服务器和客户端的地址设置：使用 inet_pton() 将 IP 地址转换后，设置到套接字地址结构体中，用于 connect()、bind() 等函数。 日志和调试信息：使用 inet_ntop() 将二进制 IP 地址转换为可读的字符串，便于输出和记录。 八、拓展资料：关键概念解释 8.1 网络字节序与主机字节序 网络字节序（Big Endian）：高位字节存在低地址，网络传输使用大端序。 主机字节序：不同的主机可能使用大端序或小端序，需要在网络编程中进行转换。 8.2 IPv4 与 IPv6 IPv4 地址：32 位地址，通常表示为点分十进制，如 192.168.1.1。 IPv6 地址：128 位地址，表示形式多样，支持更大的地址空间。 8.3 地址族（Address Family） AF_INET：表示 IPv4 地址族。 AF_INET6：表示 IPv6 地址族。 PF_INET 与 AF_INET：在某些系统中，PF_INET 和 AF_INET 是等价的，但建议在套接字编程中使用 AF_INET。 8.4 早期的地址转换函数 inet_addr()：将 IPv4 字符串地址转换为网络字节序的 32 位整数，不推荐使用。 inet_aton()：改进的版本，返回值更明确，但仍仅支持 IPv4。 inet_ntoa()：将 IPv4 地址转换为字符串形式，返回静态缓冲区指针，线程不安全。 九、示例代码：IPv4 和 IPv6 地址转换 9.1 IPv4 地址转换示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main() { const char *ip_str = \u0026#34;192.168.1.100\u0026#34;; struct in_addr ip_addr; // 字符串转换为二进制 if (inet_pton(AF_INET, ip_str, \u0026amp;ip_addr) != 1) { perror(\u0026#34;inet_pton\u0026#34;); return -1; } // 二进制转换为字符串 char buffer[INET_ADDRSTRLEN]; if (inet_ntop(AF_INET, \u0026amp;ip_addr, buffer, INET_ADDRSTRLEN) == NULL) { perror(\u0026#34;inet_ntop\u0026#34;); return -1; } printf(\u0026#34;Original IP: %s\\nConverted IP: %s\\n\u0026#34;, ip_str, buffer); return 0; } 9.2 IPv6 地址转换示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main() { const char *ip_str = \u0026#34;2001:0db8::1\u0026#34;; struct in6_addr ip6_addr; // 字符串转换为二进制 if (inet_pton(AF_INET6, ip_str, \u0026amp;ip6_addr) != 1) { perror(\u0026#34;inet_pton\u0026#34;); return -1; } // 二进制转换为字符串 char buffer[INET6_ADDRSTRLEN]; if (inet_ntop(AF_INET6, \u0026amp;ip6_addr, buffer, INET6_ADDRSTRLEN) == NULL) { perror(\u0026#34;inet_ntop\u0026#34;); return -1; } printf(\u0026#34;Original IP: %s\\nConverted IP: %s\\n\u0026#34;, ip_str, buffer); return 0; } ","permalink":"https://oheyu.github.io/zh/posts/tech/inet_pton%E4%B8%8Einet_ntop/","summary":"在网络编程中，IP 地址的转换和表示是一个常见且重要的任务。为了在程序中处理网络地址，需要将人类可读的字符串形式的 IP 地址转换为计算机可处理的二","title":"Inet_pton与inet_ntop"},{"content":"\r一、accept() 函数概述 1.1 定义与作用 accept() 函数用于从监听套接字的已完成连接队列中取出一个已建立的连接，返回一个新的套接字文件描述符，用于与客户端进行通信。在 TCP 服务器编程中，这是处理客户端连接的关键步骤。\n1.2 函数原型 1 2 3 4 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 二、accept() 函数的参数与返回值 2.1 参数解析 sockfd：监听套接字的文件描述符，由 socket() 创建，并经过 bind() 和 listen() 函数设置为监听状态。 addr：可选参数，指向 struct sockaddr 类型的指针，用于存储客户端的地址信息。 addrlen：指向一个 socklen_t 类型的变量，初始值为 addr 所指向的结构体的长度，返回时包含客户端地址的实际长度。 2.2 返回值 成功：返回一个新的套接字文件描述符，用于与客户端通信。 失败：返回 -1，并设置 errno，指示具体的错误原因。 三、accept() 函数的工作原理 3.1 连接队列 在调用 listen() 后，套接字进入被动监听状态，内核为其维护两个队列：\n未完成连接队列：存放已收到客户端的 SYN 请求，但尚未完成三次握手的连接。 已完成连接队列：存放已完成三次握手的连接，等待应用程序调用 accept() 取出处理。 accept() 函数从已完成连接队列中取出一个连接，返回新的套接字描述符。\n3.2 套接字的区别 监听套接字 (sockfd)：用于监听新的连接请求。 已连接套接字：由 accept() 返回，用于与特定客户端通信。 四、accept() 的使用示例 4.1 基本的服务器接收连接示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #define PORT 8080 #define BACKLOG 5 int main() { int listen_fd, conn_fd; struct sockaddr_in server_addr, client_addr; socklen_t client_addrlen = sizeof(client_addr); // 创建套接字 if ((listen_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) { perror(\u0026#34;socket creation failed\u0026#34;); return -1; } // 绑定地址 memset(\u0026amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(PORT); if (bind(listen_fd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) == -1) { perror(\u0026#34;bind failed\u0026#34;); close(listen_fd); return -1; } // 开始监听 if (listen(listen_fd, BACKLOG) == -1) { perror(\u0026#34;listen failed\u0026#34;); close(listen_fd); return -1; } printf(\u0026#34;Server is listening on port %d...\\n\u0026#34;, PORT); // 接受连接 if ((conn_fd = accept(listen_fd, (struct sockaddr *)\u0026amp;client_addr, \u0026amp;client_addrlen)) == -1) { perror(\u0026#34;accept failed\u0026#34;); close(listen_fd); return -1; } printf(\u0026#34;Accepted a connection from %s:%d\\n\u0026#34;, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port)); // 与客户端通信... // 关闭套接字 close(conn_fd); close(listen_fd); return 0; } 五、使用注意事项 5.1 accept() 的阻塞行为 问题：默认情况下，accept() 是阻塞的，如果已完成连接队列为空，accept() 将阻塞，直到有新的连接。 解决方案： 非阻塞模式：将监听套接字设置为非阻塞模式，若无连接则立即返回 -1，并设置 errno 为 EAGAIN 或 EWOULDBLOCK。 I/O 多路复用：使用 select()、poll()、epoll() 等机制，在调用 accept() 之前检测套接字是否可读。 5.2 addr 和 addrlen 参数 可选性：addr 和 addrlen 可以为 NULL，如果不需要获取客户端地址信息。 注意事项：若需要获取客户端信息，必须提供有效的 addr 和 addrlen，并确保 addrlen 指向的变量初始化为 addr 的长度。 5.3 文件描述符的管理 问题：accept() 返回的新套接字描述符需要妥善管理，及时关闭，防止文件描述符耗尽。 解决方案：在通信结束后，调用 close() 关闭已连接套接字。 5.4 多线程和并发处理 场景：在高并发服务器中，需要同时处理多个客户端连接。 解决方案：每次 accept() 后，创建新线程或进程处理连接，或使用事件驱动的方式。 六、常见问题 6.1 忘记检查返回值 问题：未检查 accept() 的返回值，无法及时发现错误。 解决方案：始终检查返回值，处理可能的错误。 6.2 忽略 EINTR 错误 问题：accept() 可能被信号中断，返回 -1，并设置 errno 为 EINTR。 解决方案：在收到 EINTR 错误时，重新调用 accept()。 1 2 3 4 5 6 7 8 while ((conn_fd = accept(listen_fd, (struct sockaddr *)\u0026amp;client_addr, \u0026amp;client_addrlen)) == -1) { if (errno == EINTR) continue; else { perror(\u0026#34;accept failed\u0026#34;); break; } } 6.3 文件描述符耗尽 问题：未及时关闭已连接套接字，导致文件描述符耗尽，无法接受新的连接。 解决方案：妥善管理套接字的生命周期，及时关闭不再使用的套接字。 6.4 拒绝服务攻击的防范 问题：恶意客户端大量连接服务器，导致资源耗尽。 解决方案： 限制每个客户端的连接数。 实现连接超时机制，关闭长时间未活动的连接。 使用防火墙和入侵检测系统。 七、accept() 函数的高级用法 7.1 使用 accept4() 函数 简介：accept4() 是 Linux 特有的系统调用，功能类似于 accept()，但增加了一个 flags 参数。 函数原型： 1 2 3 #include \u0026lt;sys/socket.h\u0026gt; int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags); 优势： 可以在接受连接的同时设置新套接字的属性，如非阻塞模式 (O_NONBLOCK)。 减少系统调用次数，提高性能。 7.2 非阻塞 accept() 方法：将监听套接字设置为非阻塞模式，或使用 accept4() 设置 O_NONBLOCK 标志。 应用场景：在事件驱动的服务器中，避免阻塞在 accept() 调用上。 7.3 获取客户端的更多信息 方法：使用 getpeername() 获取已连接套接字对端的地址信息。 示例： 1 2 3 4 5 6 7 struct sockaddr_in peer_addr; socklen_t peer_len = sizeof(peer_addr); if (getpeername(conn_fd, (struct sockaddr *)\u0026amp;peer_addr, \u0026amp;peer_len) == 0) { printf(\u0026#34;Connected to %s:%d\\n\u0026#34;, inet_ntoa(peer_addr.sin_addr), ntohs(peer_addr.sin_port)); } 八、拓展资料：关键概念解释 8.1 阻塞与非阻塞模式 阻塞模式：默认情况下，accept() 会阻塞，直到有新的连接或发生错误。 非阻塞模式：accept() 立即返回，若无连接，则返回 -1，并设置 errno 为 EAGAIN 或 EWOULDBLOCK。 设置方法：使用 fcntl() 函数设置套接字为非阻塞模式。 1 2 3 4 #include \u0026lt;fcntl.h\u0026gt; int flags = fcntl(listen_fd, F_GETFL, 0); fcntl(listen_fd, F_SETFL, flags | O_NONBLOCK); 8.2 I/O 多路复用 概念：使用单个线程或进程监控多个文件描述符，提高资源利用率。 常用机制：select()、poll()、epoll()。 应用场景：高并发服务器，避免为每个连接创建线程或进程。 8.3 accept() 与多线程 问题：在多线程服务器中，多个线程同时调用 accept() 可能导致竞争。 解决方案： 使用同步机制，如互斥锁，确保只有一个线程调用 accept()。 或者将监听套接字设置为非阻塞模式，结合事件驱动模型。 8.4 SO_REUSEADDR 与 SO_REUSEPORT SO_REUSEADDR：允许绑定已在使用的地址，常用于服务器重启时快速重新绑定端口。 SO_REUSEPORT：允许多个套接字绑定到同一 IP 和端口，常用于多线程或多进程服务器。 九、示例代码：多线程服务器示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #define PORT 8080 #define BACKLOG 5 void *handle_client(void *arg) { int conn_fd = *(int *)arg; free(arg); char buffer[1024]; ssize_t bytes_read; // 通信处理 while ((bytes_read = recv(conn_fd, buffer, sizeof(buffer), 0)) \u0026gt; 0) { send(conn_fd, buffer, bytes_read, 0); } close(conn_fd); return NULL; } int main() { int listen_fd; struct sockaddr_in server_addr, client_addr; socklen_t client_addrlen = sizeof(client_addr); // 创建套接字 if ((listen_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) { perror(\u0026#34;socket creation failed\u0026#34;); return -1; } // 绑定地址 memset(\u0026amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(PORT); if (bind(listen_fd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) == -1) { perror(\u0026#34;bind failed\u0026#34;); close(listen_fd); return -1; } // 开始监听 if (listen(listen_fd, BACKLOG) == -1) { perror(\u0026#34;listen failed\u0026#34;); close(listen_fd); return -1; } printf(\u0026#34;Server is listening on port %d...\\n\u0026#34;, PORT); // 接受并处理连接 while (1) { int *conn_fd = malloc(sizeof(int)); if ((*conn_fd = accept(listen_fd, (struct sockaddr *)\u0026amp;client_addr, \u0026amp;client_addrlen)) == -1) { perror(\u0026#34;accept failed\u0026#34;); free(conn_fd); continue; } printf(\u0026#34;Accepted a connection from %s:%d\\n\u0026#34;, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port)); pthread_t tid; if (pthread_create(\u0026amp;tid, NULL, handle_client, conn_fd) != 0) { perror(\u0026#34;pthread_create failed\u0026#34;); close(*conn_fd); free(conn_fd); } else { pthread_detach(tid); } } close(listen_fd); return 0; } ","permalink":"https://oheyu.github.io/zh/posts/tech/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84accept%E5%87%BD%E6%95%B0/","summary":"一、accept() 函数概述 1.1 定义与作用 accept() 函数用于从监听套接字的已完成连接队列中取出一个已建立的连接，返回一个新的套接字文件描述符，用于与客","title":"服务端的accept函数"},{"content":"\rlisten() 函数在网络编程中是服务器端建立连接的关键步骤。它将套接字设置为被动监听模式，等待客户端的连接请求。本文将深入剖析 listen() 函数，从其定义、参数、返回值，到工作原理、使用示例和常见问题。\n一、listen() 函数概述 1.1 定义与作用 listen() 函数用于将一个绑定（bind()）了地址和端口的套接字设置为 被动监听模式。这意味着套接字将准备接受客户端的连接请求，是构建服务器程序的重要一步。\n1.2 函数原型 1 2 3 4 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int listen(int sockfd, int backlog); 二、listen() 函数的参数与返回值 2.1 参数解析 sockfd：套接字文件描述符，由 socket() 函数创建并返回，并已通过 bind() 绑定了本地地址和端口。 backlog：未完成连接队列的最大长度，即内核允许在监听套接字上排队的未处理连接的数量。 2.2 返回值 成功：返回 0，表示套接字已成功进入监听状态。 失败：返回 -1，并设置 errno，指示具体的错误原因。 三、listen() 函数的工作原理 3.1 连接队列的概念 在服务器端，TCP 协议使用两个队列来管理连接：\n未完成连接队列：存放已收到客户端的 SYN 请求，但服务器尚未发送 ACK 的连接（半连接）。 已完成连接队列：存放已完成三次握手的连接，等待 accept() 函数处理。 backlog 参数影响的是已完成连接队列的大小。\n3.2 套接字状态的转换 调用 listen() 后，套接字从主动模式（默认）转换为被动模式，准备接受连接请求。此时，套接字可以接收来自客户端的 SYN 包，并按照 TCP 的三次握手流程建立连接。\n四、listen() 的使用示例 4.1 服务器端监听示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #define PORT 8080 #define BACKLOG 5 int main() { int server_fd; struct sockaddr_in address; int opt = 1; int addrlen = sizeof(address); // 创建套接字 if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(\u0026#34;socket failed\u0026#34;); return -1; } // 设置端口重用 if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;opt, sizeof(opt))) { perror(\u0026#34;setsockopt failed\u0026#34;); close(server_fd); return -1; } // 绑定地址 address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); if (bind(server_fd, (struct sockaddr *)\u0026amp;address, sizeof(address)) \u0026lt; 0) { perror(\u0026#34;bind failed\u0026#34;); close(server_fd); return -1; } // 开始监听 if (listen(server_fd, BACKLOG) \u0026lt; 0) { perror(\u0026#34;listen failed\u0026#34;); close(server_fd); return -1; } printf(\u0026#34;Server is listening on port %d\\n\u0026#34;, PORT); // 接受连接（省略 accept() 部分） close(server_fd); return 0; } 五、注意事项 5.1 backlog 参数的影响 含义：backlog 指定了内核为此套接字排队的最大连接数量。 实际效果：不同操作系统对 backlog 的处理可能不同，有的会对其进行限制或调整。 建议：设置合适的 backlog 值，根据服务器的负载能力和预期的并发连接数进行调整。 5.2 套接字的状态检查 问题：调用 listen() 之前，必须确保套接字已成功创建并绑定。 解决方案：在调用 listen() 之前，检查 socket() 和 bind() 的返回值，确保没有错误。 5.3 多次调用 listen() 问题：对同一个套接字多次调用 listen() 会导致错误。 解决方案：listen() 只需调用一次，后续操作由 accept() 处理。 5.4 权限问题 问题：绑定到低于 1024 的端口需要超级用户权限，否则 bind() 会失败，进而无法调用 listen()。 解决方案：以适当的权限运行程序，或选择高于 1024 的端口。 六、常见陷阱 6.1 忘记调用 listen() 问题：创建并绑定套接字后，未调用 listen()，直接调用 accept()，会导致程序阻塞或出错。 解决方案：在服务器程序中，确保在 bind() 之后调用 listen()，然后再调用 accept()。 6.2 backlog 设置过小 问题：backlog 设置过小，可能导致高并发情况下，新的连接请求被拒绝。 解决方案：根据服务器的处理能力，适当增大 backlog 值，避免连接被拒绝。 6.3 未正确处理返回值 问题：未检查 listen() 的返回值，无法及时发现监听失败的问题。 解决方案：始终检查 listen() 的返回值，处理可能的错误。 6.4 忽略 errno 的信息 问题：在 listen() 失败时，未使用 errno 提供的错误信息，导致调试困难。 解决方案：在错误处理时，使用 perror() 或 strerror(errno) 获取详细的错误描述。 七、listen() 函数的高级用法 7.1 调整系统限制 问题：操作系统可能对半连接队列和已完成连接队列的大小有上限。 解决方案：通过调整系统参数，增大连接队列的最大值。 7.1.1 Linux 系统参数调整 /proc/sys/net/core/somaxconn：定义了监听队列的最大长度，默认值通常为 128。 修改方法： 1 echo 1024 \u0026gt; /proc/sys/net/core/somaxconn 或修改 /etc/sysctl.conf，添加：\n1 net.core.somaxconn = 1024 然后执行 sysctl -p 使配置生效。\n7.2 高并发服务器的优化 方法：结合 epoll、kqueue 等 I/O 多路复用机制，提升服务器的并发处理能力。 示例：使用 accept4() 函数，可以在接受连接时直接设置套接字为非阻塞模式，减少系统调用次数。 八、拓展资料：关键概念解释 8.1 TCP 三次握手 定义：TCP 协议中，建立连接需要经过的三个步骤，确保双方建立可靠的连接。 步骤： SYN：客户端发送 SYN 包，请求建立连接。 SYN-ACK：服务器收到后，回复 SYN-ACK 包，表示同意连接。 ACK：客户端收到 SYN-ACK 后，发送 ACK 包，连接建立成功。 8.2 半连接队列与全连接队列 半连接队列：存放已收到 SYN 包，但未完成三次握手的连接请求。 全连接队列：存放已完成三次握手，等待 accept() 处理的连接。 8.3 accept() 函数 作用：从已完成连接队列中取出一个已建立的连接，返回新的套接字文件描述符，用于与客户端进行通信。 注意：accept() 会阻塞，直到有新的连接可用，或设置为非阻塞模式。 8.4 I/O 多路复用 概念：使用单个线程或进程监控多个文件描述符的状态，提高资源利用率。 常用机制：select()、poll()、epoll()、kqueue() 等。 应用场景：高并发网络服务器，实时性要求高的应用。 九、示例代码：完整的服务器程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #define PORT 8080 #define BACKLOG 10 int main() { int server_fd, new_socket; struct sockaddr_in address; int opt = 1; int addrlen = sizeof(address); // 忽略 SIGPIPE 信号，防止因为客户端断开连接导致程序终止 signal(SIGPIPE, SIG_IGN); // 创建套接字 if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(\u0026#34;socket failed\u0026#34;); return -1; } // 设置端口重用 if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;opt, sizeof(opt))) { perror(\u0026#34;setsockopt failed\u0026#34;); close(server_fd); return -1; } // 绑定地址 address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); if (bind(server_fd, (struct sockaddr *)\u0026amp;address, sizeof(address)) \u0026lt; 0) { perror(\u0026#34;bind failed\u0026#34;); close(server_fd); return -1; } // 开始监听 if (listen(server_fd, BACKLOG) \u0026lt; 0) { perror(\u0026#34;listen failed\u0026#34;); close(server_fd); return -1; } printf(\u0026#34;Server is listening on port %d\\n\u0026#34;, PORT); // 接受连接 while (1) { new_socket = accept(server_fd, (struct sockaddr *)\u0026amp;address, (socklen_t *)\u0026amp;addrlen); if (new_socket \u0026lt; 0) { perror(\u0026#34;accept failed\u0026#34;); continue; } printf(\u0026#34;Accepted a connection from %s:%d\\n\u0026#34;, inet_ntoa(address.sin_addr), ntohs(address.sin_port)); // 简单地向客户端发送一条消息 const char *message = \u0026#34;Hello, Client!\\n\u0026#34;; send(new_socket, message, strlen(message), 0); // 关闭与客户端的连接 close(new_socket); } close(server_fd); return 0; } ","permalink":"https://oheyu.github.io/zh/posts/tech/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84listen%E5%87%BD%E6%95%B0/","summary":"listen() 函数在网络编程中是服务器端建立连接的关键步骤。它将套接字设置为被动监听模式，等待客户端的连接请求。本文将深入剖析 listen() 函数，从其定义、参数、返","title":"服务端的listen函数"},{"content":"\r一、bind() 函数概述 1.1 定义与作用 bind() 函数用于将一个套接字绑定到一个特定的 本地地址 和 端口号。在服务器程序中，这是一个必不可少的步骤，确保服务器在指定的地址和端口上监听客户端的连接请求。\n1.2 函数原型 1 2 3 4 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 二、bind() 函数的参数与返回值 2.1 参数解析 sockfd：套接字文件描述符，由 socket() 函数创建并返回，表示需要绑定的套接字。 addr：指向 struct sockaddr 类型的指针，包含要绑定的本地地址和端口信息。 addrlen：addr 结构体的长度（字节数），可以使用 sizeof(struct sockaddr_in) 获取。 2.2 返回值 成功：返回 0，表示绑定成功。 失败：返回 -1，并设置 errno，指示具体的错误原因。 三、bind() 函数的工作原理 3.1 套接字与地址的关联 在创建套接字后，默认情况下并未指定使用哪个本地地址和端口。通过 bind() 函数，可以明确地指定这些信息，使套接字在特定的网络接口和端口上进行通信。\n3.2 服务器端的必要步骤 对于服务器程序，bind() 是必要的，因为服务器需要在一个 固定的地址和端口 上监听客户端的连接请求，方便客户端找到并连接到服务器。\n3.3 客户端的特殊情况 在客户端程序中，通常不需要调用 bind()，因为操作系统会自动分配一个临时的本地端口和地址。然而，在需要指定特定的本地端口或进行多播、广播时，客户端也可能需要使用 bind()。\n四、bind() 的使用示例 4.1 服务器端绑定示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main() { int sockfd; struct sockaddr_in server_addr; // 创建套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { perror(\u0026#34;socket creation failed\u0026#34;); return -1; } // 初始化服务器地址结构体 memset(\u0026amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; // IPv4 server_addr.sin_addr.s_addr = INADDR_ANY; // 监听所有本地地址 server_addr.sin_port = htons(8080); // 绑定端口 8080 // 绑定地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) \u0026lt; 0) { perror(\u0026#34;bind failed\u0026#34;); close(sockfd); return -1; } printf(\u0026#34;Bind successful. Server is ready to accept connections.\\n\u0026#34;); // 后续的 listen() 和 accept() 操作... close(sockfd); return 0; } 4.2 客户端绑定特定端口示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main() { int sockfd; struct sockaddr_in local_addr; // 创建套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { perror(\u0026#34;socket creation failed\u0026#34;); return -1; } // 初始化本地地址结构体 memset(\u0026amp;local_addr, 0, sizeof(local_addr)); local_addr.sin_family = AF_INET; // IPv4 local_addr.sin_addr.s_addr = INADDR_ANY; // 使用任意本地地址 local_addr.sin_port = htons(50000); // 绑定本地端口 50000 // 绑定本地地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026amp;local_addr, sizeof(local_addr)) \u0026lt; 0) { perror(\u0026#34;bind failed\u0026#34;); close(sockfd); return -1; } // 连接服务器的操作... close(sockfd); return 0; } 五、注意事项 5.1 地址结构体的正确设置 sin_family：必须设置为 AF_INET（IPv4）或 AF_INET6（IPv6），与套接字的地址族一致。 sin_port：端口号需要使用 htons() 函数转换为网络字节序。 sin_addr：本地 IP 地址，可以使用 INADDR_ANY 监听所有可用接口。 5.2 端口重用 问题：当服务器程序意外退出后，端口可能被占用一段时间（TIME_WAIT 状态），导致重新绑定失败。 解决方案：设置套接字选项 SO_REUSEADDR，允许端口快速重用。 1 2 3 4 5 6 int opt = 1; if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;opt, sizeof(opt)) \u0026lt; 0) { perror(\u0026#34;setsockopt failed\u0026#34;); close(sockfd); return -1; } 5.3 权限问题 问题：绑定 0-1023 范围内的端口（系统保留端口）需要有超级用户权限。 解决方案：避免在非特权程序中使用系统保留端口，或以适当的权限运行程序。 5.4 地址已在使用 现象：调用 bind() 时，出现 EADDRINUSE 错误，表示地址已被占用。 原因：端口被其他程序占用，或未正确关闭的套接字仍在使用该端口。 解决方案：确保端口未被占用，或使用 SO_REUSEADDR 选项。 六、疑难杂症 6.1 忘记将端口号转换为网络字节序 问题：如果未使用 htons() 转换端口号，可能导致绑定到错误的端口。 解决方案：始终使用 htons() 将主机字节序的端口号转换为网络字节序。 1 server_addr.sin_port = htons(8080); 6.2 地址族不匹配 问题：sin_family 设置错误，导致 bind() 失败。 解决方案：确保 sin_family 与套接字的地址族一致。 6.3 未正确处理返回值 问题：未检查 bind() 的返回值，无法及时发现绑定失败的问题。 解决方案：始终检查 bind() 的返回值，处理可能的错误。 6.4 忽略 errno 的信息 问题：在 bind() 失败时，未使用 errno 提供的错误信息，导致调试困难。 解决方案：在错误处理时，使用 perror() 或 strerror(errno) 获取详细的错误描述。 七、bind() 函数的更多用法（稍微介绍一下啦） 7.1 绑定到特定的网络接口 场景：服务器有多个网络接口（多块网卡），需要在特定的接口上监听。 实现：将 sin_addr.s_addr 设置为指定接口的 IP 地址。 1 inet_pton(AF_INET, \u0026#34;192.168.1.100\u0026#34;, \u0026amp;server_addr.sin_addr); 7.2 IPv6 的支持 注意：使用 struct sockaddr_in6 和 AF_INET6，设置 IPv6 地址。 1 2 3 4 5 6 7 8 struct sockaddr_in6 server_addr6; memset(\u0026amp;server_addr6, 0, sizeof(server_addr6)); server_addr6.sin6_family = AF_INET6; inet_pton(AF_INET6, \u0026#34;::1\u0026#34;, \u0026amp;server_addr6.sin6_addr); // 绑定到本地 IPv6 地址 server_addr6.sin6_port = htons(8080); // 绑定操作 bind(sockfd, (struct sockaddr *)\u0026amp;server_addr6, sizeof(server_addr6)); 7.3 多播和广播 多播：用于发送数据到一组订阅的主机，需要使用 bind() 来加入多播组。 广播：需要设置套接字选项 SO_BROADCAST，并在 bind() 时指定广播地址。 八、拓展资料：关键概念解释 8.1 套接字地址结构体 8.1.1 struct sockaddr 定义：通用的套接字地址结构体，适用于多种协议族。 1 2 3 4 struct sockaddr { sa_family_t sa_family; // 地址族 char sa_data[14]; // 地址数据 }; 8.1.2 struct sockaddr_in 定义：用于 IPv4 地址的套接字地址结构体。 1 2 3 4 5 6 struct sockaddr_in { sa_family_t sin_family; // 地址族（AF_INET） in_port_t sin_port; // 端口号（网络字节序） struct in_addr sin_addr; // IPv4 地址（网络字节序） unsigned char sin_zero[8];// 填充字节 }; 8.2 网络字节序与主机字节序 字节序： 大端序（Big Endian）：高位字节存储在低地址。 小端序（Little Endian）：低位字节存储在低地址。 网络字节序：TCP/IP 协议规定使用大端序，称为网络字节序。 转换函数： htons()：主机字节序到网络字节序（16 位）。 htonl()：主机字节序到网络字节序（32 位）。 ntohs()、ntohl()：网络字节序到主机字节序。 8.3 端口号 范围： 系统保留端口：0-1023，需要超级用户权限。 用户端口：1024-49151，可供一般程序使用。 动态/私有端口：49152-65535，通常由系统动态分配。 作用：用于标识主机上的特定进程或服务。 8.4 INADDR_ANY 与 INADDR_LOOPBACK INADDR_ANY：表示监听所有可用的本地地址。通常用于服务器程序，值为 0.0.0.0。 INADDR_LOOPBACK：表示本地主机地址，值为 127.0.0.1。 九、示例代码：完整的服务器程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #define PORT 8080 int main() { int server_fd; struct sockaddr_in address; int opt = 1; int addrlen = sizeof(address); // 创建套接字 if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(\u0026#34;socket failed\u0026#34;); return -1; } // 设置端口重用 if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;opt, sizeof(opt))) { perror(\u0026#34;setsockopt failed\u0026#34;); close(server_fd); return -1; } // 绑定地址 address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); if (bind(server_fd, (struct sockaddr *)\u0026amp;address, sizeof(address)) \u0026lt; 0) { perror(\u0026#34;bind failed\u0026#34;); close(server_fd); return -1; } printf(\u0026#34;Server is listening on port %d\\n\u0026#34;, PORT); // 开始监听 if (listen(server_fd, 3) \u0026lt; 0) { perror(\u0026#34;listen failed\u0026#34;); close(server_fd); return -1; } // 接受连接 int new_socket; if ((new_socket = accept(server_fd, (struct sockaddr *)\u0026amp;address, (socklen_t *)\u0026amp;addrlen)) \u0026lt; 0) { perror(\u0026#34;accept failed\u0026#34;); close(server_fd); return -1; } // 处理客户端连接... close(new_socket); close(server_fd); return 0; } ","permalink":"https://oheyu.github.io/zh/posts/tech/bind%E5%87%BD%E6%95%B0/","summary":"一、bind() 函数概述 1.1 定义与作用 bind() 函数用于将一个套接字绑定到一个特定的 本地地址 和 端口号。在服务器程序中，这是一个必不可少的步骤，确保服务","title":"Bind函数"},{"content":"\rrecv() 函数是从已连接的套接字接收数据的主要方式。\n一、recv() 函数概述 1.1 定义与作用 recv() 函数用于从已连接的套接字中接收数据，主要用于 面向连接的套接字（如 TCP）。它提供了比 read() 更丰富的功能，可以通过参数指定接收行为。\n1.2 函数原型 1 2 3 4 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; ssize_t recv(int sockfd, void *buf, size_t len, int flags); 二、recv() 函数的参数与返回值 2.1 参数解析 sockfd：套接字文件描述符，由 socket() 函数创建并返回，表示通信的端点。 buf：指向用于存放接收数据的缓冲区的指针。 len：缓冲区的长度（字节数），即最多接收的数据量。 flags：接收选项，控制接收行为。常用的标志包括： 0：默认，无特殊选项。 MSG_DONTWAIT：非阻塞接收。 MSG_PEEK：查看数据，但不从缓冲区中移除。 MSG_WAITALL：等待接收到指定的字节数，除非发生错误或连接关闭。 2.2 返回值 成功：返回实际接收的字节数。 返回 0：表示连接已关闭。 失败：返回 -1，并设置 errno，指示具体的错误原因。 三、recv() 函数的工作原理 3.1 数据接收过程 内核空间到用户空间：recv() 从内核接收缓冲区中读取数据，复制到用户提供的缓冲区中。 接收缓冲区管理：如果没有数据可读，recv() 会阻塞（阻塞模式）或返回错误（非阻塞模式）。 协议处理：对于 TCP，内核协议栈会处理数据的重组、顺序等，提供可靠的数据流。 3.2 阻塞与非阻塞行为 阻塞模式：当没有数据可读时，recv() 会阻塞，直到有数据到达或发生错误。 非阻塞模式：recv() 立即返回，若没有数据，则返回 -1，并设置 errno 为 EAGAIN 或 EWOULDBLOCK。 3.3 与 read() 的区别 功能：recv() 提供了 flags 参数，可控制接收行为；read() 没有此功能。 适用范围：recv() 专用于套接字通信；read() 可用于文件、管道等。 四、recv() 的使用示例 4.1 基本数据接收 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int receive_data(int sockfd) { char buffer[1024]; ssize_t received_bytes = recv(sockfd, buffer, sizeof(buffer), 0); if (received_bytes \u0026lt; 0) { perror(\u0026#34;recv failed\u0026#34;); return -1; } else if (received_bytes == 0) { printf(\u0026#34;Connection closed by peer.\\n\u0026#34;); return 0; } else { // 处理接收到的数据 buffer[received_bytes] = \u0026#39;\\0\u0026#39;; // 确保字符串以空字符结尾 printf(\u0026#34;Received %zd bytes: %s\\n\u0026#34;, received_bytes, buffer); } return received_bytes; } 4.2 使用 MSG_PEEK 查看数据 1 2 3 ssize_t peek_data(int sockfd, void *buf, size_t len) { return recv(sockfd, buf, len, MSG_PEEK); } 4.3 使用 MSG_WAITALL 接收指定长度的数据 1 2 3 ssize_t receive_exact(int sockfd, void *buf, size_t len) { return recv(sockfd, buf, len, MSG_WAITALL); } 五、注意事项 5.1 处理返回值 返回值为 0：表示对方关闭了连接，应当关闭本地的套接字。 返回值为 -1：需要根据 errno 判断错误类型，可能是暂时性错误或致命错误。 5.2 非阻塞模式下的处理 问题：在非阻塞套接字上，recv() 可能返回 -1，并设置 errno 为 EAGAIN 或 EWOULDBLOCK。 解决方案：在程序中处理这种情况，采用异步或事件驱动方式，等待数据可用。 5.3 数据边界与粘包问题 现象：TCP 是流式协议，没有消息边界，可能会出现粘包或拆包。 解决方案：设计应用层协议，添加消息长度或特殊分隔符，确保数据正确解析。 5.4 SIGPIPE 信号 问题：一般在发送数据时才会触发 SIGPIPE 信号，但在某些异常情况下，recv() 也可能受到影响。 建议：在接收数据时，也要注意处理异常和错误，避免程序崩溃。 六、疑难杂症 6.1 忘记处理部分接收 问题：假设每次调用 recv() 都能接收到完整的数据，可能导致数据不完整或解析错误。 解决方案：实现循环接收，直到满足特定条件，如接收到特定的字节数或检测到消息结束标志。 6.2 不检查连接关闭 问题：未检查 recv() 返回值为 0 的情况，可能导致死循环或逻辑错误。 解决方案：在接收数据时，始终检查返回值是否为 0，及时关闭套接字并清理资源。 6.3 数据缓冲区溢出 问题：接收的数据超过缓冲区大小，导致缓冲区溢出，造成安全隐患。 解决方案：确保 recv() 的 len 参数不超过缓冲区大小，或使用动态缓冲区。 6.4 未处理 EINTR 错误 问题：recv() 被信号中断，返回 -1 且 errno 为 EINTR，若未处理，可能导致程序异常退出。 解决方案：在收到 EINTR 时，重新调用 recv()。 七、recv() 函数的高级用法 7.1 使用 flags 控制接收行为 MSG_PEEK：查看数据，但不从接收缓冲区中移除，可用于检测数据。 MSG_DONTWAIT：非阻塞接收，即使套接字未设置为非阻塞模式。 MSG_WAITALL：等待接收到指定的字节数，除非发生错误或连接关闭。 7.2 实现超时接收 方法：使用 select()、poll() 或 epoll() 等 I/O 多路复用机制，设置超时时间，等待套接字变为可读。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;sys/select.h\u0026gt; int recv_with_timeout(int sockfd, void *buf, size_t len, int timeout_sec) { fd_set readfds; struct timeval tv; FD_ZERO(\u0026amp;readfds); FD_SET(sockfd, \u0026amp;readfds); tv.tv_sec = timeout_sec; tv.tv_usec = 0; int ret = select(sockfd + 1, \u0026amp;readfds, NULL, NULL, \u0026amp;tv); if (ret \u0026gt; 0) { // 套接字可读 return recv(sockfd, buf, len, 0); } else if (ret == 0) { // 超时 fprintf(stderr, \u0026#34;recv timeout\\n\u0026#34;); return -2; } else { // 错误 perror(\u0026#34;select failed\u0026#34;); return -1; } } 7.3 接收带外数据 概念：TCP 提供带外数据（Out-of-band data）的机制，用于发送紧急数据。 使用：在接收带外数据时，可以使用 MSG_OOB 标志。 1 2 3 ssize_t recv_oob_data(int sockfd, void *buf, size_t len) { return recv(sockfd, buf, len, MSG_OOB); } 八、拓展资料：关键概念解释 8.1 粘包与拆包问题 现象：在 TCP 通信中，由于其面向字节流的特性，发送的多条消息可能粘连在一起，或一条消息被拆分成多次接收。 原因：TCP 不保证每次发送的数据与接收的数据一一对应，数据的分段和组包由 TCP 协议栈决定。 解决方案： 定长消息：约定固定的消息长度。 消息头：在消息前添加长度字段，指示消息的总长度。 特殊分隔符：使用特定的字符或字符串标记消息的结束。 8.2 阻塞与非阻塞模式 阻塞模式：默认模式，I/O 操作会阻塞，直到完成或发生错误。\n非阻塞模式：I/O 操作立即返回，若无法完成，则返回错误。\n设置非阻塞模式：\n1 2 3 #include \u0026lt;fcntl.h\u0026gt; int flags = fcntl(sockfd, F_GETFL, 0); fcntl(sockfd, F_SETFL, flags | O_NONBLOCK); 8.3 I/O 多路复用 概念：使用单个线程或进程监控多个文件描述符的状态，提高资源利用率。 常用机制：select()、poll()、epoll()、kqueue() 等。 应用场景：高并发网络服务器，实时性要求高的应用。 8.4 信号中断 EINTR 错误：I/O 操作被信号中断，需在程序中处理此错误。 处理方式：在收到 EINTR 时，重新调用被中断的系统调用。 九、示例代码：完整的服务器接收程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #define SERVER_PORT 8080 int main() { int listenfd, connfd; struct sockaddr_in server_addr, client_addr; socklen_t client_len = sizeof(client_addr); char buffer[1024]; // 忽略 SIGPIPE 信号 signal(SIGPIPE, SIG_IGN); // 创建套接字 listenfd = socket(AF_INET, SOCK_STREAM, 0); if (listenfd \u0026lt; 0) { perror(\u0026#34;socket creation failed\u0026#34;); return -1; } // 设置服务器地址 memset(\u0026amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; // IPv4 server_addr.sin_addr.s_addr = INADDR_ANY; // 监听所有接口 server_addr.sin_port = htons(SERVER_PORT); // 端口 // 绑定地址 if (bind(listenfd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) \u0026lt; 0) { perror(\u0026#34;bind failed\u0026#34;); close(listenfd); return -1; } // 开始监听 if (listen(listenfd, 5) \u0026lt; 0) { perror(\u0026#34;listen failed\u0026#34;); close(listenfd); return -1; } printf(\u0026#34;Server is listening on port %d...\\n\u0026#34;, SERVER_PORT); // 接受连接 connfd = accept(listenfd, (struct sockaddr *)\u0026amp;client_addr, \u0026amp;client_len); if (connfd \u0026lt; 0) { perror(\u0026#34;accept failed\u0026#34;); close(listenfd); return -1; } printf(\u0026#34;Client connected.\\n\u0026#34;); // 接收数据 while (1) { ssize_t received = recv(connfd, buffer, sizeof(buffer) - 1, 0); if (received \u0026lt; 0) { if (errno == EINTR) { continue; // 被信号中断，重新接收 } else { perror(\u0026#34;recv failed\u0026#34;); break; } } else if (received == 0) { printf(\u0026#34;Client disconnected.\\n\u0026#34;); break; } else { buffer[received] = \u0026#39;\\0\u0026#39;; // 确保字符串以空字符结尾 printf(\u0026#34;Received %zd bytes: %s\\n\u0026#34;, received, buffer); // 可以在此处处理数据，或发送响应 } } // 关闭套接字 close(connfd); close(listenfd); return 0; } ","permalink":"https://oheyu.github.io/zh/posts/tech/%E9%82%A3recv%E5%87%BD%E6%95%B0%E5%91%A2/","summary":"recv() 函数是从已连接的套接字接收数据的主要方式。 一、recv() 函数概述 1.1 定义与作用 recv() 函数用于从已连接的套接字中接收数据，主要用于 面向连接的套接","title":"那recv函数呢"},{"content":"\r一、send() 函数概述 1.1 定义与作用 send() 函数用于将数据发送到已建立连接的套接字上，主要用于 面向连接的套接字（如 TCP）。它提供了比 write() 更丰富的功能，可以通过参数指定发送行为。\n1.2 函数原型 1 2 3 4 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; ssize_t send(int sockfd, const void *buf, size_t len, int flags); 二、send() 函数的参数与返回值 2.1 参数解析 sockfd：套接字文件描述符，由 socket() 函数创建并返回，表示通信的端点。 buf：指向要发送的数据缓冲区的指针。 len：要发送的数据长度（字节数）。 flags：发送选项，控制发送行为。常用的标志包括： 0：默认，无特殊选项。 MSG_DONTWAIT：非阻塞发送。 MSG_NOSIGNAL：避免发送 SIGPIPE 信号。 2.2 返回值 成功：返回实际发送的字节数。 失败：返回 -1，并设置 errno，指示具体的错误原因。 三、send() 函数的工作原理 3.1 数据发送过程 用户空间到内核空间：send() 将用户空间的数据复制到内核空间的发送缓冲区。 发送缓冲区管理：如果发送缓冲区已满，send() 会阻塞（阻塞模式）或返回错误（非阻塞模式）。 协议处理：内核协议栈处理数据，根据协议（如 TCP）进行封装和传输。 数据传输：通过网络将数据发送到目标主机。 3.2 阻塞与非阻塞行为 阻塞模式：当发送缓冲区已满时，send() 会阻塞，直到有足够空间。 非阻塞模式：send() 立即返回，若无法发送，则返回 -1，并设置 errno 为 EAGAIN 或 EWOULDBLOCK。 3.3 与 write() 的区别 功能：send() 提供了 flags 参数，可控制发送行为；write() 没有此功能。 适用范围：send() 专用于套接字通信；write() 可用于文件、管道等。 四、send() 的使用示例 4.1 发送字符串数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int send_message(int sockfd, const char *message) { size_t len = strlen(message); ssize_t sent_bytes = send(sockfd, message, len, 0); if (sent_bytes \u0026lt; 0) { perror(\u0026#34;send failed\u0026#34;); return -1; } else if (sent_bytes != len) { fprintf(stderr, \u0026#34;Partial send: %zd bytes sent\\n\u0026#34;, sent_bytes); // 根据需要处理剩余数据 } return 0; } 4.2 处理发送缓冲区满的情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ssize_t send_all(int sockfd, const void *buf, size_t len) { size_t total_sent = 0; const char *ptr = (const char *)buf; while (total_sent \u0026lt; len) { ssize_t sent = send(sockfd, ptr + total_sent, len - total_sent, 0); if (sent \u0026lt;= 0) { if (sent \u0026lt; 0 \u0026amp;\u0026amp; (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)) { // 被信号中断或缓冲区满，继续尝试 continue; } else { // 发生错误 perror(\u0026#34;send failed\u0026#34;); return -1; } } total_sent += sent; } return total_sent; } 五、使用注意事项 5.1 部分发送与循环发送 现象：send() 可能无法一次发送完所有数据，需循环发送。 原因：网络拥塞、发送缓冲区限制等。 解决方案：在发送数据时，使用循环，不断调用 send()，直到所有数据发送完毕。 5.2 信号中断 问题：send() 可能被信号中断（EINTR），需要处理此情况。 解决方案：在收到 EINTR 时，重新调用 send()。 5.3 SIGPIPE 信号 现象：向已关闭的套接字发送数据，会触发 SIGPIPE 信号，默认行为是终止进程。\n解决方案：\n捕获并忽略 SIGPIPE 信号：\n1 2 #include \u0026lt;signal.h\u0026gt; signal(SIGPIPE, SIG_IGN); 使用 MSG_NOSIGNAL 标志：\n1 send(sockfd, buf, len, MSG_NOSIGNAL); 5.4 非阻塞模式处理 问题：在非阻塞套接字上，send() 可能返回 -1，并设置 errno 为 EAGAIN 或 EWOULDBLOCK。 解决方案：在程序中处理这种情况，采用异步或事件驱动方式。 六、常见问题 6.1 忘记检查返回值 问题：未检查 send() 的返回值，无法确定数据是否成功发送。 建议：始终检查返回值，处理可能的错误和部分发送情况。 6.2 缓冲区管理不当 问题：未考虑发送缓冲区的容量，导致程序阻塞或数据丢失。 解决方案：在高并发或大量数据传输时，合理设置发送缓冲区大小，或使用非阻塞模式结合事件通知。 6.3 数据完整性 问题：未处理部分发送，导致数据丢失或不完整。 解决方案：实现循环发送，确保所有数据都被发送。 6.4 数据序列化与协议设计 问题：直接发送复杂数据结构，可能导致数据不一致或兼容性问题。 解决方案：对数据进行序列化，设计良好的通信协议，确保数据的可解析性和兼容性。 七、send() 函数的高级用法 7.1 使用 flags 控制发送行为 MSG_DONTWAIT：非阻塞发送，即使套接字未设置为非阻塞模式。 MSG_OOB：发送带外数据（紧急数据），用于 TCP 套接字的紧急模式。 MSG_EOR：标记数据的结束，用于记录分界。 7.2 发送文件描述符（UNIX 域套接字） 场景：在 UNIX 域套接字中，可以通过 sendmsg() 发送文件描述符，实现进程间共享文件描述符。 实现：构造 msghdr 结构体，使用控制消息（cmsghdr）传递文件描述符。 7.3 高级 I/O 模型的结合 异步 I/O：结合 epoll、kqueue 等机制，实现高性能的网络通信。 零拷贝发送：使用 sendfile() 函数，可以将文件数据直接从内核空间发送，减少数据拷贝，提高效率。 八、拓展资料：关键概念解释 8.1 套接字缓冲区 发送缓冲区：内核为每个套接字维护的缓冲区，用于存储待发送的数据。 接收缓冲区：用于存储接收到但未被应用程序读取的数据。 设置缓冲区大小：可以使用 setsockopt() 函数设置 SO_SNDBUF 和 SO_RCVBUF，调整缓冲区大小。 8.2 阻塞与非阻塞模式 阻塞模式：默认模式，I/O 操作会阻塞，直到完成或发生错误。\n非阻塞模式：I/O 操作立即返回，若无法完成，则返回错误。\n设置非阻塞模式：\n1 2 3 #include \u0026lt;fcntl.h\u0026gt; int flags = fcntl(sockfd, F_GETFL, 0); fcntl(sockfd, F_SETFL, flags | O_NONBLOCK); 8.3 I/O 多路复用 概念：使用单个线程或进程监控多个文件描述符的状态，提高资源利用率。 常用机制：select()、poll()、epoll()、kqueue() 等。 应用场景：高并发网络服务器，实时性要求高的应用。 8.4 信号处理 SIGPIPE 信号：向已关闭的套接字发送数据，会触发此信号。 处理方式： 忽略信号：signal(SIGPIPE, SIG_IGN); 屏蔽信号：使用 sigaction() 函数。 使用 MSG_NOSIGNAL 标志，避免触发信号。 九、示例代码：完整的客户端发送程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #define SERVER_IP \u0026#34;127.0.0.1\u0026#34; #define SERVER_PORT 8080 int main() { int sockfd; struct sockaddr_in server_addr; const char *message = \u0026#34;Hello, Server!\u0026#34;; size_t message_len = strlen(message); // 忽略 SIGPIPE 信号 signal(SIGPIPE, SIG_IGN); // 创建套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { perror(\u0026#34;socket creation failed\u0026#34;); return -1; } // 设置非阻塞模式 int flags = fcntl(sockfd, F_GETFL, 0); fcntl(sockfd, F_SETFL, flags | O_NONBLOCK); // 设置服务器地址 memset(\u0026amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(SERVER_PORT); inet_pton(AF_INET, SERVER_IP, \u0026amp;server_addr.sin_addr); // 连接服务器 if (connect(sockfd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) \u0026lt; 0) { if (errno != EINPROGRESS) { perror(\u0026#34;connect failed\u0026#34;); close(sockfd); return -1; } } // 使用 select 等待连接完成 fd_set wfds; FD_ZERO(\u0026amp;wfds); FD_SET(sockfd, \u0026amp;wfds); struct timeval tv = {5, 0}; // 超时 5 秒 int ret = select(sockfd + 1, NULL, \u0026amp;wfds, NULL, \u0026amp;tv); if (ret \u0026lt;= 0) { fprintf(stderr, \u0026#34;connect timeout or error\\n\u0026#34;); close(sockfd); return -1; } // 检查连接是否成功 int error = 0; socklen_t len = sizeof(error); getsockopt(sockfd, SOL_SOCKET, SO_ERROR, \u0026amp;error, \u0026amp;len); if (error != 0) { fprintf(stderr, \u0026#34;connect failed: %s\\n\u0026#34;, strerror(error)); close(sockfd); return -1; } // 发送数据 ssize_t sent = send(sockfd, message, message_len, MSG_NOSIGNAL); if (sent \u0026lt; 0) { perror(\u0026#34;send failed\u0026#34;); } else { printf(\u0026#34;Sent %zd bytes to server\\n\u0026#34;, sent); } // 关闭套接字 close(sockfd); return 0; } ","permalink":"https://oheyu.github.io/zh/posts/tech/send%E5%8F%91%E9%80%81%E5%87%BD%E6%95%B0/","summary":"一、send() 函数概述 1.1 定义与作用 send() 函数用于将数据发送到已建立连接的套接字上，主要用于 面向连接的套接字（如 TCP）。它提供了比 write() 更丰富的功","title":"Send发送函数"},{"content":"\rstd::array 是 C++11 引入的一个容器，提供了定长数组的封装，比传统的 C 风格数组更安全、更具可操作性。本文将详细剖析 std::array，从其定义、特性、用法到实践中的注意事项，力求为各个阶段的学习者提供全面而深入的指导。\n一、std::array 概述 1.1 定义与作用 std::array 是一个 定长、顺序、连续存储 的容器，封装了原生数组，提供了 STL 容器的接口和功能，如迭代器、大小查询等。它的大小在编译时确定，不能动态调整。\n1.2 头文件与命名空间 要使用 std::array，需要包含头文件 \u0026lt;array\u0026gt;，并使用 std 命名空间。\n1 2 3 #include \u0026lt;array\u0026gt; using namespace std; 二、std::array 的定义与基本用法 2.1 定义语法 1 std::array\u0026lt;类型, 大小\u0026gt; 数组名; 类型：数组中元素的类型。 大小：数组的长度，必须是编译时常量。 2.2 示例 1 std::array\u0026lt;int, 5\u0026gt; arr = {1, 2, 3, 4, 5}; 2.3 与原生数组的区别 安全性：std::array 提供了边界检查，如 at() 方法。 可操作性：支持 STL 容器的接口，如迭代器、算法等。 赋值与拷贝：std::array 支持拷贝赋值，而原生数组不支持直接赋值。 三、成员函数与操作 3.1 访问元素 operator[]：随机访问，不进行边界检查。\n1 int value = arr[2]; // 访问第 3 个元素 at()：随机访问，进行边界检查，越界时抛出 std::out_of_range 异常。\n1 int value = arr.at(2); front()：返回第一个元素的引用。\n1 int \u0026amp;first = arr.front(); back()：返回最后一个元素的引用。\n1 int \u0026amp;last = arr.back(); 3.2 大小与容量 size()：返回元素数量（固定的）。\n1 size_t n = arr.size(); // 等于 5 max_size()：返回最大可存储的元素数量。\n1 size_t max_n = arr.max_size(); // 等于 5 3.3 迭代器 begin()：返回指向第一个元素的迭代器。\n1 auto it = arr.begin(); end()：返回指向末尾后位置的迭代器。\n1 auto it_end = arr.end(); 反向迭代器：rbegin()、rend()\n3.4 数据访问 data()：返回指向内部数组的指针，可与 C 风格函数兼容。\n1 int *p = arr.data(); 3.5 其他操作 fill()：将所有元素赋予相同的值。\n1 arr.fill(0); // 将所有元素置为 0 swap()：交换两个 std::array 的内容。\n1 2 std::array\u0026lt;int, 5\u0026gt; arr2 = {5, 4, 3, 2, 1}; arr.swap(arr2); 四、std::array 的高级用法 4.1 与算法库的结合 std::array 可以与 \u0026lt;algorithm\u0026gt; 中的算法结合使用。\n1 2 3 4 #include \u0026lt;algorithm\u0026gt; std::array\u0026lt;int, 5\u0026gt; arr = {3, 1, 4, 1, 5}; std::sort(arr.begin(), arr.end()); // 对数组排序 4.2 多维数组 可以使用嵌套的 std::array 来创建多维数组。\n1 std::array\u0026lt;std::array\u0026lt;int, 3\u0026gt;, 4\u0026gt; matrix; 4.3 与 std::vector 的区别 大小：std::array 大小固定，std::vector 大小可动态调整。 性能：std::array 没有动态内存分配，性能更好。 使用场景：std::array 适用于大小固定的情况，std::vector 适用于需要动态调整大小的情况。 4.4 与 C 风格数组的互操作 通过 data() 方法，可以获取原生数组指针，与 C 风格函数兼容。\n1 2 3 4 void c_function(int *arr, size_t size); std::array\u0026lt;int, 5\u0026gt; arr = {1, 2, 3, 4, 5}; c_function(arr.data(), arr.size()); 五、注意事项 5.1 边界检查 operator[]：不进行边界检查，越界访问会导致未定义行为。 at()：进行边界检查，越界时抛出异常。 建议：在可能发生越界的情况下，优先使用 at() 方法。\n5.2 大小必须是编译时常量 std::array 的大小在编译时确定，不能使用运行时变量。\n1 2 int n = 5; std::array\u0026lt;int, n\u0026gt; arr; // 错误，n 必须是常量表达式 解决方案：如果需要在运行时确定大小，使用 std::vector。\n5.3 初始化方式 列表初始化：\n1 std::array\u0026lt;int, 5\u0026gt; arr = {1, 2, 3, 4, 5}; 默认初始化：元素未初始化。\n1 std::array\u0026lt;int, 5\u0026gt; arr; 值初始化：所有元素初始化为默认值（对于基本类型为 0）。\n1 std::array\u0026lt;int, 5\u0026gt; arr = {}; 5.4 与原生数组的大小比较 sizeof(arr) 返回整个 std::array 对象的大小，而原生数组可能退化为指针，sizeof 的结果不同。\n1 2 3 4 5 std::array\u0026lt;int, 5\u0026gt; arr; std::cout \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; std::endl; // 输出 20（假设 int 为 4 字节） int c_arr[5]; std::cout \u0026lt;\u0026lt; sizeof(c_arr) \u0026lt;\u0026lt; std::endl; // 也输出 20 六、常见陷阱 6.1 忘记包含头文件 问题：未包含 \u0026lt;array\u0026gt; 头文件，导致编译错误。 解决方案：确保包含正确的头文件。 6.2 大小不匹配的拷贝 问题：尝试拷贝大小不同的 std::array，会导致编译错误。 解决方案：只有大小相同且元素类型相同的 std::array 才能相互赋值。 6.3 不使用 std::array 的优势 问题：使用 std::array 却仍然当作原生数组使用，未充分利用其安全性和功能性。 解决方案：充分利用 std::array 提供的成员函数和 STL 算法，提高代码质量。 七、拓展资料：关键概念解释 7.1 STL 容器概述 标准模板库（STL） 提供了一组通用的容器、算法和迭代器，用于高效地管理和操作数据。\n序列式容器：如 std::vector、std::deque、std::list、std::array，用于按序存储元素。 关联式容器：如 std::map、std::set，用于按键值快速查找元素。 7.2 迭代器与算法 迭代器：提供了一种遍历容器元素的方式，类似于指针。 算法：STL 提供了一系列通用算法，如排序、查找、复制等，可与任何符合要求的容器和迭代器配合使用。 7.3 std::array 与 std::vector 的选择 std::array： 大小固定，内存连续，性能高，无额外的内存分配。 适用于需要确定大小的场景。 std::vector： 大小可变，支持动态添加和删除元素。 适用于需要灵活调整大小的场景。 八、示例代码 8.1 使用 std::array 计算平均值 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;numeric\u0026gt; // std::accumulate int main() { std::array\u0026lt;double, 5\u0026gt; temperatures = {23.5, 25.0, 22.8, 24.1, 23.9}; double sum = std::accumulate(temperatures.begin(), temperatures.end(), 0.0); double average = sum / temperatures.size(); std::cout \u0026lt;\u0026lt; \u0026#34;Average temperature: \u0026#34; \u0026lt;\u0026lt; average \u0026lt;\u0026lt; \u0026#34;°C\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 8.2 使用 std::array 实现简单的矩阵相加 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;array\u0026gt; const size_t ROWS = 2; const size_t COLS = 3; int main() { std::array\u0026lt;std::array\u0026lt;int, COLS\u0026gt;, ROWS\u0026gt; matrix1 = {{{1, 2, 3}, {4, 5, 6}}}; std::array\u0026lt;std::array\u0026lt;int, COLS\u0026gt;, ROWS\u0026gt; matrix2 = {{{6, 5, 4}, {3, 2, 1}}}; std::array\u0026lt;std::array\u0026lt;int, COLS\u0026gt;, ROWS\u0026gt; result; for (size_t i = 0; i \u0026lt; ROWS; ++i) { for (size_t j = 0; j \u0026lt; COLS; ++j) { result[i][j] = matrix1[i][j] + matrix2[i][j]; } } // 输出结果 for (const auto \u0026amp;row : result) { for (const auto \u0026amp;elem : row) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; std::endl; } return 0; } 九、结语 std::array 作为 C++11 引入的 STL 容器，为定长数组的使用提供了安全性和便利性。通过深入理解其特性和用法，我们可以编写出更为健壮和高效的代码。在实际开发中，选择合适的容器类型，对代码性能和可维护性都有重要影响。\n希望本文能够帮助读者全面掌握 std::array，在日常编程中充分发挥其优势。\n","permalink":"https://oheyu.github.io/zh/posts/tech/stl%E5%AE%B9%E5%99%A8%E4%B9%8Barray/","summary":"std::array 是 C++11 引入的一个容器，提供了定长数组的封装，比传统的 C 风格数组更安全、更具可操作性。本文将详细剖析 std::array，从其定义、特性、用法","title":"STL容器之Array"},{"content":"\r深入解析 connect() 函数：理解、用法与实践 在网络编程中，connect() 函数是客户端建立网络连接的关键步骤。无论是开发简单的客户端应用，还是构建复杂的网络服务，对 connect() 的深入理解都是至关重要的。\n一、connect() 函数概述 1.1 定义与作用 connect() 函数用于在 客户端 与 服务器端 之间建立一个连接。对于流式套接字（如 TCP），它会在指定的套接字上发起对服务器的连接请求；对于数据报套接字（如 UDP），它会设置默认的目标地址，使得后续的发送和接收操作不需要每次指定目标地址。\n1.2 函数原型 1 2 3 4 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 二、connect() 函数的参数与返回值 2.1 参数解析 sockfd：套接字文件描述符，由 socket() 函数创建并返回，表示客户端的套接字。 addr：指向 struct sockaddr 类型的指针，包含了要连接的服务器地址和端口信息。 addrlen：addr 结构体的长度（字节数），可以使用 sizeof(struct sockaddr_in) 获取。 2.2 返回值 成功：返回 0，表示连接成功建立。 失败：返回 -1，并设置 errno 来指示具体的错误原因。 三、connect() 函数的工作原理 3.1 TCP 连接的建立过程 对于 TCP 套接字，connect() 函数的调用会触发 三次握手（Three-way Handshake）过程，以建立可靠的连接：\n客户端发送 SYN：客户端发送一个 SYN（同步）包，表示请求建立连接。 服务器回应 SYN-ACK：服务器收到 SYN 包后，回复一个 SYN-ACK 包，表示同意建立连接并同步序列号。 客户端发送 ACK：客户端收到 SYN-ACK 包后，发送一个 ACK 包，确认连接建立。 3.2 UDP 的特殊情况 对于 UDP 套接字，connect() 并不真正建立连接，而是设置默认的目标地址。这样，使用 send()、recv() 时无需每次指定目的地，但并不保证数据的可靠传输。\n3.3 非阻塞模式下的行为 如果套接字被设置为非阻塞模式，connect() 可能会立即返回，并设置 errno 为 EINPROGRESS，表示连接正在进行中，需要使用 select() 或 poll() 等函数等待连接完成。\n四、connect() 的使用示例 4.1 TCP 客户端连接示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main() { int sockfd; struct sockaddr_in server_addr; // 创建套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { perror(\u0026#34;socket creation failed\u0026#34;); return -1; } // 设置服务器地址 memset(\u0026amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; // IPv4 server_addr.sin_port = htons(8080); // 服务器端口 // 将 IP 地址转换为网络字节序 if (inet_pton(AF_INET, \u0026#34;192.168.1.100\u0026#34;, \u0026amp;server_addr.sin_addr) \u0026lt;= 0) { perror(\u0026#34;inet_pton failed\u0026#34;); close(sockfd); return -1; } // 连接服务器 if (connect(sockfd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) \u0026lt; 0) { perror(\u0026#34;connect failed\u0026#34;); close(sockfd); return -1; } printf(\u0026#34;Connected to the server successfully.\\n\u0026#34;); // 进行数据传输... // 关闭套接字 close(sockfd); return 0; } 4.2 UDP 套接字中的 connect() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 创建 UDP 套接字 int sockfd = socket(AF_INET, SOCK_DGRAM, 0); // 设置服务器地址 struct sockaddr_in server_addr; // ...（同上） // 使用 connect() 设置默认目标地址 connect(sockfd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)); // 现在可以使用 send() 和 recv() 而无需每次指定地址 char buffer[1024]; strcpy(buffer, \u0026#34;Hello, UDP server!\u0026#34;); send(sockfd, buffer, strlen(buffer), 0); 五、使用注意事项 5.1 地址结构体的正确设置 地址族一致性：sin_family 必须与套接字的地址族一致（AF_INET）。 IP 地址与端口的网络字节序：使用 inet_pton() 和 htons() 进行转换，确保地址和端口以网络字节序存储。 5.2 错误处理与重试机制 检查返回值：connect() 失败时，应根据 errno 进行错误处理。 常见错误： ECONNREFUSED：目标地址没有在监听。 ETIMEDOUT：连接超时。 EHOSTUNREACH：目标主机不可达。 重试策略：对于临时性错误，可以实现重试机制，避免因网络抖动导致连接失败。 5.3 非阻塞模式下的连接 处理 EINPROGRESS：表示连接正在进行中，需要使用 select()、poll() 或 epoll() 等函数等待连接完成。 检查连接结果：在非阻塞模式下，可以使用 getsockopt() 获取套接字选项 SO_ERROR，检查连接是否成功。 1 2 3 4 5 6 7 8 int error = 0; socklen_t len = sizeof(error); getsockopt(sockfd, SOL_SOCKET, SO_ERROR, \u0026amp;error, \u0026amp;len); if (error == 0) { // 连接成功 } else { // 连接失败，处理错误 } 六、常见陷阱与可能的解决方案 6.1 忘记绑定本地地址（客户端） 现象：客户端通常不需要调用 bind()，因为操作系统会自动分配本地端口和地址。 陷阱：如果显式调用 bind()，且指定了错误的地址或端口，可能导致连接失败。 6.2 多次调用 connect() 问题：对于已连接的套接字，再次调用 connect() 会导致错误。 解决方案：一个套接字只能连接一次，需要新的连接时，应创建新的套接字。 6.3 地址解析的错误处理 现象：使用主机名而非 IP 地址时，需要进行 DNS 解析，可能会失败。 建议：使用 getaddrinfo() 进行解析，处理 IPv4 和 IPv6，注意检查返回值。 6.4 连接超时设置 问题：默认的连接超时时间可能较长，影响用户体验。 解决方案： 设置套接字选项：使用 setsockopt() 设置超时时间。 非阻塞模式：将套接字设置为非阻塞，并使用 select() 等函数实现超时控制。 七、拓展资料：关键概念解释 7.1 三次握手（Three-way Handshake） 定义：在 TCP 协议中，客户端和服务器通过三次交互来建立可靠的连接。\n步骤： SYN：客户端发送 SYN 包，请求建立连接。 SYN-ACK：服务器回复 SYN-ACK 包，同意并同步序列号。 ACK：客户端发送 ACK 包，确认连接建立。 作用：确保双方都有能力发送和接收数据，并同步序列号，防止因延迟的旧连接数据影响新的连接。\n7.2 阻塞与非阻塞模式 阻塞模式：套接字操作（如 connect()）会阻塞调用线程，直到操作完成或发生错误。 非阻塞模式：套接字操作立即返回，若操作无法立即完成，则返回错误（如 EINPROGRESS）。 设置非阻塞模式：\n1 2 3 4 #include \u0026lt;fcntl.h\u0026gt; int flags = fcntl(sockfd, F_GETFL, 0); fcntl(sockfd, F_SETFL, flags | O_NONBLOCK); 应用场景：非阻塞模式常用于高性能网络编程，需要配合 I/O 多路复用机制（如 select()、poll()、epoll()）。\n7.3 select() 函数 定义：select() 用于监控多个文件描述符的状态，当其中一个或多个文件描述符变为就绪状态（可读、可写、异常），select() 返回，应用程序可以对其进行相应的操作。\n函数原型：\n1 2 3 #include \u0026lt;sys/select.h\u0026gt; int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 作用：在非阻塞套接字的连接过程中，select() 可用于等待套接字变为可写状态，表示连接已建立或失败。\n","permalink":"https://oheyu.github.io/zh/posts/tech/connect%E7%A9%B6%E7%AB%9F%E8%BF%9E%E6%8E%A5%E4%BA%86%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC/","summary":"深入解析 connect() 函数：理解、用法与实践 在网络编程中，connect() 函数是客户端建立网络连接的关键步骤。无论是开发简单的客户端应用，还是构建复杂","title":"Connect究竟连接了个什么鬼"},{"content":"\r这些个结构体哟！！！\n一、sockaddr_in 结构体概述 1.1 定义与作用 sockaddr_in 是用于 IPv4 网络编程的地址结构体，包含了 IP 地址和端口号等信息。在使用套接字进行网络通信时，需要使用该结构体来指定通信双方的地址信息。\n1.2 结构体定义 sockaddr_in 定义在头文件 \u0026lt;netinet/in.h\u0026gt; 中，具体定义如下：\n1 2 3 4 5 6 struct sockaddr_in { sa_family_t sin_family; /* 地址族 (Address Family) */ in_port_t sin_port; /* 16 位端口号 (Port Number) */ struct in_addr sin_addr; /* 32 位 IP 地址 (IPv4 Address) */ unsigned char sin_zero[8];/* 填充字节 (Padding) */ }; sa_family_t：通常是一个 unsigned short，指定地址族。 in_port_t：通常是一个 unsigned short，用于存储端口号。 struct in_addr：用于存储 IPv4 地址。 sin_zero：填充使得结构体大小与 struct sockaddr 保持一致。 二、sockaddr_in 结构体成员详解 2.1 sin_family：地址族 类型：sa_family_t 含义：指定地址族，必须设置为 AF_INET，表示使用 IPv4 地址。 注意：不要与 PF_INET 混淆，AF_INET 用于套接字地址，PF_INET 用于套接字通信域。 2.2 sin_port：端口号 类型：in_port_t（通常为 uint16_t） 含义：16 位的端口号，用于标识进程间通信的端点。 注意：端口号需要使用 网络字节序（大端序）。应使用 htons() 函数进行转换。 2.3 sin_addr：IP 地址 类型：struct in_addr 含义：存储 32 位 IPv4 地址。 成员：in_addr_t s_addr，实际的 IP 地址值。 注意：IP 地址需要使用 网络字节序。应使用 inet_pton() 或 inet_addr() 等函数进行设置。 2.4 sin_zero：填充字节 类型：unsigned char[8] 含义：填充字段，使 sockaddr_in 的大小与 sockaddr 结构体一致。 作用：一般不使用，应将其置零。 三、sockaddr_in 与 sockaddr 之间的关系 3.1 sockaddr 结构体 sockaddr 是通用的套接字地址结构体，定义如下：\n1 2 3 4 struct sockaddr { sa_family_t sa_family; /* 地址族 */ char sa_data[14]; /* 地址数据 */ }; 3.2 类型转换 在使用套接字函数（如 bind()、connect()）时，通常需要将 sockaddr_in 转换为 sockaddr 指针。这是因为这些函数使用通用的 sockaddr 结构体来支持不同的地址族。\n1 2 struct sockaddr_in addr_in; struct sockaddr *addr = (struct sockaddr *)\u0026amp;addr_in; 3.3 为什么需要转换 兼容性：套接字函数设计为支持多种协议族，使用通用的 sockaddr 结构体，可以通过 sa_family 来区分具体的地址类型。 灵活性：通过类型转换，可以在需要时传递特定的地址结构体，同时保持函数接口的一致性。 四、sockaddr_in 的使用示例 4.1 初始化 sockaddr_in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; void init_sockaddr_in(struct sockaddr_in *addr, const char *ip_str, uint16_t port) { memset(addr, 0, sizeof(struct sockaddr_in)); // 清零 addr-\u0026gt;sin_family = AF_INET; // 设置地址族 // 设置端口号，使用网络字节序 addr-\u0026gt;sin_port = htons(port); // 设置 IP 地址 if (inet_pton(AF_INET, ip_str, \u0026amp;(addr-\u0026gt;sin_addr)) \u0026lt;= 0) { perror(\u0026#34;inet_pton failed\u0026#34;); } } 4.2 在服务器端使用 sockaddr_in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int server_socket_setup(uint16_t port) { int sockfd; struct sockaddr_in server_addr; // 创建套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { perror(\u0026#34;socket creation failed\u0026#34;); return -1; } // 初始化地址结构体 init_sockaddr_in(\u0026amp;server_addr, \u0026#34;0.0.0.0\u0026#34;, port); // 绑定地址 if (bind(sockfd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) \u0026lt; 0) { perror(\u0026#34;bind failed\u0026#34;); close(sockfd); return -1; } // 开始监听 if (listen(sockfd, SOMAXCONN) \u0026lt; 0) { perror(\u0026#34;listen failed\u0026#34;); close(sockfd); return -1; } return sockfd; } 4.3 在客户端使用 sockaddr_in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int client_socket_setup(const char *server_ip, uint16_t port) { int sockfd; struct sockaddr_in server_addr; // 创建套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { perror(\u0026#34;socket creation failed\u0026#34;); return -1; } // 初始化服务器地址 init_sockaddr_in(\u0026amp;server_addr, server_ip, port); // 连接服务器 if (connect(sockfd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) \u0026lt; 0) { perror(\u0026#34;connect failed\u0026#34;); close(sockfd); return -1; } return sockfd; } 五、使用注意事项 5.1 网络字节序与主机字节序 问题：不同机器可能使用不同的字节序（大端或小端）。 解决方案：使用 htons()、htonl() 将主机字节序转换为网络字节序；使用 ntohs()、ntohl() 进行逆转换。 1 addr-\u0026gt;sin_port = htons(port); // 端口号转换 5.2 IP 地址的设置 方法： 使用 inet_pton()：推荐，支持 IPv4 和 IPv6，线程安全。 使用 inet_addr()：仅支持 IPv4，返回网络字节序的整数表示。 使用 INADDR_ANY：绑定到所有可用接口，通常用于服务器端。 使用 INADDR_LOOPBACK：绑定到本地主机（127.0.0.1）。 1 addr-\u0026gt;sin_addr.s_addr = htonl(INADDR_ANY); 5.3 初始化 sin_zero 注意：sin_zero 一般不使用，但为了兼容性，通常将其置零。 方法：使用 memset() 或显式赋值。 1 memset(\u0026amp;(addr-\u0026gt;sin_zero), 0, sizeof(addr-\u0026gt;sin_zero)); 5.4 套接字地址长度 获取长度：使用 sizeof(struct sockaddr_in)，或者使用 socklen_t 类型。 原因：不同的地址结构体可能长度不同，使用 sizeof 可以确保传递正确的长度。 1 socklen_t addr_len = sizeof(struct sockaddr_in); 六、常见陷阱 6.1 忘记字节序转换 现象：端口号或 IP 地址不正确，无法连接。 解决方案：确保使用 htons()、htonl() 进行必要的转换。 6.2 地址族不匹配 问题：sin_family 设置错误，导致函数调用失败。 解决方案：始终将 sin_family 设置为 AF_INET（IPv4）或 AF_INET6（IPv6）。 6.3 使用未初始化的结构体 问题：未对 sockaddr_in 结构体进行初始化，包含垃圾值。 解决方案：使用 memset() 清零，或逐个字段进行赋值。 6.4 错误的类型转换 问题：在调用套接字函数时，未正确转换为 struct sockaddr * 类型。 解决方案：使用显式类型转换。 1 (struct sockaddr *)\u0026amp;server_addr 七、拓展资料：关键概念解释 7.1 网络字节序与主机字节序 字节序： 大端序（Big Endian）：高位字节存储在低地址。 小端序（Little Endian）：低位字节存储在低地址。 网络字节序：TCP/IP 协议规定使用大端序，称为网络字节序。 转换函数： htons()：主机字节序到网络字节序（16 位）。 htonl()：主机字节序到网络字节序（32 位）。 ntohs()、ntohl()：网络字节序到主机字节序。 7.2 IP 地址与端口 IP 地址：用于标识网络中的主机或设备，IPv4 地址为 32 位，通常表示为点分十进制格式（如 192.168.1.1）。 端口号：用于标识主机上的具体应用或服务，取值范围为 0 到 65535，其中 0 到 1023 为系统保留端口。 7.3 结构体填充与对齐 填充（Padding）：为了满足内存对齐要求，编译器可能在结构体中插入填充字节。 对齐（Alignment）：数据在内存中按一定的字节数对齐，以提高访问效率。 sin_zero 的作用：填充使得 sockaddr_in 的大小与 sockaddr 一致，确保结构体在内存中的布局正确。 ","permalink":"https://oheyu.github.io/zh/posts/tech/sockaddr_in%E7%BB%93%E6%9E%84%E4%BD%93/","summary":"这些个结构体哟！！！ 一、sockaddr_in 结构体概述 1.1 定义与作用 sockaddr_in 是用于 IPv4 网络编程的地址结构体，包含了 IP 地址和端口号等信息。在使用套接字","title":"Sockaddr_in结构体"},{"content":"\r这万恶的结构体啊！！！\n一、hostent 结构体概述 1.1 定义与作用 hostent 结构体用于描述主机的信息，包括主机名、别名、地址类型、地址长度和地址列表等。它通常在使用域名解析函数（如 gethostbyname()、gethostbyaddr()）时返回，帮助程序获取主机的网络地址信息。\n1.2 结构体定义 在头文件 \u0026lt;netdb.h\u0026gt; 中，hostent 结构体定义如下：\n1 2 3 4 5 6 7 struct hostent { char *h_name; /* Official name of the host */ char **h_aliases; /* Null-terminated array of alternative names */ int h_addrtype; /* Address type (e.g., AF_INET) */ int h_length; /* Length of the address in bytes */ char **h_addr_list; /* Null-terminated array of addresses */ }; 为了兼容，通常会定义一个宏：\n1 #define h_addr h_addr_list[0] /* For backward compatibility */ 二、hostent 结构体的成员详解 2.1 h_name：主机的正式名称 类型：char * 含义：主机的官方全称，通常是一个完全限定域名（FQDN，Fully Qualified Domain Name），如 \u0026quot;www.example.com\u0026quot;。 2.2 h_aliases：主机的别名列表 类型：char **（以 NULL 结尾的字符串数组） 含义：主机的其他名称或别名列表，可以通过这些别名访问同一主机。 2.3 h_addrtype：地址类型 类型：int 含义：指定地址的类型，常见的值有： AF_INET：IPv4 地址 AF_INET6：IPv6 地址 2.4 h_length：地址长度 类型：int 含义：地址的长度，以字节为单位。 对于 IPv4，h_length 等于 4（因为 IPv4 地址占 4 个字节）。 对于 IPv6，h_length 等于 16（因为 IPv6 地址占 16 个字节）。 2.5 h_addr_list：主机地址列表 类型：char **（以 NULL 结尾的字节数组指针数组） 含义：主机的网络地址列表，每个地址都是一个 h_length 字节长的二进制地址。 注意：地址以网络字节序存储。 2.6 h_addr：第一个地址（兼容宏） 宏定义：#define h_addr h_addr_list[0] 含义：为了兼容早期代码，h_addr 提供了获取第一个地址的快捷方式。 三、主机名解析函数与 hostent 3.1 gethostbyname() 3.1.1 函数原型 1 2 3 #include \u0026lt;netdb.h\u0026gt; struct hostent *gethostbyname(const char *name); 3.1.2 参数与返回值 参数：主机名字符串，如 \u0026quot;www.example.com\u0026quot;。 返回值：指向 hostent 结构体的指针，包含解析后的主机信息；如果失败，返回 NULL。 3.1.3 用法示例 1 2 3 4 struct hostent *host = gethostbyname(\u0026#34;www.example.com\u0026#34;); if (host == NULL) { // 处理错误 } 3.2 gethostbyaddr() 3.2.1 函数原型 1 2 3 #include \u0026lt;netdb.h\u0026gt; struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type); 3.2.2 参数与返回值 addr：指向网络字节序的地址数据。 len：地址长度（h_length）。 type：地址类型（h_addrtype）。 返回值：指向 hostent 结构体的指针；失败返回 NULL。 3.2.3 用法示例 1 2 3 4 5 6 struct in_addr ipv4_addr; inet_pton(AF_INET, \u0026#34;93.184.216.34\u0026#34;, \u0026amp;ipv4_addr); struct hostent *host = gethostbyaddr(\u0026amp;ipv4_addr, sizeof(ipv4_addr), AF_INET); if (host == NULL) { // 处理错误 } 3.3 注意事项 线程安全性：gethostbyname() 和 gethostbyaddr() 并非线程安全，可能返回指向静态内存的指针，多个线程调用可能导致数据混乱。 替代函数：建议使用线程安全的函数，如 gethostbyname_r()、gethostbyaddr_r()，或者使用现代的 getaddrinfo() 函数。 四、hostent 结构体的使用示例 4.1 获取主机 IP 地址列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; void print_host_info(const char *hostname) { struct hostent *host = gethostbyname(hostname); if (host == NULL) { fprintf(stderr, \u0026#34;Failed to resolve hostname: %s\\n\u0026#34;, hostname); return; } printf(\u0026#34;Official name: %s\\n\u0026#34;, host-\u0026gt;h_name); // 打印别名列表 char **alias = host-\u0026gt;h_aliases; printf(\u0026#34;Aliases:\\n\u0026#34;); while (*alias != NULL) { printf(\u0026#34; %s\\n\u0026#34;, *alias); alias++; } // 打印 IP 地址列表 char **addr_list = host-\u0026gt;h_addr_list; char ip_str[INET6_ADDRSTRLEN]; printf(\u0026#34;Addresses:\\n\u0026#34;); while (*addr_list != NULL) { if (host-\u0026gt;h_addrtype == AF_INET) { struct in_addr *addr = (struct in_addr *)*addr_list; inet_ntop(AF_INET, addr, ip_str, sizeof(ip_str)); } else if (host-\u0026gt;h_addrtype == AF_INET6) { struct in6_addr *addr6 = (struct in6_addr *)*addr_list; inet_ntop(AF_INET6, addr6, ip_str, sizeof(ip_str)); } else { strncpy(ip_str, \u0026#34;Unknown AF\u0026#34;, sizeof(ip_str)); } printf(\u0026#34; %s\\n\u0026#34;, ip_str); addr_list++; } } int main() { print_host_info(\u0026#34;www.example.com\u0026#34;); return 0; } 4.2 解析 IP 地址对应的主机名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; void print_reverse_dns(const char *ip_address) { struct in_addr ipv4_addr; inet_pton(AF_INET, ip_address, \u0026amp;ipv4_addr); struct hostent *host = gethostbyaddr(\u0026amp;ipv4_addr, sizeof(ipv4_addr), AF_INET); if (host == NULL) { fprintf(stderr, \u0026#34;Failed to perform reverse DNS lookup for: %s\\n\u0026#34;, ip_address); return; } printf(\u0026#34;Host name for IP %s: %s\\n\u0026#34;, ip_address, host-\u0026gt;h_name); } int main() { print_reverse_dns(\u0026#34;93.184.216.34\u0026#34;); return 0; } 五、实践中的注意事项 5.1 线程安全问题 风险：gethostbyname() 返回的数据存储在静态区域，多线程同时调用可能导致数据混淆。 解决方案： 使用线程安全的函数，如 gethostbyname_r()。 使用现代的 getaddrinfo()，它是线程安全的，功能更强大。 5.2 IPv6 支持 问题：gethostbyname() 对 IPv6 支持有限，可能无法解析 IPv6 地址。 解决方案：使用 getaddrinfo()，它支持 IPv4 和 IPv6，并提供统一的接口。 5.3 地址转换 网络字节序：h_addr_list 中的地址是二进制形式，需要转换成人类可读的字符串。 函数：使用 inet_ntop()（推荐）或 inet_ntoa()（IPv4 专用）进行地址转换。 5.4 错误处理 返回值检查：当函数返回 NULL 时，应检查全局变量 h_errno 以确定错误原因。 错误信息：使用 hstrerror(h_errno) 获取错误描述。 1 2 3 if (host == NULL) { fprintf(stderr, \u0026#34;Error: %s\\n\u0026#34;, hstrerror(h_errno)); } 六、替代方案：getaddrinfo() 和 addrinfo 结构体 6.1 getaddrinfo() 的优势 线程安全：适用于多线程环境。 支持 IPv4 和 IPv6：统一处理不同协议族的地址解析。 灵活的查询选项：通过 addrinfo 结构体可以指定更多的查询参数。 6.2 addrinfo 结构体定义 1 2 3 4 5 6 7 8 9 10 struct addrinfo { int ai_flags; /* Input flags */ int ai_family; /* Address family */ int ai_socktype; /* Socket type */ int ai_protocol; /* Protocol */ socklen_t ai_addrlen; /* Length of ai_addr */ struct sockaddr *ai_addr; /* Binary address */ char *ai_canonname; /* Canonical name */ struct addrinfo *ai_next; /* Next structure in linked list */ }; 6.3 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; void print_addresses(const char *hostname) { struct addrinfo hints, *res, *p; char ip_str[INET6_ADDRSTRLEN]; memset(\u0026amp;hints, 0, sizeof(hints)); hints.ai_family = AF_UNSPEC; // AF_INET 或 AF_INET6 hints.ai_socktype = SOCK_STREAM; int status = getaddrinfo(hostname, NULL, \u0026amp;hints, \u0026amp;res); if (status != 0) { fprintf(stderr, \u0026#34;getaddrinfo error: %s\\n\u0026#34;, gai_strerror(status)); return; } printf(\u0026#34;IP addresses for %s:\\n\\n\u0026#34;, hostname); for (p = res; p != NULL; p = p-\u0026gt;ai_next) { void *addr; const char *ip_version; if (p-\u0026gt;ai_family == AF_INET) { // IPv4 struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-\u0026gt;ai_addr; addr = \u0026amp;(ipv4-\u0026gt;sin_addr); ip_version = \u0026#34;IPv4\u0026#34;; } else if (p-\u0026gt;ai_family == AF_INET6) { // IPv6 struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-\u0026gt;ai_addr; addr = \u0026amp;(ipv6-\u0026gt;sin6_addr); ip_version = \u0026#34;IPv6\u0026#34;; } else { continue; } inet_ntop(p-\u0026gt;ai_family, addr, ip_str, sizeof(ip_str)); printf(\u0026#34; %s: %s\\n\u0026#34;, ip_version, ip_str); } freeaddrinfo(res); } int main() { print_addresses(\u0026#34;www.example.com\u0026#34;); return 0; } 七、拓展资料：关键概念解释 7.1 DNS（域名系统） 定义：DNS 是域名系统（Domain Name System）的缩写，它将人类可读的主机名转换为机器可读的 IP 地址。 作用：方便用户通过域名访问网络资源，而无需记忆复杂的 IP 地址。 解析过程：当程序调用 gethostbyname() 等函数时，操作系统会查询本地缓存、Hosts 文件或通过网络向 DNS 服务器请求解析。 7.2 网络字节序与主机字节序 字节序：指多字节数据在内存中的存储顺序。 大端序（Big Endian）：高字节存储在低地址。 小端序（Little Endian）：低字节存储在低地址。 网络字节序：TCP/IP 协议规定使用大端序，称为网络字节序。 转换函数：htonl()、htons()、ntohl()、ntohs()。 7.3 inet_ntop() 与 inet_pton() 作用： inet_ntop()：将网络字节序的二进制 IP 地址转换为点分十进制字符串表示。 inet_pton()：将点分十进制字符串 IP 地址转换为网络字节序的二进制格式。 优势：支持 IPv4 和 IPv6，线程安全，推荐使用。 ","permalink":"https://oheyu.github.io/zh/posts/tech/hostent%E7%BB%93%E6%9E%84%E4%BD%93/","summary":"这万恶的结构体啊！！！ 一、hostent 结构体概述 1.1 定义与作用 hostent 结构体用于描述主机的信息，包括主机名、别名、地址类型、地址长度和地址列表等。","title":"Hostent结构体"},{"content":"\r之前也断断续续接触过Linux下的网络编程，相关内容一放下就很难记起来，还是用得太少。今天开始，准备系统地、持续地学习一下相关内容。今天，就用socket() 函数作为正式开始吧。\n一、socket() 函数的基础 1.1 函数原型 1 2 3 4 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int socket(int domain, int type, int protocol); 1.2 参数解析 domain（协议族）：\nAF_INET：IPv4 互联网协议。 AF_INET6：IPv6 互联网协议。 AF_UNIX / AF_LOCAL：本地通信（Unix 域套接字）。 AF_PACKET：底层套接字，可直接操作链路层。 type（套接字类型）：\nSOCK_STREAM：面向连接的字节流（TCP）。 SOCK_DGRAM：无连接的数据报（UDP）。 SOCK_RAW：原始套接字，可用于自定义协议。 protocol（协议）：\n通常设置为 0，由系统自动选择合适的协议。 可以指定特定协议，如 IPPROTO_TCP、IPPROTO_UDP。 1.3 返回值 成功：返回套接字文件描述符（非负整数）。 失败：返回 -1，并设置 errno 以指示错误原因。 1.4 套接字的生命周期 创建套接字：socket() 绑定地址：bind() 监听连接（服务器端）：listen() 接受连接（服务器端）：accept() 建立连接（客户端）：connect() 数据传输：send() / recv() 或 read() / write() 关闭连接：close() 或 shutdown() 二、深入理解 socket() 的工作原理 2.1 套接字在内核中的表示 在 Linux 内核中，套接字是一种特殊的文件，遵循“一切皆文件”的哲学。socket() 调用返回的文件描述符实际上是一个索引，指向内核空间中的 struct socket 结构。\n2.2 协议栈的分层 网络协议栈通常分为五层（大家貌似更加偏向于四层）：\n物理层：传输比特流的物理媒介。 数据链路层：MAC 地址、帧的传输。 网络层：IP 地址、路由选择。 传输层：TCP、UDP 协议，提供端到端通信。 应用层：HTTP、FTP 等具体应用协议。 socket() 函数主要涉及传输层和网络层，通过指定 domain、type、protocol，可以灵活选择所需的通信方式。\n2.3 套接字类型的深入分析 SOCK_STREAM（TCP）：\n提供可靠的、面向连接的字节流服务。 数据无边界，需自行解析消息。 适用于要求数据完整性和顺序性的应用。 SOCK_DGRAM（UDP）：\n提供无连接的、尽最大努力交付的数据报服务。 数据有边界，每个 send() / recv() 对应一个数据报。 适用于实时性要求高，但可容忍部分数据丢失的应用。 SOCK_RAW（原始套接字）：\n允许直接访问下层协议，如 IP 层。 可用于实现自定义协议或网络工具（如 ping、traceroute）。 需要 root 权限。 三、socket() 的高级用法和技巧 3.1 套接字选项的灵活配置 使用 setsockopt() 和 getsockopt() 函数，可以设置和获取套接字的各种选项，优化网络应用的性能和行为。\n3.1.1 常用套接字选项 SO_REUSEADDR：允许重用本地地址和端口，解决“地址已在使用”错误。 SO_RCVBUF / SO_SNDBUF：设置接收和发送缓冲区大小，优化吞吐量。 SO_KEEPALIVE：启用心跳机制，检测连接是否存活。 TCP_NODELAY：禁用 Nagle 算法，降低小包延迟。 3.1.2 示例：设置 SO_REUSEADDR 1 2 3 4 5 6 int opt = 1; if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;opt, sizeof(opt)) \u0026lt; 0) { perror(\u0026#34;setsockopt SO_REUSEADDR failed\u0026#34;); close(sockfd); exit(EXIT_FAILURE); } 3.2 非阻塞套接字与多路复用 3.2.1 非阻塞模式 设置方法：使用 fcntl() 函数，将套接字设置为非阻塞模式。 1 2 3 4 #include \u0026lt;fcntl.h\u0026gt; int flags = fcntl(sockfd, F_GETFL, 0); fcntl(sockfd, F_SETFL, flags | O_NONBLOCK); 应用场景：高性能服务器，需要同时处理大量连接，避免阻塞在某个套接字上。 3.2.2 多路复用技术 select()：早期的 I/O 多路复用函数，支持的文件描述符数量有限（FD_SETSIZE）。 poll()：改进了 select() 的一些缺点，但仍存在性能问题。 epoll()：Linux 特有，高效处理大量并发连接，适用于高性能服务器。 3.2.3 示例：使用 epoll 实现高并发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;sys/epoll.h\u0026gt; int epfd = epoll_create1(0); struct epoll_event ev, events[MAX_EVENTS]; ev.events = EPOLLIN; ev.data.fd = sockfd; epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, \u0026amp;ev); int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1); for (int i = 0; i \u0026lt; nfds; ++i) { if (events[i].events \u0026amp; EPOLLIN) { // 处理可读事件 } } 3.3 信号驱动式套接字 概念：利用信号机制处理套接字事件，减少阻塞等待。 设置方法：使用 fcntl() 设置 O_ASYNC 标志，并指定信号接收者。 1 2 fcntl(sockfd, F_SETFL, flags | O_ASYNC); fcntl(sockfd, F_SETOWN, getpid()); 应用场景：适用于对实时性要求高的应用，但编程复杂度较大。 四、常见陷阱与问题解析 4.1 bind() 失败：地址已在使用 原因：套接字在关闭后，操作系统会将其置于 TIME_WAIT 状态，暂时无法重用地址和端口。 解决方案： 设置 SO_REUSEADDR 选项。 但需注意，这可能导致端口被不正确地重用，带来安全风险。 4.2 SIGPIPE 信号导致程序崩溃 原因：向已关闭的套接字写入数据，会触发 SIGPIPE 信号，默认行为是终止进程。 解决方案： 捕获并忽略 SIGPIPE 信号。 1 signal(SIGPIPE, SIG_IGN); 在 send() 时使用 MSG_NOSIGNAL 标志。 1 send(sockfd, buf, len, MSG_NOSIGNAL); 4.3 网络字节序与主机字节序 问题：不同体系结构的主机可能使用不同的字节序（大端或小端）。 解决方案：使用标准函数进行转换。 1 2 3 4 uint16_t htons(uint16_t hostshort); // 主机字节序转网络字节序（短整数） uint32_t htonl(uint32_t hostlong); // 主机字节序转网络字节序（长整数） uint16_t ntohs(uint16_t netshort); // 网络字节序转主机字节序（短整数） uint32_t ntohl(uint32_t netlong); // 网络字节序转主机字节序（长整数） 4.4 粘包与拆包问题 现象：在 TCP 协议中，由于流式传输，数据可能会出现粘包或拆包，需要自行处理消息边界。 解决方案： 定义应用层协议，添加消息头，指定数据长度。 使用定界符（如 \\n）标识消息结束。 五、实践经验与独到见解 5.1 深刻理解阻塞与非阻塞模式 阻塞模式：编程简单，但在高并发场景下性能有限，可能导致线程或进程数量过多。 非阻塞模式：需要配合多路复用，编程复杂度较高，但能显著提升性能。 建议：根据应用需求选择合适的模式，小型应用可采用阻塞模式，追求高性能时应使用非阻塞模式并结合 epoll 等机制。\n5.2 合理设置套接字选项，提升性能 发送缓冲区与接收缓冲区：根据网络状况和应用需求，适当调整缓冲区大小，避免过小导致频繁的系统调用，过大则浪费内存。 TCP_NODELAY：在需要低延迟的小数据传输时，禁用 Nagle 算法，防止数据延迟发送。 5.3 充分考虑异常和错误处理 网络编程中的异常情况多样：对方关闭连接、网络波动、超时等。 健壮的错误处理：检查每个系统调用的返回值，处理可能的错误，确保程序的稳定性。 5.4 安全性考虑 防止资源泄漏：及时关闭未使用的套接字，防止文件描述符耗尽。 防御性编程：验证输入数据的合法性，防止缓冲区溢出和其他安全漏洞。 5.5 学习和使用高效的网络库 Boost.Asio：跨平台的 C++ 网络库，支持同步和异步 I/O，封装了复杂的细节。 libevent / libev / libuv：高性能事件驱动库，可用于构建高并发网络应用。 建议：在理解底层原理的基础上，合理使用成熟的网络库，加快开发速度，提高代码质量。\n","permalink":"https://oheyu.github.io/zh/posts/tech/socket%E5%87%BD%E6%95%B0%E5%89%96%E6%9E%90/","summary":"之前也断断续续接触过Linux下的网络编程，相关内容一放下就很难记起来，还是用得太少。今天开始，准备系统地、持续地学习一下相关内容。今天，就","title":"Socket函数剖析"},{"content":"\r随着 C++11 标准的引入，智能指针成为了现代 C++ 编程中资源管理的核心工具。其中，unique_ptr 是一种独占式的智能指针，负责管理动态分配的对象，确保在不再需要时自动释放内存，避免内存泄漏。本文将全面、准确地介绍 unique_ptr 的用法、特点以及在实际编程中的应用和注意事项。\n一、什么是 unique_ptr unique_ptr 是 C++11 标准库中的智能指针，位于头文件 \u0026lt;memory\u0026gt; 中。它实现了独占式所有权，即同一时间内只有一个 unique_ptr 指向某个动态分配的对象。当 unique_ptr 被销毁时，所管理的对象也会被自动销毁，避免了内存泄漏。\n特点：\n独占所有权：unique_ptr 独自拥有所指向的对象，不能复制或共享。 移动语义支持：支持移动构造和移动赋值，可以转移所有权。 轻量级：无需引用计数，开销较小。 二、unique_ptr 的基本用法 2.1 初始化 unique_ptr 方法一：直接使用构造函数\n1 2 3 #include \u0026lt;memory\u0026gt; std::unique_ptr\u0026lt;int\u0026gt; p1(new int(10)); 方法二：使用 std::make_unique（C++14 引入）\n1 2 3 #include \u0026lt;memory\u0026gt; auto p2 = std::make_unique\u0026lt;int\u0026gt;(20); 方法三：从已有的原始指针初始化（不推荐）\n1 2 int* raw_ptr = new int(30); std::unique_ptr\u0026lt;int\u0026gt; p3(raw_ptr); // 不推荐 注意： 方法三存在风险，如果多个 unique_ptr 管理同一原始指针，会导致未定义行为。\n2.2 使用 unique_ptr 访问所管理的对象\n1 2 3 std::unique_ptr\u0026lt;AA\u0026gt; ptr = std::make_unique\u0026lt;AA\u0026gt;(\u0026#34;对象名称\u0026#34;); ptr-\u0026gt;成员函数(); (*ptr).成员函数(); 禁止复制和赋值\n1 2 3 std::unique_ptr\u0026lt;int\u0026gt; p1(new int(10)); std::unique_ptr\u0026lt;int\u0026gt; p2 = p1; // 错误，不能复制 p2 = p1; // 错误，不能赋值 移动所有权\n1 std::unique_ptr\u0026lt;int\u0026gt; p3 = std::move(p1); // p1 资源转移给 p3 2.3 函数参数中的 unique_ptr 传递所有权\n如果函数需要接管 unique_ptr 的所有权，可以通过 移动语义 传递：\n1 2 3 4 void func(std::unique_ptr\u0026lt;AA\u0026gt; ptr) { // 接管所有权 } func(std::move(p1)); 共享访问\n如果函数只需要访问对象，不需要所有权，可以传递 引用 或 原始指针：\n1 2 void func(const std::unique_ptr\u0026lt;AA\u0026gt;\u0026amp; ptr); // 传引用 void func(const AA* ptr); // 传原始指针 三、unique_ptr 的高级特性 3.1 所有权转移与移动语义 unique_ptr 禁止复制构造和复制赋值，但支持移动构造和移动赋值。这意味着可以通过 std::move 转移所有权。\n1 2 std::unique_ptr\u0026lt;AA\u0026gt; p1 = std::make_unique\u0026lt;AA\u0026gt;(\u0026#34;对象1\u0026#34;); std::unique_ptr\u0026lt;AA\u0026gt; p2 = std::move(p1); // p1 被置空，p2 接管所有权 注意： 转移所有权后，原来的 unique_ptr 将不再指向对象，应避免再次使用。\n3.2 自定义删除器 unique_ptr 支持自定义删除器，以替代默认的 delete 操作。\n1 2 3 4 5 6 void custom_deleter(AA* ptr) { // 自定义删除逻辑 delete ptr; } std::unique_ptr\u0026lt;AA, decltype(\u0026amp;custom_deleter)\u0026gt; p(new AA, custom_deleter); 3.3 管理动态数组 unique_ptr 提供了针对数组的特化版本，可以管理动态分配的数组。\n1 2 std::unique_ptr\u0026lt;int[]\u0026gt; arr(new int[5]{1, 2, 3, 4, 5}); arr[0] = 10; // 支持下标操作 注意： 管理数组时，unique_ptr 会使用 delete[] 来释放内存。\n四、unique_ptr 的成员函数与操作 operator* 和 operator-\u0026gt;\n1 2 *ptr; // 解引用，访问对象 ptr-\u0026gt;func(); // 通过指针访问成员函数 get()\n返回所管理对象的原始指针。\n1 AA* raw_ptr = ptr.get(); release()\n释放所有权，返回原始指针，unique_ptr 置为空。\n1 AA* raw_ptr = ptr.release(); // 需要手动 delete raw_ptr reset()\n重置 unique_ptr，释放当前对象并接管新对象。\n1 2 ptr.reset(new AA(\u0026#34;新对象\u0026#34;)); ptr.reset(); // 释放对象，置为空 swap()\n交换两个 unique_ptr 所管理的对象。\n1 ptr1.swap(ptr2); 五、示例代码解析 5.1 示例一：unique_ptr 在函数中的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; class AA { public: string m_name; AA(const string\u0026amp; name) : m_name(name) { cout \u0026lt;\u0026lt; \u0026#34;构造函数 AA(\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;) 被调用。\\n\u0026#34;; } ~AA() { cout \u0026lt;\u0026lt; \u0026#34;析构函数 ~AA(\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;) 被调用。\\n\u0026#34;; } }; // 函数需要一个原始指针，不负责释放 void func1(const AA* a) { cout \u0026lt;\u0026lt; \u0026#34;func1: \u0026#34; \u0026lt;\u0026lt; a-\u0026gt;m_name \u0026lt;\u0026lt; endl; } // 函数需要一个原始指针，负责释放 void func2(AA* a) { cout \u0026lt;\u0026lt; \u0026#34;func2: \u0026#34; \u0026lt;\u0026lt; a-\u0026gt;m_name \u0026lt;\u0026lt; endl; delete a; } // 函数需要一个 unique_ptr 引用，不负责释放 void func3(const unique_ptr\u0026lt;AA\u0026gt;\u0026amp; a) { cout \u0026lt;\u0026lt; \u0026#34;func3: \u0026#34; \u0026lt;\u0026lt; a-\u0026gt;m_name \u0026lt;\u0026lt; endl; } // 函数需要一个 unique_ptr，负责释放（转移所有权） void func4(unique_ptr\u0026lt;AA\u0026gt; a) { cout \u0026lt;\u0026lt; \u0026#34;func4: \u0026#34; \u0026lt;\u0026lt; a-\u0026gt;m_name \u0026lt;\u0026lt; endl; } int main() { unique_ptr\u0026lt;AA\u0026gt; pu = make_unique\u0026lt;AA\u0026gt;(\u0026#34;西施\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;开始调用函数。\\n\u0026#34;; // func1(pu.get()); // 传递原始指针，不负责释放 // func2(pu.release()); // 传递原始指针，负责释放，pu 被置空 // func3(pu); // 传递引用，不转移所有权 func4(move(pu)); // 转移所有权，pu 被置空 cout \u0026lt;\u0026lt; \u0026#34;调用函数完成。\\n\u0026#34;; if (!pu) cout \u0026lt;\u0026lt; \u0026#34;pu 是空指针。\\n\u0026#34;; return 0; } 运行结果：\n1 2 3 4 5 6 构造函数 AA(西施) 被调用。 开始调用函数。 func4: 西施 析构函数 ~AA(西施) 被调用。 调用函数完成。 pu 是空指针。 解析：\n使用 make_unique 创建一个 unique_ptr，指向对象 \u0026ldquo;西施\u0026rdquo;。 调用 func4，通过 move 转移所有权，pu 被置空。 函数结束后，func4 内的 unique_ptr 被销毁，自动调用析构函数。 5.2 示例二：使用 unique_ptr 管理数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; class AA { public: string m_name; AA() { cout \u0026lt;\u0026lt; \u0026#34;默认构造函数 AA() 被调用。\\n\u0026#34;; } AA(const string\u0026amp; name) : m_name(name) { cout \u0026lt;\u0026lt; \u0026#34;构造函数 AA(\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;) 被调用。\\n\u0026#34;; } ~AA() { cout \u0026lt;\u0026lt; \u0026#34;析构函数 ~AA(\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;) 被调用。\\n\u0026#34;; } }; int main() { // 使用 unique_ptr 管理动态数组 unique_ptr\u0026lt;AA[]\u0026gt; parr(new AA[2]); parr[0].m_name = \u0026#34;西施\u0026#34;; parr[1].m_name = \u0026#34;貂蝉\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;parr[0]: \u0026#34; \u0026lt;\u0026lt; parr[0].m_name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;parr[1]: \u0026#34; \u0026lt;\u0026lt; parr[1].m_name \u0026lt;\u0026lt; endl; // 无需手动 delete，unique_ptr 会自动释放内存 return 0; } 运行结果：\n1 2 3 4 5 6 默认构造函数 AA() 被调用。 默认构造函数 AA() 被调用。 parr[0]: 西施 parr[1]: 貂蝉 析构函数 ~AA() 被调用。 析构函数 ~AA() 被调用。 解析：\n创建一个 unique_ptr\u0026lt;AA[]\u0026gt;，管理一个大小为 2 的 AA 数组。 通过下标操作赋值和访问数组元素。 程序结束时，unique_ptr 自动调用 delete[] 释放内存。 六、注意事项与最佳实践 禁止复制操作\nunique_ptr 禁止复制构造和复制赋值，确保独占所有权。\n慎用原始指针初始化\n避免使用同一个原始指针初始化多个 unique_ptr，会导致多次释放同一内存。\n不要管理非动态分配的内存\nunique_ptr 应该只管理通过 new 分配的内存，不要用于栈内存或其他方式分配的内存。\n转移所有权时使用 std::move\n当需要将 unique_ptr 作为函数参数并转移所有权时，使用 std::move。\n管理数组时使用特化版本\n使用 unique_ptr\u0026lt;T[]\u0026gt; 来管理动态数组，支持下标操作符。\n自定义删除器\n如果需要自定义资源释放方式，可以在 unique_ptr 中指定自定义删除器。\n避免空悬指针\n当 unique_ptr 被销毁或转移所有权后，应避免再次使用。\n七、总结 unique_ptr 是现代 C++ 中管理动态内存的首选工具之一。通过独占式的所有权模型和对移动语义的支持，unique_ptr 提供了高效、安全的资源管理方式。在实际编程中，合理使用 unique_ptr，可以显著减少内存泄漏和空悬指针等问题，提高代码的可靠性和可维护性。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B9%8Bunique_ptr/","summary":"随着 C++11 标准的引入，智能指针成为了现代 C++ 编程中资源管理的核心工具。其中，unique_ptr 是一种独占式的智能指针，负责管理动态分配的对象，确","title":"智能指针之unique_ptr"},{"content":"\rC++11 引入了 可变参数模板（Variadic Templates），这是该标准新增的最强大和最灵活的特性之一。可变参数模板允许函数和类模板接受任意数量的模板参数，使得编写泛型代码更加简洁和高效。\n一、什么是可变参数模板 可变参数模板 是一种特殊的模板，它可以接受 任意数量 的模板参数，包括零个。可变参数模板可以应用于函数模板和类模板，使得编写通用、灵活的代码成为可能。\n优势：\n泛化参数：支持任意类型、任意数量的参数。 代码简洁：避免了编写大量的重载函数或特化模板。 高效灵活：能够根据需要展开参数，实现复杂的逻辑。 二、可变参数模板的语法 可变参数模板使用 模板参数包（Template Parameter Pack） 和 函数参数包（Function Parameter Pack） 来表示可变数量的模板参数和函数参数。\n模板参数包语法：\n1 template\u0026lt;typename... Args\u0026gt; Args... 表示一个模板参数包，可以包含零个或多个模板参数。 函数参数包语法：\n1 void function(Args... args) args... 表示一个函数参数包，对应于模板参数包中的每个类型。 示例：\n1 2 3 4 template\u0026lt;typename... Args\u0026gt; void func(Args... args) { // 函数体 } 三、递归展开参数包 在使用可变参数模板时，常常需要 递归地展开参数包，即通过递归调用，将参数包中的每个参数逐一处理。\n基本思想：\n基例（Base Case）：定义一个非模板函数，作为递归终止条件。 递归（Recursive Case）：定义一个模板函数，每次处理一个参数，然后对剩余参数递归调用。 递归展开示意图：\n1 2 3 4 5 print(arg1, arg2, arg3) -\u0026gt; print(arg1), print(arg2, arg3) -\u0026gt; print(arg2), print(arg3) -\u0026gt; print(arg3), print() -\u0026gt; 递归终止 四、示例代码解析 下面我们通过一个完整的示例，详细解析可变参数模板的使用方法和递归展开过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; // 函数模板，用于向特定对象表白 template \u0026lt;typename T\u0026gt; void show(T girl) { cout \u0026lt;\u0026lt; \u0026#34;亲爱的 \u0026#34; \u0026lt;\u0026lt; girl \u0026lt;\u0026lt; \u0026#34;，我是一只傻傻鸟。\\n\u0026#34;; } // 递归终止条件的非模板函数 void print() { cout \u0026lt;\u0026lt; \u0026#34;递归终止。\\n\u0026#34;; } // 递归展开参数包的函数模板 template \u0026lt;typename T, typename... Args\u0026gt; void print(T arg, Args... args) { show(arg); // 处理当前参数 print(args...); // 递归处理剩余参数 } // 包含可变参数的函数模板，可以接受其他常规参数 template \u0026lt;typename... Args\u0026gt; void func(const string\u0026amp; str, Args... args) { cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; // 输出口号 print(args...); // 展开并处理参数包 cout \u0026lt;\u0026lt; \u0026#34;表白完成。\\n\u0026#34;; } int main() { func(\u0026#34;我是绝世帅哥。\u0026#34;, \u0026#34;冰冰\u0026#34;, 8, \u0026#34;西施\u0026#34;, 3); return 0; } 4.1 函数模板 show 1 2 3 4 template \u0026lt;typename T\u0026gt; void show(T girl) { cout \u0026lt;\u0026lt; \u0026#34;亲爱的 \u0026#34; \u0026lt;\u0026lt; girl \u0026lt;\u0026lt; \u0026#34;，我是一只傻傻鸟。\\n\u0026#34;; } 作用：接受一个参数 girl，输出表白信息。 模板参数：T，用于支持任意类型的参数，例如字符串、整数等。 示例调用：show(\u0026quot;冰冰\u0026quot;); 或 show(8); 4.2 非模板函数 print() 1 2 3 void print() { cout \u0026lt;\u0026lt; \u0026#34;递归终止。\\n\u0026#34;; } 作用：递归终止条件，当参数包为空时调用。 特点：函数名与递归函数模板相同，但没有参数。 4.3 函数模板 print 1 2 3 4 5 template \u0026lt;typename T, typename... Args\u0026gt; void print(T arg, Args... args) { show(arg); // 处理当前参数 print(args...); // 递归处理剩余参数 } 模板参数： T：当前处理的参数类型。 Args...：剩余参数包。 函数参数： T arg：当前处理的参数值。 Args... args：剩余参数包。 实现逻辑： 调用 show(arg)，处理当前参数。 递归调用 print(args...)，处理剩余参数。 4.4 函数模板 func 1 2 3 4 5 6 template \u0026lt;typename... Args\u0026gt; void func(const string\u0026amp; str, Args... args) { cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; // 输出口号 print(args...); // 展开并处理参数包 cout \u0026lt;\u0026lt; \u0026#34;表白完成。\\n\u0026#34;; } 模板参数：Args...，可变参数包。 函数参数： const string\u0026amp; str：常规参数，表示口号或前置信息。 Args... args：可变参数包，将被传递给 print 函数。 实现逻辑： 输出 str。 调用 print(args...)，展开参数包并处理。 输出 \u0026ldquo;表白完成。\u0026rdquo; 4.5 main 函数 1 2 3 4 int main() { func(\u0026#34;我是绝世帅哥。\u0026#34;, \u0026#34;冰冰\u0026#34;, 8, \u0026#34;西施\u0026#34;, 3); return 0; } 调用 func： \u0026quot;我是绝世帅哥。\u0026quot;：常规参数 str。 \u0026quot;冰冰\u0026quot;, 8, \u0026quot;西施\u0026quot;, 3：可变参数包 args...。 执行过程： 输出口号：\u0026ldquo;我是绝世帅哥。\u0026rdquo; 展开并处理参数包： 第一次递归：arg = \u0026quot;冰冰\u0026quot;, args... = {8, \u0026quot;西施\u0026quot;, 3} 第二次递归：arg = 8, args... = {\u0026quot;西施\u0026quot;, 3} 第三次递归：arg = \u0026quot;西施\u0026quot;, args... = {3} 第四次递归：arg = 3, args... = {} 第五次递归：参数包为空，调用非模板函数 print() 输出 \u0026ldquo;表白完成。\u0026rdquo; 运行结果：\n1 2 3 4 5 6 7 我是绝世帅哥。 亲爱的 冰冰，我是一只傻傻鸟。 亲爱的 8，我是一只傻傻鸟。 亲爱的 西施，我是一只傻傻鸟。 亲爱的 3，我是一只傻傻鸟。 递归终止。 表白完成。 五、可变参数模板的应用场景 5.1 日志系统 可变参数模板可以用于实现灵活的日志函数，支持任意数量和类型的参数。\n1 2 3 4 template\u0026lt;typename... Args\u0026gt; void log(const Args\u0026amp;... args) { (cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; args) \u0026lt;\u0026lt; endl; // C++17 的折叠表达式 } 5.2 智能指针的构造 std::make_shared 和 std::make_unique 使用可变参数模板，能够传递任意数量的构造函数参数。\n1 2 3 4 template\u0026lt;typename T, typename... Args\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; make_shared(Args\u0026amp;\u0026amp;... args) { return std::shared_ptr\u0026lt;T\u0026gt;(new T(std::forward\u0026lt;Args\u0026gt;(args)...)); } 5.3 库函数的包装 可变参数模板可以用于包装库函数，提供额外的功能，如计时、日志等。\n1 2 3 4 5 6 7 8 template\u0026lt;typename Func, typename... Args\u0026gt; auto measure_time(Func\u0026amp;\u0026amp; func, Args\u0026amp;\u0026amp;... args) { auto start = std::chrono::high_resolution_clock::now(); auto result = func(std::forward\u0026lt;Args\u0026gt;(args)...); auto end = std::chrono::high_resolution_clock::now(); cout \u0026lt;\u0026lt; \u0026#34;函数执行时间: \u0026#34; \u0026lt;\u0026lt; (end - start).count() \u0026lt;\u0026lt; \u0026#34; 纳秒\u0026#34; \u0026lt;\u0026lt; endl; return result; } 六、注意事项和最佳实践 6.1 递归终止条件 必须提供递归终止条件，通常是参数包为空时的非模板函数。 避免无限递归，确保递归过程能够正确结束。 6.2 参数传递方式 可以使用 参数传递方式 来优化性能，如按值传递、按引用传递、转发引用等。 如果参数类型未知，使用 转发引用（Forwarding Reference） 更为通用。 1 2 3 4 template\u0026lt;typename T\u0026gt; void func(T\u0026amp;\u0026amp; arg) { // 使用 std::forward\u0026lt;T\u0026gt;(arg) 转发参数 } 6.3 使用折叠表达式（C++17 引入） 在 C++17 中，可以使用 折叠表达式 来简化参数包的展开过程。*\n1 2 3 4 template\u0026lt;typename... Args\u0026gt; void print_all(const Args\u0026amp;... args) { (cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; args) \u0026lt;\u0026lt; endl; } 6.4 防止参数包展开顺序问题 在递归展开时，注意参数的处理顺序，确保逻辑正确。 可以使用 初始化列表 或 折叠表达式 控制顺序。 七、总结 可变参数模板是 C++11 引入的强大特性，极大地增强了模板的灵活性和泛型编程能力。通过使用模板参数包和函数参数包，我们可以编写接受任意数量和类型参数的模板函数或类。递归展开参数包是处理可变参数的常用方法，需要注意递归终止条件和参数传递方式。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/","summary":"C++11 引入了 可变参数模板（Variadic Templates），这是该标准新增的最强大和最灵活的特性之一。可变参数模板允许函数和类模板接受任意数","title":"可变参数模板"},{"content":"\r完美转发（Perfect Forwarding）是 C++11 一个重要的特性，允许函数模板将参数 完美地 转发给其它函数。这意味着不仅能够准确地传递参数的值，还能保持被转发参数的左值或右值属性不变，从而避免不必要的拷贝或移动操作。\n一、什么是完美转发 完美转发 是指在函数模板中，将参数传递给另一个函数时，能够 完美地保持 参数的值类别（左值或右值）和类型，从而确保被调用函数接收到的参数与原始参数完全一致。\n完美转发解决了以下问题：\n保持参数的左值或右值属性：防止在转发过程中丢失参数的值类别，避免额外的拷贝或移动操作。 通用性：使函数模板能够处理各种类型的参数，包括左值、右值、常量、非常量等。 二、左值、右值与右值引用 在深入讨论完美转发之前，先回顾一下 左值（lvalue）、右值（rvalue） 和 右值引用（rvalue reference） 的概念。\n2.1 左值（Lvalue）和右值（Rvalue） 左值（Lvalue）：表示具有 持久存储 的对象，可以获取其地址。通常是变量、数组元素、对象成员等。 右值（Rvalue）：表示 临时对象 或 值，在表达式结束后就不再存在。通常是字面量、临时对象、表达式的结果等。 2.2 右值引用（Rvalue Reference） C++11 引入了 右值引用，语法为 Type\u0026amp;\u0026amp;，用于引用右值。\n特点：\n只能绑定右值：右值引用只能绑定到右值（临时对象）。 支持移动语义：通过右值引用，可以实现移动构造和移动赋值，避免不必要的拷贝。 2.3 引用折叠规则 在模板中使用引用时，可能会发生 引用折叠。引用折叠遵循以下规则：\n\u0026amp; \u0026amp; 折叠为 \u0026amp; \u0026amp; \u0026amp;\u0026amp; 折叠为 \u0026amp; \u0026amp;\u0026amp; \u0026amp; 折叠为 \u0026amp; \u0026amp;\u0026amp; \u0026amp;\u0026amp; 折叠为 \u0026amp;\u0026amp; 三、模板参数的引用折叠 在函数模板中，使用 模板类型参数的右值引用，可以实现对参数的 完美捕获，既能接受左值，又能接受右值。\n3.1 万能引用（Universal Reference） 当函数模板的参数形式为 T\u0026amp;\u0026amp;，并且 T 是一个模板类型参数时，T\u0026amp;\u0026amp; 被称为 万能引用（Universal Reference）。\n特点：\n万能引用 可以同时绑定左值和右值。 实际引用类型取决于模板参数的类型推导结果。 3.2 引用折叠示例 1 2 template\u0026lt;typename T\u0026gt; void func(T\u0026amp;\u0026amp; param); 如果传入左值 lvalue，则 T 被推导为 Lvalue\u0026amp;，T\u0026amp;\u0026amp; 经过引用折叠后为 Lvalue\u0026amp;。 如果传入右值 rvalue，则 T 被推导为 Rvalue，T\u0026amp;\u0026amp; 保持为 Rvalue\u0026amp;\u0026amp;。 四、实现完美转发的方法 要在函数模板中实现完美转发，需要满足以下两个条件：\n参数类型声明为万能引用：template\u0026lt;typename T\u0026gt; void func(T\u0026amp;\u0026amp; param); 使用 std::forward 转发参数：std::forward\u0026lt;T\u0026gt;(param); 五、std::forward 的作用 std::forward 是一个函数模板，用于保持参数的值类别（左值或右值），将参数完美地转发给另一个函数。\n5.1 std::forward 的实现 std::forward 的基本实现如下：\n1 2 3 4 template\u0026lt;typename T\u0026gt; T\u0026amp;\u0026amp; forward(typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp; param) noexcept { return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(param); } 5.2 使用 std::forward 的原因 保持值类别：std::forward 能够根据模板参数 T 的类型，决定是否将参数转化为左值引用或右值引用。 避免不必要的拷贝或移动：确保被调用函数接收到的参数与原始参数一致，避免性能损失。 六、示例代码解析 下面通过一个示例来具体说明如何实现完美转发。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; // 包含 std::forward void func1(int\u0026amp; ii) { // 接受左值引用 std::cout \u0026lt;\u0026lt; \u0026#34;参数是左值：\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; std::endl; } void func1(int\u0026amp;\u0026amp; ii) { // 接受右值引用 std::cout \u0026lt;\u0026lt; \u0026#34;参数是右值：\u0026#34; \u0026lt;\u0026lt; ii \u0026lt;\u0026lt; std::endl; } template\u0026lt;typename T\u0026gt; void func(T\u0026amp;\u0026amp; ii) { func1(std::forward\u0026lt;T\u0026gt;(ii)); } int main() { int ii = 3; func(ii); // 实参是左值 func(8); // 实参是右值 return 0; } 6.1 代码分析 func1 函数重载：\nvoid func1(int\u0026amp; ii)：接受左值引用。 void func1(int\u0026amp;\u0026amp; ii)：接受右值引用。 模板函数 func：\n模板参数为 T，函数参数为 T\u0026amp;\u0026amp; ii，即万能引用。 使用 std::forward\u0026lt;T\u0026gt;(ii) 将参数转发给 func1。 main 函数：\n定义了一个左值 int ii = 3;。 调用 func(ii);，ii 为左值。 T 被推导为 int\u0026amp;，T\u0026amp;\u0026amp; 经过引用折叠为 int\u0026amp;。 std::forward\u0026lt;int\u0026amp;\u0026gt;(ii) 返回 int\u0026amp;，保持左值属性。 调用 func1(int\u0026amp; ii)，输出 \u0026ldquo;参数是左值：3\u0026rdquo;。 调用 func(8);，8 为右值。 T 被推导为 int，T\u0026amp;\u0026amp; 为 int\u0026amp;\u0026amp;。 std::forward\u0026lt;int\u0026gt;(ii) 返回 int\u0026amp;\u0026amp;，保持右值属性。 调用 func1(int\u0026amp;\u0026amp; ii)，输出 \u0026ldquo;参数是右值：8\u0026rdquo;。 6.2 运行结果 1 2 参数是左值：3 参数是右值：8 七、完美转发的应用场景 7.1 通用的工厂函数 在编写通用的工厂函数时，完美转发可以避免不必要的拷贝或移动。\n1 2 3 4 template\u0026lt;typename T, typename... Args\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; make_shared_ptr(Args\u0026amp;\u0026amp;... args) { return std::shared_ptr\u0026lt;T\u0026gt;(new T(std::forward\u0026lt;Args\u0026gt;(args)...)); } 7.2 适配器模式 在实现函数适配器时，完美转发可以确保参数的值类别不变。\n1 2 3 4 template\u0026lt;typename Func, typename... Args\u0026gt; auto wrapper(Func\u0026amp;\u0026amp; func, Args\u0026amp;\u0026amp;... args) { return func(std::forward\u0026lt;Args\u0026gt;(args)...); } 八、注意事项和最佳实践 8.1 仅在万能引用中使用 std::forward std::forward 应该只在参数类型为万能引用时使用。 不要滥用 std::forward，否则可能导致意外的行为。 8.2 避免重复使用被转发的参数 被 std::forward 转发的参数在转发后应避免再次使用，特别是当参数为右值时。 8.3 理解引用折叠 理解引用折叠规则对于正确使用万能引用和完美转发至关重要。 8.4 区分左值引用和右值引用 在模板编程中，清楚地区分左值引用、右值引用和万能引用，避免混淆。 九、总结 完美转发是 C++11 中引入的强大特性，使得函数模板能够完美地转发参数，保持参数的值类别和类型不变。通过使用万能引用和 std::forward，我们可以编写高效、通用的模板函数，避免不必要的拷贝和移动操作。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/","summary":"完美转发（Perfect Forwarding）是 C++11 一个重要的特性，允许函数模板将参数 完美地 转发给其它函数。这意味着不仅能够准确地传递参数的值","title":"完美转发"},{"content":"\r我们要知道，在 C++98 中，如果一个类包含 堆资源（例如动态分配的内存、文件句柄等），为了管理这些资源，需要手动编写 拷贝构造函数 和 赋值运算符，以实现 深拷贝。然而，深拷贝会带来性能开销，尤其是在处理临时对象时，可能导致不必要的资源申请和释放。为了解决这个问题，C++11 引入了 移动语义，允许我们高效地转移资源的所有权，避免不必要的拷贝操作。\n一、为什么需要移动语义 1.1 深拷贝的代价 在传统的 C++98 中，如果一个类拥有指向堆内存的指针，需要实现深拷贝以避免 浅拷贝 带来的问题（如多次释放同一内存）。深拷贝会为每个对象创建自己独立的资源副本。\n缺点：\n性能开销大：深拷贝涉及内存分配和数据复制，耗费时间和资源。 资源浪费：对于临时对象，拷贝后立即销毁，导致资源的申请和释放没有实际意义。 1.2 移动语义的引入 C++11 引入了 移动语义（Move Semantics），允许对象的资源所有权在不发生深拷贝的情况下从一个对象转移到另一个对象。这对于临时对象尤为有用，因为临时对象在表达式结束后会被销毁，转移其资源可以避免不必要的拷贝。\n优势：\n提高性能：避免了深拷贝的开销。 资源高效利用：直接使用源对象的资源，无需重新分配。 二、左值、右值与右值引用 2.1 左值（Lvalue）与右值（Rvalue） 左值（Lvalue）：表示具名的、可持久存储的对象，可以取地址（\u0026amp;）。通常是变量、数组元素、对象成员等。 右值（Rvalue）：表示临时的、不可持久存储的值，通常是字面量、表达式计算结果、匿名对象等。 判断方法：\n能否取地址：能取地址的是左值，不能的是右值。 是否具名：具名对象通常是左值。 2.2 右值引用（Rvalue Reference） C++11 引入了 右值引用，语法为 Type\u0026amp;\u0026amp;，用于引用右值（临时对象）。\n特点：\n只能绑定右值：右值引用只能绑定到右值。 延长对象生命周期：右值引用可延长临时对象的生命周期。 支持移动语义：通过右值引用，可以实现移动构造和移动赋值。 1 int\u0026amp;\u0026amp; rvalue_ref = 42; // 42 是右值 2.3 std::move() 的作用 std::move() 是一个标准库函数，用于将 左值 转换为 右值引用，指示对象可以被移动。\n1 2 3 #include \u0026lt;utility\u0026gt; Type\u0026amp;\u0026amp; rref = std::move(lvalue); 注意：\n使用 std::move() 后，源对象仍然存在，但其资源可能已被转移，需谨慎使用。 std::move() 并不移动对象，它只是进行类型转换。 三、移动构造函数与移动赋值运算符 为了实现移动语义，需要在类中定义 移动构造函数 和 移动赋值运算符。\n3.1 移动构造函数 1 ClassName(ClassName\u0026amp;\u0026amp; source); 实现要点：\n参数为 右值引用，接受一个临时对象。 转移资源所有权：将源对象的资源指针赋值给当前对象。 置空源对象的指针：防止源对象在析构时释放资源。 不进行深拷贝：避免性能开销。 1 2 3 4 ClassName(ClassName\u0026amp;\u0026amp; source) { this-\u0026gt;ptr = source.ptr; source.ptr = nullptr; } 3.2 移动赋值运算符 1 ClassName\u0026amp; operator=(ClassName\u0026amp;\u0026amp; source); 实现要点：\n检查 自我赋值，避免错误。 释放当前对象的资源，防止内存泄漏。 转移资源所有权：将源对象的资源指针赋值给当前对象。 置空源对象的指针。 1 2 3 4 5 6 7 8 ClassName\u0026amp; operator=(ClassName\u0026amp;\u0026amp; source) { if (this != \u0026amp;source) { delete this-\u0026gt;ptr; this-\u0026gt;ptr = source.ptr; source.ptr = nullptr; } return *this; } 注意事项 异常安全：移动操作应确保异常安全，推荐在函数后加上 noexcept。 自我赋值检查：防止对象与自身进行移动赋值。 资源管理：移动后源对象应处于可析构的安全状态。 四、实现移动语义的注意事项 4.1 使用 std::move() 将左值转换为右值引用 对于一些左值（如局部变量），其生命周期很短，使用移动语义可以提高性能。std::move() 可以将左值转换为右值引用，使其能够调用移动构造函数或移动赋值运算符。\n1 2 ClassName obj1; ClassName obj2 = std::move(obj1); // 调用移动构造函数 注意：\n经过 std::move() 转换后，源对象的资源可能已被转移，应避免再使用。 源对象在离开作用域时才会析构。 4.2 提供拷贝和移动操作的配套实现 如果类中提供了 拷贝构造函数 或 拷贝赋值运算符，而没有提供对应的 移动构造函数 或 移动赋值运算符，编译器不会为其生成默认的移动操作。因此，为了充分利用移动语义，应为类提供完整的拷贝和移动操作实现。\n4.3 标准库容器的移动语义支持 C++11 中的所有标准库容器（如 std::vector、std::string 等）都实现了移动语义，能够高效地处理含有资源的对象，避免无谓的拷贝。\n4.4 移动语义对基本类型无效 对于基本类型（如 int、double），移动和拷贝的代价相同，使用移动语义没有意义。移动语义主要适用于拥有资源的对象。\n五、示例代码解析 下面通过一个完整的示例，展示如何在类中实现移动语义，以及移动语义带来的性能提升。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; // 包含 memset 和 memcpy class AA { public: int* m_data = nullptr; // 指向堆区资源的指针 // 默认构造函数 AA() = default; // 分配内存 void alloc() { m_data = new int; memset(m_data, 0, sizeof(int)); } // 拷贝构造函数（深拷贝） AA(const AA\u0026amp; a) { std::cout \u0026lt;\u0026lt; \u0026#34;调用了拷贝构造函数。\\n\u0026#34;; if (a.m_data) { m_data = new int; memcpy(m_data, a.m_data, sizeof(int)); } } // 移动构造函数 AA(AA\u0026amp;\u0026amp; a) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;调用了移动构造函数。\\n\u0026#34;; m_data = a.m_data; a.m_data = nullptr; } // 拷贝赋值运算符（深拷贝） AA\u0026amp; operator=(const AA\u0026amp; a) { std::cout \u0026lt;\u0026lt; \u0026#34;调用了赋值运算符。\\n\u0026#34;; if (this != \u0026amp;a) { if (m_data) delete m_data; if (a.m_data) { m_data = new int; memcpy(m_data, a.m_data, sizeof(int)); } else { m_data = nullptr; } } return *this; } // 移动赋值运算符 AA\u0026amp; operator=(AA\u0026amp;\u0026amp; a) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;调用了移动赋值运算符。\\n\u0026#34;; if (this != \u0026amp;a) { if (m_data) delete m_data; m_data = a.m_data; a.m_data = nullptr; } return *this; } // 析构函数 ~AA() { if (m_data) { delete m_data; m_data = nullptr; } } }; int main() { AA a1; // 创建对象 a1 a1.alloc(); // 分配堆区资源 *a1.m_data = 3; // 赋值 std::cout \u0026lt;\u0026lt; \u0026#34;a1.m_data = \u0026#34; \u0026lt;\u0026lt; *a1.m_data \u0026lt;\u0026lt; std::endl; AA a2 = a1; // 调用拷贝构造函数 std::cout \u0026lt;\u0026lt; \u0026#34;a2.m_data = \u0026#34; \u0026lt;\u0026lt; *a2.m_data \u0026lt;\u0026lt; std::endl; AA a3; a3 = a1; // 调用赋值运算符 std::cout \u0026lt;\u0026lt; \u0026#34;a3.m_data = \u0026#34; \u0026lt;\u0026lt; *a3.m_data \u0026lt;\u0026lt; std::endl; // 返回 AA 对象的 lambda 函数 auto f = [] { AA aa; aa.alloc(); *aa.m_data = 8; return aa; // 返回临时对象（右值） }; AA a4 = f(); // 调用移动构造函数 std::cout \u0026lt;\u0026lt; \u0026#34;a4.m_data = \u0026#34; \u0026lt;\u0026lt; *a4.m_data \u0026lt;\u0026lt; std::endl; AA a5; a5 = f(); // 调用移动赋值运算符 std::cout \u0026lt;\u0026lt; \u0026#34;a5.m_data = \u0026#34; \u0026lt;\u0026lt; *a5.m_data \u0026lt;\u0026lt; std::endl; return 0; } 代码解析 类 AA 的定义\n成员变量：int* m_data，指向堆区资源的指针。 构造函数： 默认构造函数 AA()：使用 = default，编译器生成默认实现。 拷贝构造函数 AA(const AA\u0026amp; a)：实现深拷贝，分配新内存并复制数据。 移动构造函数 AA(AA\u0026amp;\u0026amp; a) noexcept：转移资源所有权，置空源对象指针。 赋值运算符： 拷贝赋值运算符 operator=(const AA\u0026amp; a)：实现深拷贝，注意自我赋值检查和释放旧资源。 移动赋值运算符 operator=(AA\u0026amp;\u0026amp; a) noexcept：转移资源，释放旧资源，置空源对象指针。 析构函数：释放堆区资源，防止内存泄漏。 main 函数\n创建对象 a1 并分配资源，赋值 3。 拷贝构造 a2：AA a2 = a1;，调用拷贝构造函数，深拷贝资源。 赋值操作 a3：a3 = a1;，调用赋值运算符，深拷贝资源。 移动构造 a4： f() 返回一个临时对象（右值）。 AA a4 = f(); 调用移动构造函数，转移资源，无需分配新内存。 移动赋值 a5： a5 = f();，调用移动赋值运算符，转移资源，释放旧资源。 运行结果 1 2 3 4 5 6 7 8 9 a1.m_data = 3 调用了拷贝构造函数。 a2.m_data = 3 调用了赋值运算符。 a3.m_data = 3 调用了移动构造函数。 a4.m_data = 8 调用了移动赋值运算符。 a5.m_data = 8 说明 拷贝构造函数和赋值运算符在处理 a1 时被调用，进行了深拷贝。 移动构造函数在处理 a4 时被调用，直接转移资源，无需分配内存。 移动赋值运算符在处理 a5 时被调用，释放旧资源，转移新资源。 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/","summary":"我们要知道，在 C++98 中，如果一个类包含 堆资源（例如动态分配的内存、文件句柄等），为了管理这些资源，需要手动编写 拷贝构造函数 和 赋值运算符，以实现 深","title":"移动语义"},{"content":"\r自上次撰写相关内容，我也算是有了一段实际的应用经验。现在，回头再次分析相关内容，有了更深的感悟。今儿个，我们再次探究一下左值、右值与引用等相关内容。\n一、左值与右值的基本概念 1.1 什么是左值（lvalue）和右值（rvalue） 左值（lvalue）：表示具有持久存储的对象，可以获取其地址。通常是命名变量、数组元素、类成员等，可以出现在赋值语句的左侧。\n右值（rvalue）：表示不具有持久存储的临时对象或值，通常是字面量、临时对象、表达式的结果等，不能获取其地址，通常只能出现在赋值语句的右侧。\n1.2 判断左值和右值的简单方法 能否取地址：如果可以对表达式取地址（\u0026amp;expr），则为左值；否则为右值。 是否具名：具名对象通常为左值，匿名的临时对象为右值。 1.3 示例 1 2 int x = 5; // x 是左值，5 是右值 int y = x + 3; // y 是左值，x + 3 是右值 二、C++11 中的值类别扩展 C++11 对值类别进行了重新分类，引入了新的概念，使得表达式的分类更加精确。这些值类别包括：\n左值（lvalue） 亡值（xvalue，eXpiring value） 纯右值（prvalue，Pure rvalue） 泛左值（glvalue，Generalized lvalue） 右值（rvalue） 2.1 新的值类别定义 左值（lvalue）：表示标识实体的表达式，可以获取对象的身份（地址）。通常是具名变量或可持久化的存储。\n亡值（xvalue）：表示即将被移动的对象，资源可以被重用，但仍然具有对象的身份。例如，函数返回的右值引用。\n纯右值（prvalue）：表示不具有身份的纯值，用于初始化对象或计算表达式结果。例如，字面量、临时对象、算术表达式的结果。\n泛左值（glvalue）：左值和亡值的统称，表示具有对象身份的表达式。\n右值（rvalue）：纯右值和亡值的统称，表示没有特定存储的值或即将被移动的对象。\n2.2 值类别之间的关系 值类别之间的关系可以用以下关系图表示：\n1 2 3 4 5 6 7 8 9 表达式（Expressions） | +------------+------------+ | | glvalue rvalue | | +-----+-----+ +---+---+ | | | | lvalue xvalue xvalue prvalue glvalue（泛左值）：包括 lvalue 和 xvalue rvalue（右值）：包括 xvalue 和 prvalue xvalue（亡值）：同时属于 glvalue 和 rvalue 2.3 值类别的含义 lvalue：具有持久存储，可以获取地址。典型的左值包括变量、函数、数组元素、解引用指针等。\nxvalue：表示资源可被重用的对象，即将被移动。典型的亡值包括函数返回的右值引用、std::move 的结果等。\nprvalue：不具有对象身份，仅表示一个值。典型的纯右值包括字面量、临时对象、算术表达式的结果等。\n2.4 示例 1 2 3 4 5 6 7 8 class MyClass {}; MyClass createObject() { return MyClass(); // 返回一个临时对象，属于纯右值（prvalue） } MyClass\u0026amp;\u0026amp; rref = MyClass(); // MyClass() 是纯右值（prvalue），绑定到右值引用 MyClass\u0026amp;\u0026amp; x = std::move(rref); // std::move(rref) 是亡值（xvalue） MyClass()：纯右值（prvalue） std::move(rref)：亡值（xvalue） 三、左值引用与右值引用 3.1 左值引用（Lvalue Reference） 语法：Type\u0026amp; ref_name; 绑定对象：只能绑定到左值。 用途：为左值创建别名，常用于参数传递和返回类型。 3.2 右值引用（Rvalue Reference） 语法：Type\u0026amp;\u0026amp; ref_name; 绑定对象：只能绑定到右值（包括纯右值和亡值）。 用途：捕获右值，以实现移动语义和完美转发。 3.3 引用的绑定规则 左值引用：只能绑定到左值。 右值引用：只能绑定到右值。 常量左值引用（const Type\u0026amp;）：可以绑定到左值和右值，包括临时对象和字面量。 3.4 示例 1 2 3 4 5 6 7 8 9 10 11 int x = 10; int\u0026amp; lref = x; // 左值引用，绑定到左值 x int\u0026amp;\u0026amp; rref = 20; // 右值引用，绑定到右值 20 const int\u0026amp; cref = x; // 常量左值引用，绑定到左值 x const int\u0026amp; cref2 = 30; // 常量左值引用，绑定到右值 30 // 错误示例： // int\u0026amp; lref2 = 20; // 错误，不能将左值引用绑定到右值 // int\u0026amp;\u0026amp; rref2 = x; // 错误，不能将右值引用绑定到左值 四、右值引用的用途：移动语义与完美转发 4.1 移动语义（Move Semantics） 目的：通过移动资源（如内存、文件句柄等），避免不必要的拷贝，提高程序性能。 实现：提供移动构造函数和移动赋值运算符，将资源从源对象转移到目标对象。 4.2 移动构造函数与移动赋值运算符 移动构造函数：\n1 MyClass(MyClass\u0026amp;\u0026amp; other) noexcept; 移动赋值运算符：\n1 MyClass\u0026amp; operator=(MyClass\u0026amp;\u0026amp; other) noexcept; 实现要点：在移动过程中，转移资源所有权，并将源对象置于可析构的安全状态。\n4.3 完美转发（Perfect Forwarding） 目的：在模板函数中，无论传入的是左值还是右值，都能保持其值类别，正确地转发给其他函数。\n实现：使用模板参数的右值引用和 std::forward。\n示例：\n1 2 3 4 template \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(Arg\u0026amp;\u0026amp; arg) { return std::make_shared\u0026lt;T\u0026gt;(std::forward\u0026lt;Arg\u0026gt;(arg)); } 五、常量左值引用的特殊性 5.1 常量左值引用可以绑定右值 特性：const Type\u0026amp; 可以绑定到左值和右值，包括临时对象和字面量。 作用：延长临时对象的生命周期，直到引用超出作用域。 5.2 示例 1 2 3 4 5 6 7 8 9 10 void printValue(const int\u0026amp; value) { std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } int main() { int x = 10; printValue(x); // 绑定左值 printValue(20); // 绑定右值 return 0; } 在上述示例中，printValue 函数的参数是 const int\u0026amp;，可以绑定到左值 x，也可以绑定到右值 20。 5.3 注意事项 不可修改：由于引用的是常量，无法在函数内部修改其值。 延长生命周期：绑定到右值时，临时对象的生命周期被延长到引用的作用域结束。 六、示例代码分析 6.1 捕获临时对象的右值引用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; class MyClass { public: MyClass() { std::cout \u0026lt;\u0026lt; \u0026#34;构造函数\\n\u0026#34;; } ~MyClass() { std::cout \u0026lt;\u0026lt; \u0026#34;析构函数\\n\u0026#34;; } }; MyClass createObject() { return MyClass(); // 返回临时对象，属于纯右值（prvalue） } int main() { MyClass\u0026amp;\u0026amp; rref = createObject(); // 右值引用，绑定到纯右值 std::cout \u0026lt;\u0026lt; \u0026#34;在 main 中\\n\u0026#34;; return 0; } 输出：\n1 2 3 构造函数 在 main 中 析构函数 分析：\ncreateObject() 返回一个临时对象（纯右值）。 使用右值引用 MyClass\u0026amp;\u0026amp; rref 绑定临时对象，延长其生命周期到 rref 作用域结束。 在 main 函数结束时，临时对象被析构。 6.2 移动构造函数的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; class MyVector { public: std::vector\u0026lt;int\u0026gt; data; MyVector() { std::cout \u0026lt;\u0026lt; \u0026#34;默认构造函数\\n\u0026#34;; } // 移动构造函数 MyVector(MyVector\u0026amp;\u0026amp; other) noexcept : data(std::move(other.data)) { std::cout \u0026lt;\u0026lt; \u0026#34;移动构造函数\\n\u0026#34;; } // 禁用拷贝构造函数 MyVector(const MyVector\u0026amp;) = delete; void addData(int value) { data.push_back(value); } }; MyVector createVector() { MyVector vec; vec.addData(1); vec.addData(2); return std::move(vec); // 显式调用 std::move，触发移动构造 } int main() { MyVector myVec = createVector(); std::cout \u0026lt;\u0026lt; \u0026#34;数据大小：\u0026#34; \u0026lt;\u0026lt; myVec.data.size() \u0026lt;\u0026lt; std::endl; return 0; } 输出：\n1 2 3 默认构造函数 移动构造函数 数据大小：2 分析：\ncreateVector() 中的 vec 是一个局部对象，返回时会触发移动构造函数，而不是拷贝构造函数（已被删除）。 通过移动语义，myVec 获得了 vec 的数据，避免了不必要的深拷贝，提高了效率。 七、总结 C++11 对值类别进行了重新定义和扩展，引入了 左值（lvalue）、亡值（xvalue）、纯右值（prvalue）、泛左值（glvalue） 和 右值（rvalue）。\n理解值类别之间的关系 对于正确使用右值引用、移动语义和完美转发非常重要。\n右值引用 使得我们可以捕获右值，实现资源的移动，避免不必要的拷贝。\n常量左值引用 的特殊性在于可以绑定到右值，延长临时对象的生命周期，但无法修改其值。\n移动语义和完美转发 是 C++11 中提高性能和泛型编程能力的重要特性。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8/","summary":"自上次撰写相关内容，我也算是有了一段实际的应用经验。现在，回头再次分析相关内容，有了更深的感悟。今儿个，我们再次探究一下左值、右值与引用等相","title":"左值、右值与引用"},{"content":"\r自 C++11 标准引入以来，Lambda 表达式（也称为匿名函数）已经成为现代 C++ 编程中不可或缺的一部分。它们提供了一种简洁而强大的方式来定义内联函数，特别适用于需要临时函数对象的场景，如算法库的使用。这次整理，我尽可能全面深入地探讨 C++ 中的 Lambda 表达式，包括其语法、特性、用法和实现原理。\n一、什么是 Lambda 表达式 Lambda 表达式是一种 匿名函数，可以在代码中定义并立即使用，而无需为其命名。这使得代码更加简洁和可读，特别是在需要将函数作为参数传递的情况下。\nLambda 表达式的特点 简洁性：无需定义额外的函数或函数对象类。 就近性：函数定义与使用地点接近，方便阅读和维护。 强大性：支持捕获外部变量，能够访问所在作用域的上下文。 基本语法 1 2 3 [capture list](parameter list) -\u0026gt; return type { function body }; capture list（捕获列表）：指定哪些外部变量可在 Lambda 表达式中使用，以及如何捕获。 parameter list（参数列表）：与普通函数的参数列表类似，指定传递给 Lambda 的参数。 return type（返回类型）：可选，使用尾置返回类型（trailing return type）语法。 function body（函数体）：Lambda 表达式的执行代码。 示例 1 2 3 [](const int\u0026amp; no) -\u0026gt; void { std::cout \u0026lt;\u0026lt; \u0026#34;编号 \u0026#34; \u0026lt;\u0026lt; no \u0026lt;\u0026lt; \u0026#34;: 你好，Lambda！\\n\u0026#34;; }; 二、Lambda 表达式的使用示例 让我们通过一个完整的示例来理解 Lambda 表达式的实际应用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; void show(const int\u0026amp; no) { std::cout \u0026lt;\u0026lt; \u0026#34;普通函数：编号 \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { std::vector\u0026lt;int\u0026gt; numbers = {1, 2, 3}; // 使用普通函数 std::for_each(numbers.begin(), numbers.end(), show); // 使用函数对象（仿函数） struct Functor { void operator()(int n) const { std::cout \u0026lt;\u0026lt; \u0026#34;仿函数：编号 \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; std::for_each(numbers.begin(), numbers.end(), Functor()); // 使用 Lambda 表达式 std::for_each(numbers.begin(), numbers.end(), [](int n) { std::cout \u0026lt;\u0026lt; \u0026#34;Lambda 表达式：编号 \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }); return 0; } 输出：\n1 2 3 4 5 6 7 8 9 普通函数：编号 1 普通函数：编号 2 普通函数：编号 3 仿函数：编号 1 仿函数：编号 2 仿函数：编号 3 Lambda 表达式：编号 1 Lambda 表达式：编号 2 Lambda 表达式：编号 3 三、Lambda 表达式的各个部分详解 3.1 捕获列表（Capture List） 捕获列表位于 [] 中，用于指定 Lambda 表达式可以访问的外部变量。\n捕获方式\n值捕获（By Value）：[a, b]，拷贝外部变量的值。 引用捕获（By Reference）：[\u0026amp;a, \u0026amp;b]，引用外部变量。 隐式捕获： 按值捕获所有外部变量：[=] 按引用捕获所有外部变量：[\u0026amp;] 混合捕获：[=, \u0026amp;a, \u0026amp;b] 或 [\u0026amp;, a, b] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int x = 10; int y = 20; // 值捕获 auto lambda_by_value = [x, y]() { // x 和 y 的值是在 Lambda 创建时拷贝的 std::cout \u0026lt;\u0026lt; \u0026#34;值捕获：x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; // 引用捕获 auto lambda_by_ref = [\u0026amp;x, \u0026amp;y]() { // x 和 y 是引用，指向原始变量 x += 10; y += 10; std::cout \u0026lt;\u0026lt; \u0026#34;引用捕获：x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; lambda_by_value(); // 输出：x = 10, y = 20 lambda_by_ref(); // 输出：x = 20, y = 30 std::cout \u0026lt;\u0026lt; \u0026#34;外部变量：x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 输出：x = 20, y = 30 注意：\n值捕获的变量在 Lambda 创建时被拷贝，后续对原始变量的修改不会影响 Lambda 内部的值。 引用捕获的变量，Lambda 内部的修改会影响外部变量。 3.2 参数列表（Parameter List） Lambda 表达式的参数列表与普通函数类似，但有以下几点需要注意：\n必须为每个参数命名：不能省略参数名。 不支持默认参数：无法为参数指定默认值。 不支持可变参数：无法使用 ... 可变参数列表。 1 2 3 4 5 auto sum = [](int a, int b) { return a + b; }; std::cout \u0026lt;\u0026lt; \u0026#34;Sum: \u0026#34; \u0026lt;\u0026lt; sum(3, 4) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 输出：Sum: 7 3.3 返回类型（Return Type） Lambda 表达式可以显式指定返回类型，使用尾置返回类型语法 -\u0026gt; return_type。如果省略，编译器会自动推导。\n1 2 3 4 5 6 7 8 9 // 编译器自动推导返回类型 auto multiply = [](int a, int b) { return a * b; }; // 显式指定返回类型为 double auto divide = [](int a, int b) -\u0026gt; double { return static_cast\u0026lt;double\u0026gt;(a) / b; }; 建议：\n对于复杂的返回类型或多种返回路径，显式指定返回类型以避免推导错误。 3.4 函数体（Function Body） 函数体包含 Lambda 表达式要执行的代码，与普通函数的函数体类似。\n1 2 3 4 5 auto greet = []() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, Lambda!\\n\u0026#34;; }; greet(); // 输出：Hello, Lambda! 四、捕获列表的深入解析 4.1 值捕获（By Value） 特性：捕获时拷贝变量的值，Lambda 内部的修改不会影响外部变量。 限制：默认情况下，Lambda 内部不能修改值捕获的变量（除非使用 mutable 关键字）。 1 2 3 4 5 6 7 8 9 int count = 0; auto increment = [count]() mutable { // 需要 mutable 才能修改值捕获的变量 count++; std::cout \u0026lt;\u0026lt; \u0026#34;内部 count = \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; increment(); // 输出：内部 count = 1 std::cout \u0026lt;\u0026lt; \u0026#34;外部 count = \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 输出：外部 count = 0 4.2 引用捕获（By Reference） 特性：捕获外部变量的引用，Lambda 内部的修改会影响外部变量。 注意：需要确保外部变量在 Lambda 表达式执行时仍然存在。 1 2 3 4 5 6 7 8 int count = 0; auto increment = [\u0026amp;count]() { count++; std::cout \u0026lt;\u0026lt; \u0026#34;内部 count = \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; increment(); // 输出：内部 count = 1 std::cout \u0026lt;\u0026lt; \u0026#34;外部 count = \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 输出：外部 count = 1 4.3 隐式捕获（Implicit Capture） 按值捕获所有外部变量：[=] 按引用捕获所有外部变量：[\u0026amp;] 1 2 3 4 5 6 7 8 9 10 11 int a = 5, b = 10; // 按值捕获所有变量 auto lambda_value = [=]() { std::cout \u0026lt;\u0026lt; \u0026#34;按值捕获：a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; // 按引用捕获所有变量 auto lambda_ref = [\u0026amp;]() { std::cout \u0026lt;\u0026lt; \u0026#34;按引用捕获：a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; 4.4 混合捕获（Mixed Capture） 格式：[default_capture, variable_list] 规则：默认捕获方式和显式捕获方式不能对同一变量使用。 1 2 3 4 5 6 7 8 9 int x = 1, y = 2, z = 3; // 默认按值捕获，显式按引用捕获 x auto lambda_mixed = [=, \u0026amp;x]() { x++; std::cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;, z = \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; lambda_mixed(); // 输出：x = 2, y = 2, z = 3 4.5 修改值捕获的变量：mutable 关键字 作用：允许在 Lambda 内部修改值捕获的变量。 限制：修改仅在 Lambda 内部有效，不会影响外部变量。 1 2 3 4 5 6 7 8 int value = 5; auto modify = [value]() mutable { value *= 2; std::cout \u0026lt;\u0026lt; \u0026#34;内部 value = \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; modify(); // 输出：内部 value = 10 std::cout \u0026lt;\u0026lt; \u0026#34;外部 value = \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 输出：外部 value = 5 五、Lambda 表达式的高级特性 5.1 异常说明和 noexcept Lambda 表达式可以指定异常说明，以声明可能抛出的异常类型。\n1 2 3 auto safe_divide = [](int a, int b) noexcept -\u0026gt; double { return static_cast\u0026lt;double\u0026gt;(a) / b; }; 5.2 Lambda 表达式的类型和实现 类型：每个 Lambda 表达式都有唯一的匿名类型，不能被复制或赋值。 实现原理：编译器将 Lambda 表达式转换为一个拥有 operator() 的匿名类。 1 2 3 4 5 6 7 8 9 10 11 auto lambda = [](int n) { return n * n; }; // 等价于 class __LambdaUniqueName__ { public: int operator()(int n) const { return n * n; } }; 六、Lambda 表达式的实际应用场景 6.1 标准算法库的使用 Lambda 表达式在使用 STL 算法时非常方便，例如 std::sort、std::for_each。\n1 2 3 4 5 6 7 8 9 10 std::vector\u0026lt;int\u0026gt; numbers = {3, 1, 4, 1, 5}; std::sort(numbers.begin(), numbers.end(), [](int a, int b) { return a \u0026gt; b; // 降序排序 }); for (int n : numbers) { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // 输出：5 4 3 1 1 6.2 事件处理和回调函数 在需要传递回调函数的场景，如 GUI 编程或异步操作。\n1 2 3 4 5 6 7 8 9 10 11 void setCallback(std::function\u0026lt;void(int)\u0026gt; callback) { // 模拟事件触发 callback(42); } int main() { setCallback([](int eventId) { std::cout \u0026lt;\u0026lt; \u0026#34;事件触发，ID：\u0026#34; \u0026lt;\u0026lt; eventId \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }); return 0; } 七、注意事项和最佳实践 避免捕获过多的变量：捕获列表应尽量精简，明确指定需要的变量。 显式指定返回类型：在可能有歧义或复杂返回类型时，显式指定返回类型。 谨慎使用引用捕获：确保引用的变量在 Lambda 执行时仍然有效。 理解可变性：使用 mutable 时，注意值捕获的变量修改仅在 Lambda 内部有效。 ","permalink":"https://oheyu.github.io/zh/posts/tech/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"自 C++11 标准引入以来，Lambda 表达式（也称为匿名函数）已经成为现代 C++ 编程中不可或缺的一部分。它们提供了一种简洁而强大的方式来定义内联函数，特","title":"Lambda表达式"},{"content":"\rC++11 标准新增了两个重要的构造函数特性：委托构造 和 继承构造。这两个特性极大地简化了代码，减少了重复代码的编写，提升了代码的可读性和维护性。\n一、委托构造（Delegating Constructors） 1.1 什么是委托构造？ 在 C++ 开发中，某个类可能会有多个构造函数用于不同的初始化需求。这些构造函数往往存在重复的代码，比如成员变量的初始化。如果每个构造函数都独立编写初始化代码，会导致代码臃肿、冗余且难以维护。\n委托构造 允许我们在一个构造函数的初始化列表中调用另一个构造函数，从而简化代码，避免重复初始化的代码块。这使得类的构造逻辑更加清晰、简洁。\n2. 委托构造的使用规则 调用链：一个构造函数可以调用同一个类中的其他构造函数来初始化某些成员变量。 避免循环调用：构造函数不能形成环状调用，否则会导致编译错误或运行时错误。 初始化顺序：一旦使用了委托构造，委托的构造函数负责初始化被调用的成员变量，委托者不能再初始化其他成员。 2.3 委托构造的示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class AA { private: int m_a; int m_b; double m_c; public: // 一个参数的构造函数，初始化 m_c AA(double c) { m_c = c + 3; cout \u0026lt;\u0026lt; \u0026#34;AA(double c)\u0026#34; \u0026lt;\u0026lt; endl; } // 两个参数的构造函数，初始化 m_a 和 m_b AA(int a, int b) { m_a = a + 1; m_b = b + 2; cout \u0026lt;\u0026lt; \u0026#34;AA(int a, int b)\u0026#34; \u0026lt;\u0026lt; endl; } // 委托构造：调用 AA(int a, int b) AA(int a, int b, const string\u0026amp; str) : AA(a, b) { cout \u0026lt;\u0026lt; \u0026#34;m_a=\u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; \u0026#34;, m_b=\u0026#34; \u0026lt;\u0026lt; m_b \u0026lt;\u0026lt; \u0026#34;, str=\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } // 委托构造：调用 AA(double c) AA(double c, const string\u0026amp; str) : AA(c) { cout \u0026lt;\u0026lt; \u0026#34;m_c=\u0026#34; \u0026lt;\u0026lt; m_c \u0026lt;\u0026lt; \u0026#34;, str=\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } }; int main() { AA a1(10, 20, \u0026#34;我是一只傻傻鸟。\u0026#34;); AA a2(3.8, \u0026#34;我有一只小小鸟。\u0026#34;); return 0; } 代码解析： AA(int a, int b, const string\u0026amp; str) 调用了 AA(int a, int b)，从而初始化了 m_a 和 m_b。 AA(double c, const string\u0026amp; str) 调用了 AA(double c)，从而初始化了 m_c。 这种方式可以避免在多个构造函数中重复编写相同的初始化代码。 二、继承构造（Inheriting Constructors） 2.1 什么是继承构造？ 在 C++11 之前，派生类不能直接继承基类的构造函数。如果需要调用基类的构造函数，必须在派生类的构造函数中显式调用基类的构造函数。这种方式虽然灵活，但当基类有多个构造函数时，派生类需要逐个编写构造函数，显得繁琐。\n继承构造 允许派生类通过 using 关键字继承基类的构造函数，从而自动继承基类的所有构造函数，无需显式定义派生类的构造函数。\n2.2 继承构造的使用规则 自动继承基类构造函数：在派生类中使用 using 关键字可以继承基类的所有构造函数。 支持自定义构造函数：派生类仍然可以定义自己的构造函数，并与继承的构造函数共存。 自动调用基类构造函数：继承的构造函数会自动调用基类的构造函数进行初始化。 2.3 继承构造的示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; using namespace std; class AA // 基类 { public: int m_a; int m_b; // 一个参数的构造函数 AA(int a) : m_a(a) { cout \u0026lt;\u0026lt; \u0026#34;AA(int a)\u0026#34; \u0026lt;\u0026lt; endl; } // 两个参数的构造函数 AA(int a, int b) : m_a(a), m_b(b) { cout \u0026lt;\u0026lt; \u0026#34;AA(int a, int b)\u0026#34; \u0026lt;\u0026lt; endl; } }; class BB : public AA // 派生类 { public: double m_c; using AA::AA; // 继承基类的构造函数 // 派生类的自定义构造函数 BB(int a, int b, double c) : AA(a, b), m_c(c) { cout \u0026lt;\u0026lt; \u0026#34;BB(int a, int b, double c)\u0026#34; \u0026lt;\u0026lt; endl; } void show() { cout \u0026lt;\u0026lt; \u0026#34;m_a=\u0026#34; \u0026lt;\u0026lt; m_a \u0026lt;\u0026lt; \u0026#34;, m_b=\u0026#34; \u0026lt;\u0026lt; m_b \u0026lt;\u0026lt; \u0026#34;, m_c=\u0026#34; \u0026lt;\u0026lt; m_c \u0026lt;\u0026lt; endl; } }; int main() { BB b1(10); // 调用继承的基类构造函数 AA(int a) b1.show(); BB b2(10, 20); // 调用继承的基类构造函数 AA(int a, int b) b2.show(); BB b3(10, 20, 10.58); // 调用派生类自己的构造函数 b3.show(); return 0; } 代码解析： BB(int a) 和 BB(int a, int b) 是自动继承自基类 AA 的构造函数，通过 using AA::AA 实现。 BB(int a, int b, double c) 是派生类自定义的构造函数，用于初始化额外的成员 m_c。 4. 继承构造的注意事项 using 只能继承构造函数：using 关键字只能用于继承构造函数，不能用于其他成员函数的继承。 派生类的自定义构造函数不会覆盖继承的构造函数：派生类的构造函数和继承的基类构造函数可以共存。 三、总结 C++11 引入的 委托构造 和 继承构造 大大简化了类构造函数的编写，避免了冗余的代码。在复杂的类体系中，使用委托构造可以减少重复的初始化代码，提升代码的可维护性；使用继承构造则可以减少派生类对基类构造函数的重复实现，使代码更加简洁直观。\n委托构造：一个构造函数可以调用另一个构造函数来简化初始化逻辑，减少代码重复。 继承构造：派生类可以通过 using 关键字继承基类的构造函数，避免手动编写重复的构造函数。 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0/","summary":"C++11 标准新增了两个重要的构造函数特性：委托构造 和 继承构造。这两个特性极大地简化了代码，减少了重复代码的编写，提升了代码的可读性和维护性。 一、委","title":"委托构造与继承构造"},{"content":"\rC++11 引入了许多新的特性，极大地提升了代码的安全性、可读性和性能。其中，final 和 override 关键字的引入为开发者提供了更强的控制与提示功能，而数值与字符串之间的便捷转换更是让常见的字符串操作更加简洁高效。\n一、final 关键字的应用 1.1 什么是 final 关键字？ final 关键字用于限制某个类不能被继承，或者某个虚函数不能被重写。这样可以确保某些类或函数在继承体系中具有最终性，避免被派生类修改，提升了代码的安全性和设计的严谨性。\nfinal 可以应用于两种情况：\n类：表示该类不能被进一步继承。 虚函数：表示该虚函数在派生类中不能被重写。 1.2 final 关键字的用法示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AA { public: virtual void test() { cout \u0026lt;\u0026lt; \u0026#34;AA class...\u0026#34; \u0026lt;\u0026lt; endl; } }; class BB : public AA { public: void test() final // 这个虚函数不能在其他派生类中被重写 { cout \u0026lt;\u0026lt; \u0026#34;BB class...\u0026#34; \u0026lt;\u0026lt; endl; } }; // 继承自 BB 的类 class CC : public BB { public: void test() // 错误：BB 类中的 test() 方法已经用 final 限制，不能再重写 { cout \u0026lt;\u0026lt; \u0026#34;CC class...\u0026#34; \u0026lt;\u0026lt; endl; } }; 在以上代码中，BB 类中的 test() 方法被标记为 final，这意味着任何继承 BB 的类都不能重写 test()。尝试在 CC 中重写该方法时会导致编译错误。\n1.3 类的 final 限制 如果你想要创建一个不能被继承的类，可以将 final 关键字放在类名的后面：\n1 2 3 4 class DD final // 表示 DD 类不能被继承 { // 类的实现 }; 任何尝试继承 DD 的类都会导致编译错误，这样的设计可以防止重要的类被无意修改。\n二、override 关键字的应用 2.1 override 关键字的意义 override 关键字用于派生类中的虚函数，用来显式表明该函数是重写了基类的虚函数。虽然在没有 override 关键字时，派生类也可以重写基类的虚函数，但 override 的出现增强了代码的可读性和安全性，帮助编译器检查函数的重写是否正确。\n如果派生类中的函数与基类的虚函数签名不匹配，而你使用了 override 关键字，编译器将报错。这有效地避免了由于不匹配导致的潜在错误。\n2.2 override 关键字的用法示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class AA { public: virtual void test() { cout \u0026lt;\u0026lt; \u0026#34;AA class...\u0026#34; \u0026lt;\u0026lt; endl; } }; class BB : public AA { public: void test() override // 明确指出这是在重写基类的虚函数 { cout \u0026lt;\u0026lt; \u0026#34;BB class...\u0026#34; \u0026lt;\u0026lt; endl; } }; 在上面的例子中，BB 类中的 test() 函数重写了 AA 类中的虚函数。使用 override 关键字后，编译器可以进行检查，确保该重写是合法的。\n2.3 为什么使用 override 很重要？ 在没有 override 关键字的情况下，如果派生类的函数签名与基类的虚函数不匹配（如参数类型、数量等不同），编译器不会认为它是重写，而是认为这是一个新的函数。这种情况下，基类的虚函数仍然会被调用，这可能导致意外的行为。使用 override 可以避免这种错误。\n三、数值类型与字符串之间的转换 C++11 提供了更简便的方式在数值类型和 string 类型之间进行转换。传统上，C++ 使用 sprintf()、atoi() 等函数进行转换，但这些方法的安全性和可读性较差。在 C++11 中，提供了更为现代的函数接口，如 to_string() 和 stoi() 等。\n1. 数值转换为字符串 使用 to_string() 函数，可以将常见的数值类型转换为 string。这是一个非常直观的函数，可以避免复杂的格式化操作。\n1 2 3 int num = 42; string str = to_string(num); cout \u0026lt;\u0026lt; \u0026#34;转换后的字符串: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; to_string() 支持多种数值类型，包括 int、long、float、double 等。以下是常见的重载函数原型：\n1 2 3 4 string to_string(int val); string to_string(long val); string to_string(float val); string to_string(double val); 2. 字符串转换为数值 C++11 引入了 stoi()、stol()、stof() 等函数，用于将 string 类型转换为数值类型。这些函数非常方便，并且还可以通过可选参数来指定进制。\n1 2 3 string str = \u0026#34;123\u0026#34;; int val = stoi(str); cout \u0026lt;\u0026lt; \u0026#34;转换后的整数: \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; 这些函数支持不同的数值类型和进制转换。函数原型如下：\n1 2 3 int stoi(const string\u0026amp; str, size_t* pos = nullptr, int base = 10); float stof(const string\u0026amp; str, size_t* pos = nullptr); double stod(const string\u0026amp; str, size_t* pos = nullptr); 在转换过程中，如果字符串中包含无法转换的部分，可以通过 pos 参数获取解析停止的位置。\n1 2 3 4 string str = \u0026#34;123abc\u0026#34;; size_t pos; int val = stoi(str, \u0026amp;pos); cout \u0026lt;\u0026lt; \u0026#34;转换的整数: \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34;, 停止位置: \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; 输出：\n1 转换的整数: 123, 停止位置: 3 在这个例子中，stoi 成功解析了前 3 个字符为整数 123，并在遇到无法解析的字符 a 时停止。\n四、总结 C++11 引入的 final 和 override 关键字为类设计提供了更强的控制与安全性。使用 final 可以防止类或函数的进一步继承或重写，而 override 则为虚函数的重写提供了显式的编译器检查，极大地减少了潜在的编程错误。\n此外，C++11 提供了更简洁的数值与字符串之间的转换方式，通过 to_string() 和 stoi() 等函数，开发者可以轻松地在不同数据类型之间进行转换，提升了代码的可读性和安全性。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp11%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E6%A0%87%E5%87%86/","summary":"C++11 引入了许多新的特性，极大地提升了代码的安全性、可读性和性能。其中，final 和 override 关键字的引入为开发者提供了更强的控制与提示功能，而数值与字","title":"CPP11中的一些新标准"},{"content":"\rHTTP（Hypertext Transfer Protocol）是互联网中最常用的协议之一，它定义了客户端（如浏览器）与服务器之间的通信方式。每次客户端请求一个网页、图片或其他资源时，都会发起一个 HTTP 请求。\n一、HTTP 请求消息的组成 HTTP 请求消息包含三部分：\n请求行（Request Line）：指示请求的方式（如 GET、POST）、请求的目标资源以及使用的协议版本。 请求头部（Request Headers）：提供请求的元数据，包括客户端的配置信息、期望的响应格式等。 消息体（Message Body）：可选部分，主要在 POST、PUT 等请求中使用，用于传输数据（如表单、文件等）。 示例 HTTP 请求 我们先看一个典型的 HTTP 请求的例子：\n1 2 3 4 5 6 7 GET /index.html HTTP/1.1 Host: www.example.com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive 该请求是客户端请求服务器上的 /index.html 页面，接下来我们会逐步解析这条 HTTP 请求消息的每个部分。\n二、请求行（Request Line） 请求行是 HTTP 请求的第一行，包含以下三个部分：\n请求方法（HTTP Method） 请求目标（Request Target，通常是 URL 的路径部分） HTTP 版本（HTTP Version） 2.1 请求方法 HTTP 协议支持多种请求方法，最常见的包括：\nGET：请求服务器返回指定资源的内容，一般用于获取数据，不包含请求体。 POST：向服务器提交数据（如表单数据），数据包含在请求体中。 PUT：向服务器发送数据并更新指定资源。 DELETE：请求服务器删除指定的资源。 HEAD：类似 GET，但只请求头部信息，不返回实际的资源数据。 OPTIONS：用于查询服务器支持的请求方法。 PATCH：部分更新资源。 2.2 请求目标 请求目标通常是相对于服务器根路径的资源路径。例如：\n1 GET /index.html HTTP/1.1 这里的 /index.html 就是请求目标，表示客户端希望获取服务器上的 index.html 文件。这个路径是相对于服务器的主机名的（如 www.example.com）。\n2.3 HTTP 版本 HTTP 请求行的最后一个部分是 HTTP 版本号。常见的版本有：\nHTTP/1.0：最早的 HTTP 版本，每次请求结束后关闭连接。 HTTP/1.1：支持持久连接和流水线处理（即同一个连接上可以发出多个请求）。 HTTP/2：优化了性能，支持多路复用，减少了请求之间的等待时间。 在请求行中，客户端指明使用的 HTTP 版本，服务器会根据此版本来回应请求。\n三、请求头部（Request Headers） 请求头部由一系列的键值对组成，提供了有关客户端环境、请求上下文和客户端希望如何处理响应的附加信息。\n常见的请求头部 Host\nHost: www.example.com\n指定请求目标的主机名和端口。对于 HTTP/1.1 请求，Host 头是必须的，因为服务器可能托管多个域名。\nUser-Agent\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\n描述了发出请求的客户端软件。通常是浏览器、操作系统及其版本号等信息。服务器可以根据 User-Agent 提供差异化响应（例如移动端和桌面端网页可能不同）。\nAccept\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp\n告知服务器客户端可以接受的响应数据类型（MIME 类型）。例如，text/html 表示客户端期望返回 HTML 网页，image/webp 表示可以接受 WebP 格式的图片。\nAccept-Language\nAccept-Language: en-US,en;q=0.5\n表示客户端首选的语言环境。服务器可以根据此信息返回不同的语言版本。\nAccept-Encoding\nAccept-Encoding: gzip, deflate, br\n客户端支持的压缩算法，服务器可以根据此信息选择以何种压缩格式传输响应数据。常见的压缩方式包括 gzip、deflate 和 br（Brotli）。\nConnection\nConnection: keep-alive\n表示是否保持 TCP 连接打开。keep-alive 表示浏览器希望与服务器保持连接，避免为每个请求重新建立 TCP 连接。\n自定义请求头部 开发者可以自定义请求头部，例如在 REST API 中可能会用到 Authorization 头部，用于提供访问令牌：\n1 Authorization: Bearer \u0026lt;token\u0026gt; 四、消息体（Message Body） GET 请求 vs POST 请求 GET 请求 通常不带消息体，请求的数据通过 URL 的查询参数传递。例如：\n1 GET /search?q=linux HTTP/1.1 POST 请求 可以携带消息体，用于传输表单数据或文件。例如，一个典型的 POST 请求体可能是：\n1 2 3 4 5 POST /login HTTP/1.1 Host: www.example.com Content-Type: application/x-www-form-urlencoded username=admin\u0026amp;password=123456 Content-Type 当请求包含消息体时，客户端需要通过 Content-Type 头部指定消息体的数据格式。常见的格式包括：\napplication/x-www-form-urlencoded：用于传输表单数据。 multipart/form-data：用于上传文件。 application/json：用于传输 JSON 数据。 五、HTTPS 请求与加密 如果使用 HTTPS 进行请求，整个 HTTP 请求消息都会通过 TLS（传输层安全） 加密。HTTPS 的工作流程如下：\nTLS 握手：客户端和服务器通过 TLS 协议建立安全的加密连接。 加密通信：HTTP 请求头部和消息体被加密，并通过安全通道传输。 解密与处理：服务器收到加密的请求后，进行解密并处理请求。 通过 HTTPS，加密了客户端与服务器之间的所有通信，保护用户隐私。\n六、常见工具和调试方式 在开发过程中，我们经常需要调试 HTTP 请求。常用的工具包括：\ncurl：命令行工具，用于发送 HTTP 请求并查看服务器的响应。 浏览器开发者工具：现代浏览器（如 Chrome、Firefox）内置的开发者工具，可以在 \u0026ldquo;Network\u0026rdquo; 标签下查看详细的 HTTP 请求和响应。 Postman：用于构建、测试和调试 API 请求的强大 GUI 工具。 示例：使用 curl 发送 GET 请求 1 curl -v https://www.example.com/index.html 该命令会显示详细的 HTTP 请求和响应，包括请求行、头部和响应的状态码。\n","permalink":"https://oheyu.github.io/zh/posts/tech/http%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF/","summary":"HTTP（Hypertext Transfer Protocol）是互联网中最常用的协议之一，它定义了客户端（如浏览器）与服务器之间的通信方式。每次客户端请求","title":"HTTP请求消息"},{"content":"\r在现代计算机网络中，TCP/IP 网络模型（也称为互联网协议套件）是确保设备间通信的基础框架。它的设计不仅支持从小型局域网（LAN）到全球互联网的规模扩展，还提供了可扩展性、灵活性和可靠性。\n一、什么是 TCP/IP 网络模型？ TCP/IP 模型是一个四层的网络通信模型，它定义了数据从一台设备传输到另一台设备的全过程。它的核心思想是分层抽象：每一层负责网络通信中的特定功能，并与相邻的层进行交互。\nTCP/IP 模型中的四个层次分别为：\n网络接口层（Network Interface Layer） 互联网层（Internet Layer） 传输层（Transport Layer） 应用层（Application Layer） TCP/IP 模型与 OSI 模型的对比 虽然 OSI 模型（开放式系统互连参考模型）定义了七个层次（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），但在实际中，TCP/IP 模型因为更贴合互联网实际实现，使用更加广泛。\nTCP/IP 模型：精简为四层，强调实际实现和协议的使用。 OSI 模型：七层模型是更为理论化的框架。 TCP/IP 四层架构 下图展示了 TCP/IP 模型的各层以及其对应的 OSI 模型层次：\n1 2 3 4 5 6 7 8 9 OSI 七层模型 | TCP/IP 四层模型 ---------------------------------------------------- 7. 应用层（Application Layer） | 应用层（Application Layer） 6. 表示层（Presentation Layer） | [合并到应用层] 5. 会话层（Session Layer） | [合并到应用层] 4. 传输层（Transport Layer） | 传输层（Transport Layer） 3. 网络层（Network Layer） | 互联网层（Internet Layer） 2. 数据链路层（Data Link Layer） | 网络接口层（Network Interface Layer） 1. 物理层（Physical Layer） | [包含在网络接口层] 二、TCP/IP 模型的四个层次详解 1. 网络接口层（Network Interface Layer） 网络接口层负责数据在本地网络中的传输和接收，主要涉及物理链路的建立和维护。该层次处理硬件设备的接口问题，包括如何通过以太网、Wi-Fi 等技术来传输数据帧。\n关键协议与标准：\n以太网（Ethernet） ARP（地址解析协议） PPP（点对点协议） VLAN 在 Linux 网络编程中，网卡的驱动、数据包捕获（如使用 libpcap 库）以及物理层的连接管理都涉及到这一层次。\n2. 互联网层（Internet Layer） 互联网层负责通过 IP 地址在多个网络间传输数据包。这一层的核心功能是路由，即确定数据包从源到目的地的最佳路径。互联网层确保数据能够跨越不同的网络传输。\n关键协议：\nIP（互联网协议）：这是整个网络层的基础。IP 地址确保数据包可以在全世界范围内的设备间传输。 IPv4：最常用的互联网协议版本，使用 32 位地址。 IPv6：为解决 IPv4 地址耗尽问题，使用 128 位地址。 ICMP（互联网控制消息协议）：用于发送错误消息、测试连通性（如 ping 命令）。 ARP（地址解析协议）：将 IP 地址转换为 MAC 地址。 开发人员常用的工具如 ping、traceroute 都属于这一层的功能。作为 Linux 程序员，网络工具的开发和调试经常会使用到该层的概念。\n3. 传输层（Transport Layer） 传输层负责确保端到端的通信可靠性和数据的完整性。它为上层提供了可靠的数据传输服务，并可以处理数据的流控和纠错。\n关键协议：\nTCP（传输控制协议）：提供可靠的、面向连接的传输服务。TCP 通过三次握手建立连接，并使用序列号和确认机制确保数据的可靠传输。 UDP（用户数据报协议）：提供不可靠的、无连接的传输服务。UDP 更加轻量，不进行确认与重传，因此适用于实时通信，如视频流和在线游戏。 SCTP（流控制传输协议）：用于支持多个流之间的数据传输，具备更强的容错能力。 在 Linux 中，开发人员常通过 socket API 进行 TCP 和 UDP 的通信编程。通过设置 SOCK_STREAM（TCP）或 SOCK_DGRAM（UDP），可以在应用程序中使用对应的传输协议。\n4. 应用层（Application Layer） 应用层负责为用户和应用程序提供访问网络服务的接口。这个层次提供了各种不同的协议，允许应用程序进行数据传输、文件共享、电子邮件、远程登录等操作。\n关键协议：\nHTTP/HTTPS（超文本传输协议）：用于浏览网页的数据传输。 FTP（文件传输协议）：用于文件上传和下载。 SMTP（简单邮件传输协议）：用于发送电子邮件。 DNS（域名系统）：用于将域名解析为 IP 地址。 SSH（安全外壳协议）：用于远程登录和命令执行。 在 C++ 网络编程中，开发者可以使用 libcurl、boost::asio 等库实现应用层协议的支持。例如，实现一个简单的 HTTP 客户端或服务器，可以通过 libcurl 库简化 HTTP 请求的处理。\n三、TCP 与 UDP 的对比 TCP 和 UDP 是传输层中两个最常用的协议，它们各有优劣，适用于不同的场景：\n特性 TCP UDP 连接 面向连接，需要三次握手建立连接 无连接，不需要建立连接 可靠性 提供可靠的传输，数据丢失时会重传 不保证可靠传输，可能丢包 流量控制 有流量控制与拥塞控制机制 没有流量控制 传输速度 较慢（由于可靠性与流控机制） 较快（不保证可靠性，开销小） 适用场景 需要高可靠性的数据传输，如文件传输 需要实时性的数据传输，如视频 四、TCP/IP 编程中的常见问题 1. 数据包丢失与重传 在 TCP 协议中，数据包的丢失通常由网络不稳定或拥塞导致。TCP 提供了重传机制，通过超时检测与确认丢失包来进行重传。\n2. 拥塞控制与流量控制 TCP 实现了流量控制和拥塞控制机制，通过窗口大小和慢启动等算法来调整传输速率，避免网络拥塞。\n3. NAT 和 IP 地址转换 由于 IPv4 地址数量有限，网络地址转换（NAT）被广泛应用，特别是在家庭和公司网络中。NAT 会将内网的私有 IP 地址转换为公网的 IP 地址，解决 IP 地址不足的问题。\n五、总结 TCP/IP 网络模型是现代互联网通信的基础，其四层架构简洁而功能强大。理解各层的功能和关键协议对于网络编程、系统设计和网络调试至关重要。\n","permalink":"https://oheyu.github.io/zh/posts/tech/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/","summary":"在现代计算机网络中，TCP/IP 网络模型（也称为互联网协议套件）是确保设备间通信的基础框架。它的设计不仅支持从小型局域网（LAN）到全球互联","title":"TCPIP网络模型"},{"content":"\r并发编程中，信号量（Semaphore）作为一种强大的同步工具，可以有效地控制多个线程或进程对共享资源的访问。C++ 提供了信号量的基本操作接口，使开发者能够方便地在多线程或多进程环境中实现安全的数据共享。在不同的场景下，信号量的配置，如初始值（value）和操作标志（sem_flg），需要根据具体需求进行合理设置。\n一、信号量的基本概念 信号量可以看作一个受保护的计数器，它能够控制对资源的并发访问。信号量的值通常表示当前可用资源的数量，并通过两种基本操作来管理资源的访问：\nP 操作（等待操作，Wait/Decrement）：将信号量的值减 1。如果信号量的值已经为 0，操作将阻塞，等待信号量的值增加。 V 操作（信号操作，Signal/Increment）：将信号量的值加 1，解除阻塞等待该资源的进程或线程。 二、互斥锁中的信号量配置 2.1 互斥锁的作用 互斥锁（Mutex）用于确保在同一时刻，只有一个线程或进程能够访问共享资源，从而防止数据竞争。互斥锁的典型应用场景包括对临界区的保护，避免多线程同时访问并修改共享数据，从而造成数据不一致或未定义行为。\n2.2 信号量在互斥锁中的配置 在实现互斥锁时，信号量的初始值和操作标志 sem_flg 的配置非常关键：\nvalue 初始值为 1：在互斥锁的场景中，信号量的初始值通常设为 1，表示共享资源是可用的。线程或进程进入临界区时执行 P 操作，信号量的值减 1。当信号量的值为 0 时，意味着资源被占用，其他线程将阻塞，等待资源释放。退出临界区后，执行 V 操作释放资源。\nsem_flg 设置为 SEM_UNDO：该标志确保在持有锁的进程意外崩溃或退出时，操作系统能够自动撤销该进程对信号量的修改，释放锁资源。这样可以避免死锁现象，确保系统能够继续正常运行。\n2.3 互斥锁的代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/sem.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; class Semaphore { public: Semaphore(key_t key, int initial_value) { semid = semget(key, 1, 0666 | IPC_CREAT); semctl(semid, 0, SETVAL, initial_value); } void wait() { struct sembuf sb = {0, -1, SEM_UNDO}; // P 操作 semop(semid, \u0026amp;sb, 1); } void post() { struct sembuf sb = {0, 1, SEM_UNDO}; // V 操作 semop(semid, \u0026amp;sb, 1); } private: int semid; }; int main() { key_t key = ftok(\u0026#34;semfile\u0026#34;, \u0026#39;a\u0026#39;); Semaphore mutex(key, 1); // 互斥锁的信号量，初始值为 1 mutex.wait(); // 进入临界区 std::cout \u0026lt;\u0026lt; \u0026#34;进入临界区，进行独占操作\u0026#34; \u0026lt;\u0026lt; std::endl; sleep(2); // 模拟处理 mutex.post(); // 退出临界区 return 0; } 三、生产者-消费者模型中的信号量配置 3.1 生产者-消费者模型的原理 生产者-消费者模型是一种经典的并发控制模式，其中生产者生成资源并放入缓冲区，消费者从缓冲区获取资源进行处理。为了避免生产者过度填充缓冲区或消费者在没有可用资源时阻塞，通常需要使用信号量来管理缓冲区的状态：\nempty_slots 信号量：用于表示缓冲区中的空闲位置。 full_slots 信号量：用于表示缓冲区中的已占用位置。 3.2 信号量在生产者-消费者模型中的配置 在生产者-消费者模型中，信号量的初始值和操作标志 sem_flg 需要根据模型的具体需求进行合理配置：\nvalue 的配置：\nempty_slots 初始值为缓冲区大小：该信号量表示缓冲区中的空闲位置数，因此初始值为缓冲区的总大小。当生产者生成资源并放入缓冲区时，empty_slots 的值减 1；当消费者取走资源时，empty_slots 的值加 1，表示腾出一个空闲位置。 full_slots 初始值为 0：该信号量表示缓冲区中已占用位置的数量，初始值为 0，表示开始时缓冲区为空。每当生产者放入一个资源，full_slots 的值加 1；消费者取走资源时，该值减 1。 sem_flg 的配置：在生产者-消费者模型中，sem_flg 通常设置为 0。因为信号量的状态完全由程序控制，系统不会自动撤销进程的信号量修改，确保信号量的值与缓冲区状态保持一致。\n3.3 生产者-消费者模型的代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/sem.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; class Semaphore { public: Semaphore(key_t key, int initial_value) { semid = semget(key, 1, 0666 | IPC_CREAT); semctl(semid, 0, SETVAL, initial_value); } void wait() { struct sembuf sb = {0, -1, 0}; // P 操作 semop(semid, \u0026amp;sb, 1); } void post() { struct sembuf sb = {0, 1, 0}; // V 操作 semop(semid, \u0026amp;sb, 1); } private: int semid; }; int main() { key_t key_empty = ftok(\u0026#34;emptyfile\u0026#34;, \u0026#39;a\u0026#39;); key_t key_full = ftok(\u0026#34;fullfile\u0026#34;, \u0026#39;b\u0026#39;); int buffer_size = 5; Semaphore empty_slots(key_empty, buffer_size); // 空闲槽位，初始值为缓冲区大小 Semaphore full_slots(key_full, 0); // 已占用槽位，初始值为 0 // 生产者逻辑 empty_slots.wait(); // 等待空闲位置 std::cout \u0026lt;\u0026lt; \u0026#34;生产者生成资源\u0026#34; \u0026lt;\u0026lt; std::endl; full_slots.post(); // 通知消费者资源可用 // 消费者逻辑 full_slots.wait(); // 等待可消费资源 std::cout \u0026lt;\u0026lt; \u0026#34;消费者消费资源\u0026#34; \u0026lt;\u0026lt; std::endl; empty_slots.post(); // 通知生产者有空闲位置 return 0; } 四、不同场景中信号量配置的比较 4.1 value 的配置差异 互斥锁中的 value 为 1：表示资源是可用的，只有一个线程可以进入临界区。此时信号量的值为 0 表示资源被占用。 生产者-消费者模型中的 value：empty_slots 表示缓冲区的可用空间，因此初始值为缓冲区的大小；full_slots 初始值为 0，表示开始时没有可供消费的资源。 4.2 sem_flg 的配置差异 互斥锁中的 sem_flg 为 SEM_UNDO：确保在进程异常退出时，操作系统能够撤销对信号量的修改，避免资源死锁。 生产者-消费者模型中的 sem_flg 为 0：信号量完全由程序控制，避免操作系统干预信号量的值，以确保信号量与缓冲区状态一致。 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%86%8D%E6%8E%A2%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/","summary":"并发编程中，信号量（Semaphore）作为一种强大的同步工具，可以有效地控制多个线程或进程对共享资源的访问。C++ 提供了信号量的基本操作接","title":"再探信号量：互斥锁与生产者 消费者模型"},{"content":"\r在 C++ 编程中，引用（References）是一个非常常用的特性，允许我们通过别名来引用已有的变量。通常情况下，引用要求引用的类型和实际变量类型匹配。然而，当我们使用常引用（const reference）时，C++ 允许一种特殊行为：当引用的数据类型不匹配时，编译器会自动创建一个临时变量，并让常引用绑定到这个临时变量，这是怎么一个事？\n一、C++ 中引用的基础概念 1.1 普通引用（Lvalue Reference） 普通引用（lvalue reference）是 C++ 中引用的基本形式，要求引用的类型必须与所引用的变量类型完全一致。它提供了对已有对象的直接操作能力，所有对引用的操作实际上都会作用于被引用的对象。\n1 2 3 int a = 10; int\u0026amp; ref = a; // ref 是 a 的引用 ref = 20; // 改变 ref 的值，a 的值也会随之改变 在这个例子中，ref 是 a 的引用。对 ref 的任何修改都会影响 a，因为 ref 实际上是 a 的别名。\n1.2 常引用（Const Reference） 常引用（const reference）是一种不可变引用，它允许我们创建一个引用，但不能通过该引用修改原变量。常引用在函数参数传递中尤为常见，能够避免不必要的拷贝，同时保证数据的只读性。\n1 2 3 int a = 10; const int\u0026amp; ref = a; // ref 是 a 的常引用 // ref = 20; // 错误：不能通过常引用修改变量的值 常引用不仅用于保护变量不被修改，还允许我们引用不同类型的变量或临时对象。这是常引用的一个强大特性，它为代码的灵活性提供了极大的支持。\n二、常引用绑定临时变量的特殊行为 2.1 类型不匹配时的普通引用 在 C++ 中，普通引用要求引用的类型与被引用的变量类型完全一致。如果类型不匹配，编译器会直接报错。\n1 2 double d = 3.14; int\u0026amp; ref = d; // 错误：类型不匹配 此时，d 是一个 double 类型，而 ref 被声明为 int\u0026amp; 类型。由于引用类型和变量类型不一致，编译器会报错。\n2.2 常引用绑定不匹配类型 然而，常引用则展现出一种特殊行为：当类型不匹配时，编译器会生成一个临时变量，并将该临时变量绑定到常引用上。\n1 2 double d = 3.14; const int\u0026amp; ref = d; // 合法：编译器创建临时变量 在上面的代码中，虽然 d 是一个 double 类型，但 ref 是一个 const int\u0026amp; 类型的引用。C++ 编译器会自动将 d 转换为 int（即 3），然后创建一个临时变量存储该值，并将 ref 绑定到这个临时变量上。\n三、工作原理：编译器如何处理类型不匹配 当常引用的类型与被引用对象的类型不匹配时，编译器会执行以下步骤：\n类型转换：编译器首先将原变量的值转换为常引用所需的类型。例如，double 类型的变量会转换为 int 类型。 创建临时变量：编译器创建一个临时变量来保存转换后的值。这个临时变量的类型与常引用的类型一致。 绑定常引用：常引用最终绑定到该临时变量，而不是原始变量。 1 2 double d = 3.14; const int\u0026amp; ref = d; d 的值 3.14 会被转换为 int 类型，结果是 3。 编译器创建一个临时变量（例如 temp），并将值 3 存储在这个临时变量中。 ref 被绑定到临时变量 temp，因此 ref 的值是 3。 临时变量的生命周期会被延长到引用的生命周期结束，这样确保了引用在整个过程中始终有效。\n四、常引用绑定临时变量的应用场景 4.1 函数参数传递 常引用的这种行为在函数参数传递时特别有用。我们可以通过常引用将不同类型的变量传递给函数，从而避免不必要的拷贝操作，同时保留数据的只读性。\n1 2 3 4 5 6 void printInt(const int\u0026amp; ref) { std::cout \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; std::endl; } double d = 4.56; printInt(d); // 输出 4 在这个例子中，函数 printInt 期望接收一个 const int\u0026amp; 类型的参数。然而，我们传递了一个 double 类型的变量 d。编译器会自动将 d 转换为 int，并创建一个临时变量，然后将这个临时变量传递给 printInt 函数。\n4.2 临时对象与类型转换 常引用可以绑定到临时对象，这使得常引用在需要类型转换的场景中非常灵活。例如，当处理字符串字面量时，常引用可以避免拷贝整个字符串。\n1 2 3 4 5 void processString(const std::string\u0026amp; str) { std::cout \u0026lt;\u0026lt; \u0026#34;String: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; } processString(\u0026#34;Hello, World!\u0026#34;); // 字符串字面量被转换为 std::string 临时对象 在这个例子中，\u0026quot;Hello, World!\u0026quot; 是一个 const char* 类型的字符串字面量。编译器会自动创建一个 std::string 的临时对象，然后将这个对象绑定到 const std::string\u0026amp; 引用 str。\n四、临时变量的生命周期与注意事项 当常引用绑定到一个临时变量时，临时变量的生命周期会被延长到引用的生命周期结束。这意味着在整个引用的有效期内，临时变量都存在且有效。\n然而，需要注意的是，当常引用用于返回临时变量时，必须确保临时变量的生命周期足够长，否则会导致未定义行为。\n1 2 3 4 const int\u0026amp; getTempRef() { double temp = 7.89; return temp; // 错误：返回临时变量的引用 } 在这个例子中，temp 是一个局部变量，在函数返回时会被销毁。因此，返回指向它的引用是无效的。避免此类错误，需要确保返回的引用指向的是一个有效的变量。\n六、常引用与右值引用的比较 C++11 引入了右值引用，它允许我们直接绑定到右值或临时对象。常引用与右值引用之间存在一些相似性，但也有重要区别：\n常引用：允许绑定到左值、右值和类型不匹配的对象（通过创建临时变量）。 右值引用：只能绑定到右值或临时对象，主要用于实现移动语义，减少不必要的拷贝。 右值引用通常用于优化性能，而常引用则更多用于类型转换和数据访问的安全性。\n七、总结 C++ 中的常引用在处理类型不匹配的对象时展现出独特的灵活性：编译器会自动创建临时变量，并让常引用绑定到该临时变量。这种机制不仅增强了代码的灵活性，还在函数参数传递和处理不同类型的数据时提供了高效的解决方案。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%B8%B8%E5%BC%95%E7%94%A8%E4%B8%8E%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA/","summary":"在 C++ 编程中，引用（References）是一个非常常用的特性，允许我们通过别名来引用已有的变量。通常情况下，引用要求引用的类型和实际变量类型","title":"常引用与临时变量的自动创建"},{"content":"\r在 C++ 编程中，指针和数组是两个非常基础且重要的概念。数组指针（Pointer to Array）是指向数组的指针，它们在多维数组、动态内存分配、函数参数传递等场景中发挥了重要作用。\n一、什么是数组指针？ 数组指针是一个指向整个数组的指针，而不是单个元素的指针。它的用途在于处理更复杂的数组操作，尤其是多维数组和需要作为参数传递数组的场景。\n与指向单个元素的指针不同，数组指针是指向数组类型的指针，而不是基本类型。例如，一个指向 int[10] 的数组指针并不是 int*，而是 int (*)[10]。这在需要处理多个维度的数据结构时尤为重要。\n二、数组指针的声明 数组指针的声明形式比普通指针稍微复杂，需要同时指定数组的类型和维度。在声明时，需要通过括号明确指针与数组的关系，否则编译器将其解释为错误的类型。\n2.1 一维数组指针的声明 1 int (*ptr)[10]; // 声明一个指向包含10个 int 类型元素的数组的指针 在这里，ptr 是一个指向包含 10 个 int 元素的数组的指针。括号 () 用于区分 ptr 是指向数组的，而不是指向单个 int 元素的普通指针 int* ptr。\n2.2 多维数组指针的声明 当处理多维数组时，数组指针可以指向整个二维数组的一行或者整个数组：\n1 int (*ptr2D)[4]; // 声明一个指向含有4个 int 元素的二维数组的指针 对于更高维的数组，声明时需要明确所有维度。\n三、数组指针的初始化 数组指针的初始化是通过指向已有的数组进行的。这意味着在声明数组指针后，我们可以通过现有数组的地址进行初始化。\n1 2 int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; int (*ptr)[10] = \u0026amp;arr; // ptr 指向数组 arr 的地址 注意，这里使用 \u0026amp;arr 来获取数组的地址，而不是 arr。因为 arr 本身是指向数组第一个元素的指针，而 \u0026amp;arr 是整个数组的地址，符合 ptr 的类型 int (*)[10]。\n四、使用数组指针 数组指针的主要作用是在操作数组时能够高效处理复杂的数据结构。数组指针可以用来访问、遍历数组元素，特别是在多维数组的场景中更加实用。\n4.1 访问数组元素 通过数组指针访问数组元素时，使用解引用操作符 * 来获取数组，然后再通过索引来访问具体的元素。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; int main() { int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; int (*ptr)[10] = \u0026amp;arr; std::cout \u0026lt;\u0026lt; \u0026#34;Element at index 0: \u0026#34; \u0026lt;\u0026lt; (*ptr)[0] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Element at index 5: \u0026#34; \u0026lt;\u0026lt; (*ptr)[5] \u0026lt;\u0026lt; std::endl; return 0; } 这里，(*ptr)[i] 用于访问数组 arr 中的元素。\n4.2 遍历数组 数组指针可以用于遍历整个数组：\n1 2 3 for (int i = 0; i \u0026lt; 10; ++i) { std::cout \u0026lt;\u0026lt; (*ptr)[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 这段代码遍历并输出数组中的每个元素。\n五、多维数组与数组指针 数组指针在处理多维数组时显得尤为强大。多维数组实际上是数组的数组，数组指针的使用可以简化对多维数组的访问。\n5.1 声明指向二维数组的指针 1 2 3 4 5 6 7 int arr[3][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} }; int (*ptr)[4] = arr; // 声明一个指向包含 4 个 int 元素的二维数组的指针 此时，ptr 是指向数组 arr 中每一行的指针，每一行包含 4 个 int 元素。\n5.2 访问二维数组的元素 通过数组指针，遍历和访问二维数组变得更加方便。\n1 2 3 4 5 6 for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { std::cout \u0026lt;\u0026lt; ptr[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; } 这种方式可以高效地处理二维数组中的每个元素。\n六、将数组指针作为函数参数 在将多维数组作为参数传递给函数时，数组指针极为有用。通过数组指针传递多维数组，可以避免直接传递数组的复杂性，提高代码的灵活性。\n6.1 将二维数组指针传递给函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void printArray(int (*ptr)[4], int rows) { for (int i = 0; i \u0026lt; rows; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { std::cout \u0026lt;\u0026lt; ptr[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; } } int main() { int arr[3][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} }; printArray(arr, 3); // 将二维数组的指针传递给函数 } 在这个例子中，函数 printArray 接受一个指向包含 4 个 int 元素的数组的指针 int (*ptr)[4]，并使用该指针遍历二维数组的内容。\n七、常见的错误与注意事项 指针与数组大小的匹配：数组指针在声明时必须包含数组的大小信息，例如 int (*ptr)[10]。如果数组的维度与指针声明不匹配，编译器会报错。\n数组越界：在使用数组指针时，确保访问的索引在合法范围内，否则可能会导致内存访问错误，进而引发未定义行为。\n内存布局的理解：理解数组在内存中的布局对于正确使用数组指针至关重要。特别是在多维数组中，数组指针操作的对象是整行或整列，而不是单个元素。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/","summary":"在 C++ 编程中，指针和数组是两个非常基础且重要的概念。数组指针（Pointer to Array）是指向数组的指针，它们在多维数组、动态内存分配、函数","title":"数组指针"},{"content":"\r在 C++ 编程中，资源管理是一项至关重要的任务，尤其是在内存分配、文件操作、网络连接等与系统资源密切相关的场景中。RAII（Resource Acquisition Is Initialization，资源获取即初始化）是一种经典的资源管理技术，通过将资源的获取与对象的生命周期绑定在一起，确保资源的自动释放，有效减少内存泄漏和资源滥用的风险。\n一、什么是 RAII？ RAII 是一种编程范式，强调资源的获取与对象的生命周期同步。在 C++ 中，资源的分配通常在对象的构造函数中进行，而资源的释放则在析构函数中完成。无论是内存、文件描述符、线程锁还是网络连接，都可以通过这种方式自动管理。\n1.1 核心概念 资源的获取与初始化：资源（如内存、文件句柄、网络连接等）在对象构造时被初始化或分配。构造函数负责这些资源的安全获取。\n资源的释放：析构函数则负责释放对象在构造时获取的资源。在对象的生命周期结束（如超出作用域或显式销毁）时，析构函数会自动调用，释放相关资源。\n这一模型的关键优势在于，它将资源的获取和释放过程自动化，避免了忘记手动释放资源或由于程序逻辑复杂导致的资源泄漏问题。\n1.2 一个简单的 RAII 示例 下面是一个通过 RAII 管理内存资源的简单示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; class Resource { public: // 构造函数：资源分配 Resource() { data = new int[10]; // 动态分配内存 std::cout \u0026lt;\u0026lt; \u0026#34;Resource acquired\u0026#34; \u0026lt;\u0026lt; std::endl; } // 析构函数：资源释放 ~Resource() { delete[] data; // 释放内存 std::cout \u0026lt;\u0026lt; \u0026#34;Resource released\u0026#34; \u0026lt;\u0026lt; std::endl; } private: int* data; // 管理的资源 }; void useResource() { Resource res; // 创建对象，构造函数自动获取资源 // 使用资源... } // 函数结束，res 超出作用域，自动调用析构函数释放资源 int main() { useResource(); return 0; } 在此示例中：\n当 Resource 对象在 useResource 函数中被创建时，构造函数分配了一个整数数组。 在函数结束时，对象离开作用域，析构函数自动释放内存资源，确保没有资源泄漏。 二、RAII 的实际应用场景 RAII 的应用场景几乎涵盖了所有与资源管理相关的编程场景，尤其是在 C++ 中。它不仅可以用于管理内存，还可以用于文件、网络连接、线程锁等资源。以下是 RAII 在几类常见场景中的应用：\n2.1 动态内存管理 手动分配和释放内存是 C++ 程序中常见的错误源。通过 RAII，内存的分配和释放由对象的构造和析构函数负责，减少了程序员的负担。例如，智能指针是 RAII 的典型实现：\n1 2 3 4 5 6 #include \u0026lt;memory\u0026gt; void useSmartPointer() { std::unique_ptr\u0026lt;int[]\u0026gt; ptr(new int[10]); // 自动管理内存 // 使用 ptr... } // 超出作用域时，unique_ptr 自动释放内存 在这个例子中，std::unique_ptr 使用 RAII 来管理动态分配的数组。ptr 超出作用域时，内存会自动释放。\n2.2 文件操作 在处理文件时，RAII 可以确保文件句柄在不再需要时自动关闭，避免文件资源泄漏：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;fstream\u0026gt; void writeToFile() { std::ofstream file(\u0026#34;example.txt\u0026#34;); if (!file.is_open()) { throw std::runtime_error(\u0026#34;Unable to open file\u0026#34;); } file \u0026lt;\u0026lt; \u0026#34;Hello, RAII!\u0026#34; \u0026lt;\u0026lt; std::endl; } // 文件对象超出作用域，自动关闭文件 在这个例子中，std::ofstream 的析构函数会自动关闭文件，即使在函数抛出异常的情况下也能确保资源被释放。\n2.3 线程锁管理 RAII 同样适用于多线程编程中的锁管理，通过将锁的获取和释放绑定到对象的生命周期，可以避免因忘记释放锁而导致的死锁问题：\n1 2 3 4 5 6 7 8 #include \u0026lt;mutex\u0026gt; std::mutex mtx; void criticalSection() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); // 自动管理锁 // 访问共享资源... } // 离开作用域时自动释放锁 std::lock_guard 是 RAII 的一种常见实现，它在对象离开作用域时自动释放锁，从而确保线程同步操作的正确性。\n三、RAII 的优势 RAII 在 C++ 中被广泛应用，原因在于它具备显著的优势：\n3.1 自动管理资源，减少内存泄漏 RAII 最大的优势在于它将资源管理与对象的生命周期绑定，从而避免了忘记释放资源的风险。在资源紧张的场景（如内存、文件句柄、网络连接等），RAII 尤其重要。\n3.2 异常安全性 RAII 提供了强大的异常安全性。在 RAII 模式下，即使函数在执行过程中抛出异常，析构函数也会被自动调用，确保资源被正确释放。这样可以避免因为异常退出导致的资源泄漏。\n3.3 提高代码可维护性 RAII 通过简化资源管理逻辑，使代码更简洁、易于维护。开发者不再需要显式地管理资源释放，减少了手动释放资源的代码量，从而降低了错误发生的几率。\n四、RAII 在现代 C++ 中的应用 随着 C++11 标准的引入，RAII 得到了更广泛的应用和推广，尤其是智能指针（std::unique_ptr, std::shared_ptr）的引入。它们是 RAII 的完美实现，自动管理动态内存的生命周期，极大地减少了手动管理内存的负担。\n4.1 std::unique_ptr std::unique_ptr 是 RAII 的代表，它通过独占所有权的方式管理动态内存，在对象离开作用域时自动释放资源，避免了内存泄漏。\n1 std::unique_ptr\u0026lt;int\u0026gt; ptr(new int(10)); // 创建智能指针管理动态内存 4.2 std::shared_ptr std::shared_ptr 允许多个对象共享同一资源，通过引用计数来管理资源的生命周期。当最后一个 shared_ptr 被销毁时，资源才会被释放。\n1 2 std::shared_ptr\u0026lt;int\u0026gt; p1 = std::make_shared\u0026lt;int\u0026gt;(100); std::shared_ptr\u0026lt;int\u0026gt; p2 = p1; // 共享同一资源 五、结论 RAII 是 C++ 中一种强大且必不可少的编程技术。它通过将资源的获取和释放与对象的生命周期绑定，使资源管理更加自动化和安全。无论是在内存管理、文件操作还是线程同步等领域，RAII 都能有效减少手动管理资源带来的复杂性和潜在错误。\n","permalink":"https://oheyu.github.io/zh/posts/tech/raii%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96/","summary":"在 C++ 编程中，资源管理是一项至关重要的任务，尤其是在内存分配、文件操作、网络连接等与系统资源密切相关的场景中。RAII（Resource Acquisition Is I","title":"RAII：资源获取即初始化"},{"content":"\r在多任务操作系统中，进程间同步和共享资源的管理是至关重要的。信号量（Semaphore）作为一种经典的同步机制，为控制对共享资源的访问提供了一种有效的解决方案，尤其是在避免竞争条件的发生时。\n一、什么是信号量集？ 信号量集（Semaphore Set） 是操作系统中的一种数据结构，它由多个信号量（semaphore）组成。每个信号量集可以包含一个或多个信号量，每个信号量独立用于控制不同的资源或管理不同进程的同步问题。信号量集为开发者提供了一种在同一操作中同时管理多个信号量的机制，简化了多资源同步的操作流程。\n在 Unix 和类 Unix 系统中，信号量集通常用于进程间通信（IPC，Inter-Process Communication）中。与其他 IPC 机制相比，信号量适用于需要频繁同步或控制对共享资源访问的场景，如生产者-消费者模型或资源池管理。\n信号量集在创建时，由操作系统分配一个唯一的标识符（ID），称为 m_semid。该 ID 是后续对信号量集进行所有操作的核心。类似于文件描述符标识一个文件，信号量集的 ID 唯一标识一个信号量集。通过这个唯一的 ID，进程可以对信号量集执行各种操作，如创建、初始化、P（等待）、V（信号）操作，以及删除信号量集。\n拥有这个唯一 ID，多个进程可以同步地操作同一个信号量集，保证共享资源的正确使用和同步操作的有序执行。\n二、信号量集的基本操作 信号量集的基本操作包括创建、初始化、P（等待）操作、V（信号）操作和删除信号量集。下面将依次介绍这些操作，并结合实际代码示例展示如何在 C++ 中使用信号量集。\n2.1 创建信号量集 要创建一个信号量集，首先需要使用 semget 系统调用。这个函数返回一个唯一的信号量集 ID，用于后续的操作。\n1 2 3 4 5 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/sem.h\u0026gt; int semget(key_t key, int nsems, int semflg); key：用于标识信号量集的键值。可以通过 ftok 函数生成，或直接使用整数值。 nsems：信号量集中的信号量个数。 semflg：标志位，指定创建方式。例如 IPC_CREAT 表示如果信号量集不存在则创建。 例如，创建一个包含 1 个信号量的信号量集：\n1 2 3 4 5 6 key_t key = ftok(\u0026#34;pathname\u0026#34;, \u0026#39;A\u0026#39;); // 生成键值 int semid = semget(key, 1, 0666 | IPC_CREAT); // 创建信号量集 if (semid == -1) { perror(\u0026#34;semget failed\u0026#34;); exit(1); } 在此例中，semget 返回信号量集的唯一 ID semid，用于后续的操作。\n2.2 初始化信号量 创建信号量集之后，通常需要初始化信号量的值。我们可以使用 semctl 系统调用来初始化信号量的值。\n1 2 3 #include \u0026lt;sys/sem.h\u0026gt; int semctl(int semid, int semnum, int cmd, ...); semid：信号量集的 ID。 semnum：信号量的编号（从 0 开始）。 cmd：执行的操作命令，如 SETVAL 设置信号量值。 例如，将信号量的值初始化为 1，表示资源是可用的：\n1 2 3 4 if (semctl(semid, 0, SETVAL, 1) == -1) { perror(\u0026#34;semctl SETVAL failed\u0026#34;); exit(1); } 2.3 P（等待）操作和 V（信号）操作 信号量的核心操作是 P 和 V 操作。P 操作会减少信号量的值，表示占用资源；V 操作增加信号量的值，表示释放资源。多个进程之间通过 P 和 V 操作实现对共享资源的同步访问。\n1 2 3 4 5 struct sembuf { unsigned short sem_num; // 信号量编号 short sem_op; // 操作类型：P操作为-1，V操作为+1 short sem_flg; // 操作标志 }; P 操作通过将信号量的值减少 1 来尝试占用资源。如果信号量的值为 0，则进程阻塞，等待资源释放。\n1 2 3 4 5 struct sembuf p = {0, -1, 0}; // 第一个信号量，P操作 if (semop(semid, \u0026amp;p, 1) == -1) { perror(\u0026#34;P operation failed\u0026#34;); exit(1); } V 操作通过将信号量的值增加 1 来释放资源，唤醒等待的进程。\n1 2 3 4 5 struct sembuf v = {0, 1, 0}; // 第一个信号量，V操作 if (semop(semid, \u0026amp;v, 1) == -1) { perror(\u0026#34;V operation failed\u0026#34;); exit(1); } 通过这种方式，我们可以控制多个进程对同一资源的并发访问。\n2.4 删除信号量集 当信号量集不再需要时，可以使用 semctl 来删除它，释放系统资源。\n1 2 3 4 if (semctl(semid, 0, IPC_RMID) == -1) { perror(\u0026#34;semctl IPC_RMID failed\u0026#34;); exit(1); } 删除信号量集可以防止系统中遗留的信号量集占用资源。应确保在所有进程都不再使用该信号量集时再执行删除操作。\n三、实际示例：生产者-消费者问题 生产者-消费者问题是经典的同步问题之一，下面的例子展示了如何使用信号量集解决这一问题。生产者将数据放入共享缓冲区，消费者从缓冲区读取数据，信号量用于确保缓冲区不会被同时读取或写入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/sem.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define BUFFER_SIZE 10 int buffer[BUFFER_SIZE]; int in = 0; int out = 0; void producer(int semid) { struct sembuf p = {0, -1, 0}; struct sembuf v = {0, 1, 0}; for (int i = 0; i \u0026lt; 20; ++i) { semop(semid, \u0026amp;p, 1); // 等待缓冲区有空位 buffer[in] = i; printf(\u0026#34;Produced: %d\\n\u0026#34;, i); in = (in + 1) % BUFFER_SIZE; semop(semid, \u0026amp;v, 1); // 通知消费者 sleep(1); } } void consumer(int semid) { struct sembuf p = {0, -1, 0}; struct sembuf v = {0, 1, 0}; for (int i = 0; i \u0026lt; 20; ++i) { semop(semid, \u0026amp;p, 1); // 等待数据可用 int item = buffer[out]; printf(\u0026#34;Consumed: %d\\n\u0026#34;, item); out = (out + 1) % BUFFER_SIZE; semop(semid, \u0026amp;v, 1); // 通知生产者 sleep(2); } } int main() { key_t key = ftok(\u0026#34;semfile\u0026#34;, \u0026#39;a\u0026#39;); int semid = semget(key, 1, 0666 | IPC_CREAT); semctl(semid, 0, SETVAL, 1); if (fork() == 0) { producer(semid); } else { consumer(semid); wait(NULL); semctl(semid, 0, IPC_RMID); // 删除信号量集 } return 0; } 四、总结 信号量集是 Linux 系统中常用的同步机制之一，广泛应用于进程间通信和共享资源的管理。通过 semget、semctl 和 semop 等系统调用，开发者可以灵活地创建、初始化、操作和删除信号量集。在实际开发中，信号量集能够确保多个进程对共享资源的有序访问，避免竞争条件和死锁等问题。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E4%BF%A1%E5%8F%B7%E9%87%8F/","summary":"在多任务操作系统中，进程间同步和共享资源的管理是至关重要的。信号量（Semaphore）作为一种经典的同步机制，为控制对共享资源的访问提供了","title":"进程间同步：信号量"},{"content":"\r在 Linux 和其他类 Unix 系统中，进程管理是保证系统稳定性和高效运行的重要组成部分。其中，僵尸进程（Zombie Process）是一个特殊但常见的问题。虽然僵尸进程本身不会占用大量系统资源，但它们可能影响系统的性能，甚至在极端情况下导致系统无法创建新进程。\n一、什么是僵尸进程？ 僵尸进程是指已经结束执行，但其进程描述符仍然存在于进程表中的进程。换句话说，僵尸进程已经终止运行，但其在内核中的某些信息（如进程ID、退出状态等）还没有被父进程读取并清除。\n每个进程终止时，操作系统会保留其退出状态等信息，以便父进程通过 wait() 或 waitpid() 函数获取子进程的退出状态。如果父进程没有及时调用这些函数读取子进程的退出信息，子进程的相关条目会继续存在于进程表中，形成僵尸进程。\n虽然僵尸进程不会消耗 CPU 或内存，但它们占用系统的进程ID。系统中的进程ID数量是有限的，过多的僵尸进程会导致系统无法创建新进程，进而影响系统正常运行。\n二、僵尸进程的产生原因 僵尸进程通常在以下情况下产生：\n2.1 父进程没有及时处理子进程的退出信息 当一个子进程终止时，操作系统会发送一个 SIGCHLD 信号给父进程，通知父进程子进程已经结束。此时，父进程可以通过 wait() 或 waitpid() 获取子进程的退出状态并释放其占用的进程表条目。如果父进程忽略了该信号或没有调用这些函数，子进程的信息将无法从进程表中清除，进而产生僵尸进程。\n2.2 父进程未正确处理 SIGCHLD 信号 如果父进程没有捕获或正确处理 SIGCHLD 信号，也会导致子进程在终止后进入僵尸状态。\n2.3 多线程应用程序中不当的线程管理 在多线程应用中，父进程可能会因为管理不当，导致部分子线程在退出时没有及时被回收，从而进入僵尸状态。\n三、僵尸进程的危害 虽然僵尸进程本身不消耗 CPU 或内存，但它们会保留在进程表中，占用系统的有限资源。具体危害包括：\n进程ID资源浪费：每个进程都有一个唯一的进程ID，系统的进程ID是有限的（通常是 32768 或更大），如果系统中存在大量僵尸进程，会消耗大量的进程ID，最终导致系统无法创建新进程。\n系统稳定性降低：如果父进程没有正确处理大量子进程，系统中的僵尸进程数量可能会增加，系统性能和稳定性也可能因此受到影响。\n难以管理的系统资源：僵尸进程的增加会导致进程表变得冗长，影响系统管理进程的效率，增加运维和调试难度。\n四、如何检测僵尸进程 Linux 提供了多种工具可以用于检测系统中的僵尸进程：\n4.1 使用 ps 命令 通过 ps 命令可以轻松检测到系统中的僵尸进程。输出结果中状态标志为 Z 的进程就是僵尸进程。\n1 ps aux | grep \u0026#39;Z\u0026#39; 4.2 使用 top 命令 top 命令也可以用于实时监测系统中的进程。按 z 键可以查看状态为 Z 的进程。\n1 top 在 top 的输出中，僵尸进程会被标记为 Z 状态。\n五、如何预防僵尸进程 5.1 使用 wait() 或 waitpid() 最直接的预防僵尸进程的方式就是父进程在合适的时间调用 wait() 或 waitpid() 来回收子进程的退出状态。这些函数会阻塞父进程，直到有子进程终止，并清理其进程表条目。\n1 2 3 4 5 6 7 8 pid_t pid = fork(); if (pid == 0) { // 子进程执行代码 exit(0); } else if (pid \u0026gt; 0) { // 父进程等待子进程结束 wait(NULL); // wait() 会阻塞，直到子进程结束 } 5.2 忽略 SIGCHLD 信号 通过忽略 SIGCHLD 信号，父进程可以告诉内核不需要保留子进程的退出状态信息，子进程一旦终止，其进程表条目会立即被回收。\n1 signal(SIGCHLD, SIG_IGN); 5.3 捕获并处理 SIGCHLD 信号 父进程可以捕获 SIGCHLD 信号，并在信号处理函数中调用 wait() 或 waitpid()，以非阻塞方式回收子进程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;signal.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void handle_sigchld(int sig) { // 处理所有已终止的子进程，避免产生僵尸进程 while (waitpid(-1, NULL, WNOHANG) \u0026gt; 0); } int main() { signal(SIGCHLD, handle_sigchld); // 捕获 SIGCHLD 信号 pid_t pid = fork(); if (pid == 0) { // 子进程 sleep(2); exit(0); } // 父进程继续执行其他任务 while (1) { // 父进程的主要逻辑 sleep(1); } return 0; } 5.4 采用守护进程 如果父进程本身是长时间运行的进程，但它需要定期生成子进程处理任务，可以让这些子进程的父进程变为 init 进程。通过这种方式，子进程退出时 init 会自动处理其退出状态，防止产生僵尸进程。\n六、僵尸进程的处理方法 如果系统中已经存在僵尸进程，最有效的方式是杀死其父进程。一旦父进程结束，操作系统会将僵尸进程的父进程重新指定为 init 进程（PID 为 1 的进程），init 会自动处理这些僵尸进程。\n可以使用 kill 命令来终止父进程：\n1 kill -s SIGKILL \u0026lt;parent_pid\u0026gt; 终止父进程后，所有属于它的僵尸进程会被系统回收。\n七、总结 僵尸进程虽然不主动占用系统资源，但过多的僵尸进程会耗尽系统的进程ID，影响系统的稳定性和性能。通过正确使用 wait()、waitpid()、SIGCHLD 信号以及合适的进程管理方法，可以有效预防和清理僵尸进程，保证系统的高效运行。\n","permalink":"https://oheyu.github.io/zh/posts/tech/linux%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/","summary":"在 Linux 和其他类 Unix 系统中，进程管理是保证系统稳定性和高效运行的重要组成部分。其中，僵尸进程（Zombie Process）是一个特殊但常见的问题。","title":"Linux的僵尸进程"},{"content":"\r进程间通信（IPC，Inter-Process Communication）是 Linux 操作系统中的一个重要组成部分，它允许多个独立进程之间共享数据、同步行为和发送信号。在复杂的应用程序中，进程往往需要协同工作，因此 IPC 是实现多进程系统中数据共享和同步的基础。\n一、进程间通信的必要性 操作系统中，进程是资源分配的基本单位。每个进程都有自己独立的虚拟地址空间，无法直接访问其他进程的内存。然而，在很多实际应用中，进程需要协同工作，尤其是需要共享数据或同步任务。为了实现这些需求，操作系统提供了多种 IPC 机制。\n常见的 IPC 场景包括：\n数据共享：多个进程需要访问和修改同一份数据，而不进行多次复制。 同步和协调：多个进程需要按照一定顺序执行，或等待特定条件发生。 任务分配：父进程可以将任务分配给子进程或其他工作进程进行处理，并收集结果。 常见的进程间通信需求：\n共享内存和同步：大数据量的实时共享，保证高效、低延迟的数据访问。 任务协调：确保多个进程能够按照正确的次序和条件执行，例如生产者-消费者模型。 事件通知：一个进程发生某个事件时，及时通知其他进程，例如某个系统状态的改变。 二、Linux 进程间通信的机制 Linux 提供了多种 IPC 机制，每种都有其独特的适用场景和特性。下面我们将深入介绍几种主要的 IPC 机制，并讨论它们的应用场景。\n2.1 管道（Pipes） 管道是一种最简单、历史最悠久的 IPC 方式。它可以用于父进程和子进程之间的通信，或者两个具有血缘关系的进程之间的数据传递。\n匿名管道：适合父子进程之间的数据传输。它是单向的：数据只能从一个进程传递到另一个进程。 命名管道（FIFO）：可以在无关进程之间进行双向通信。命名管道有文件系统路径，允许多个进程通过路径访问同一管道。 管道的优点与缺点：\n优点：实现简单，适合轻量级、线性通信任务。 缺点：数据传输是单向的，无法用于复杂的数据同步机制，且只能在本地系统上使用。 示例代码（匿名管道）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int pipefds[2]; char buffer[128]; // 创建匿名管道 pipe(pipefds); // 创建子进程 pid_t pid = fork(); if (pid == 0) { // 子进程向管道写入数据 write(pipefds[1], \u0026#34;Hello from child!\u0026#34;, 18); close(pipefds[1]); // 关闭写端 } else { // 父进程从管道读取数据 read(pipefds[0], buffer, 128); std::cout \u0026lt;\u0026lt; \u0026#34;Parent received: \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; std::endl; close(pipefds[0]); // 关闭读端 } return 0; } 2.2 消息队列（Message Queues） 消息队列是一种允许进程以消息的形式传递数据的 IPC 机制。消息队列通过内核队列存储消息，并按顺序提供给接收进程，允许异步通信。消息队列支持消息的优先级，并且不像管道那样是字节流传输，而是独立消息的传递。\n消息队列的优点与缺点：\n优点：支持异步、持久化的消息传递，消息有结构化。 缺点：需要额外的内核资源管理，复杂度较高。 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/msg.h\u0026gt; struct message { long msg_type; char msg_text[100]; }; int main() { key_t key = ftok(\u0026#34;progfile\u0026#34;, 65); int msgid = msgget(key, 0666 | IPC_CREAT); message msg; msg.msg_type = 1; // 发送消息 std::cin.getline(msg.msg_text, 100); msgsnd(msgid, \u0026amp;msg, sizeof(msg), 0); std::cout \u0026lt;\u0026lt; \u0026#34;Message sent: \u0026#34; \u0026lt;\u0026lt; msg.msg_text \u0026lt;\u0026lt; std::endl; // 接收消息 msgrcv(msgid, \u0026amp;msg, sizeof(msg), 1, 0); std::cout \u0026lt;\u0026lt; \u0026#34;Message received: \u0026#34; \u0026lt;\u0026lt; msg.msg_text \u0026lt;\u0026lt; std::endl; // 删除消息队列 msgctl(msgid, IPC_RMID, NULL); return 0; } 2.3 共享内存（Shared Memory） 共享内存是最高效的 IPC 机制之一，允许多个进程共享同一块内存。它避免了数据拷贝的开销，是处理大数据量通信时的首选。然而，共享内存本身不提供同步机制，通常需要借助信号量或互斥锁来保护数据的同步访问。\n共享内存的优点与缺点\n优点：高效，适合大规模数据共享。 缺点：需要额外的同步机制来防止数据竞争。 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #include \u0026lt;cstring\u0026gt; int main() { key_t key = ftok(\u0026#34;shmfile\u0026#34;, 65); int shmid = shmget(key, 1024, 0666 | IPC_CREAT); char* str = (char*) shmat(shmid, nullptr, 0); std::cout \u0026lt;\u0026lt; \u0026#34;Write Data: \u0026#34;; std::cin.getline(str, 100); std::cout \u0026lt;\u0026lt; \u0026#34;Data written in memory: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; shmdt(str); return 0; } 2.4 信号（Signals） 信号是一种用于异步事件通知的机制。它可以通知一个进程发生了某个事件（如定时器触发、异常情况等），并且可以在进程之间发送控制信号。每个信号都有固定的编号和处理方式。\n信号的优点与缺点\n优点：用于轻量级的异步通知机制，适合事件驱动的程序。 缺点：只能传递有限的信息，信号处理复杂度较高。 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;csignal\u0026gt; #include \u0026lt;unistd.h\u0026gt; void signalHandler(int signum) { std::cout \u0026lt;\u0026lt; \u0026#34;Interrupt signal (\u0026#34; \u0026lt;\u0026lt; signum \u0026lt;\u0026lt; \u0026#34;) received.\u0026#34; \u0026lt;\u0026lt; std::endl; exit(signum); } int main() { signal(SIGINT, signalHandler); // 捕获 Ctrl + C 中断信号 while (1) { std::cout \u0026lt;\u0026lt; \u0026#34;Running...\u0026#34; \u0026lt;\u0026lt; std::endl; sleep(1); } return 0; } 2.5 信号量（Semaphores） 信号量是一种用于进程间同步的机制，主要用于控制多个进程对共享资源的访问。信号量可以是计数信号量（控制资源的使用个数），也可以是二进制信号量（互斥锁），适合用于保护共享内存中的数据读写操作。\n信号量的优点与缺点\n优点：提供强大的同步功能，适合用于进程间竞争控制。 缺点：复杂度较高，需要精细的设计和管理。 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/sem.h\u0026gt; int main() { key_t key = ftok(\u0026#34;semfile\u0026#34;, 65); int semid = semget(key, 1, 0666 | IPC_CREAT); struct sembuf sb = {0, -1, 0}; // P 操作，减少信号量 std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for semaphore...\u0026#34; \u0026lt;\u0026lt; std::endl; semop(semid, \u0026amp;sb, 1); // 等待信号量 std::cout \u0026lt;\u0026lt; \u0026#34;Semaphore acquired!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 2.6 套接字（Sockets） 套接字不仅用于网络通信，还可以用于本地进程间通信。Unix 域套接字（Unix Domain Sockets）允许在同一主机上的进程间高效传递数据，提供了可靠的双向通信机制。\n套接字的优点与缺点\n优点：适合网络通信和本地进程间复杂的双向通信，可靠且灵活。 缺点：实现较为复杂，性能相比共享内存稍差。 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/un.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int sockfd = socket(AF_UNIX, SOCK_STREAM, 0); sockaddr_un addr; addr.sun_family = AF_UNIX; strcpy(addr.sun_path, \u0026#34;/tmp/unix.sock\u0026#34;); connect(sockfd, (sockaddr*)\u0026amp;addr, sizeof(addr)); write(sockfd, \u0026#34;Hello from client\u0026#34;, 18); close(sockfd); return 0; } 三、选择适合的 IPC 机制 选择 IPC 机制取决于应用程序的需求和通信场景：\n管道：适合父子进程之间的简单、线性通信。 消息队列：适合需要异步消息传递的场景，提供结构化的消息传递。 共享内存：适合需要高效共享大量数据的进程，但需要额外的同步机制。 信号：适合轻量级的事件通知和控制。 信号量：适合进程间同步控制，尤其是共享资源的访问。 套接字：适合复杂的、双向的进程通信，尤其是网络通信或跨主机通信。 四、总结 进程间通信是 Linux 系统编程中的一个核心概念。通过理解各种 IPC 机制的特点、适用场景以及如何实现它们，程序员可以有效地构建多进程应用程序。无论是管道、消息队列，还是共享内存、信号、套接字，每种机制都有其独特的优势和局限性。在实际应用中，选择合适的 IPC 机制，并结合同步控制技术，能够确保多进程程序的高效性和稳定性。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/","summary":"进程间通信（IPC，Inter-Process Communication）是 Linux 操作系统中的一个重要组成部分，它允许多个独立进程之间共享数据、","title":"进程间的通信"},{"content":"\r在操作系统中，进程是独立的执行实体，拥有自己的独立地址空间，无法直接访问其他进程的内存。然而，在多进程程序中，有时需要多个进程之间共享数据，传统的文件、管道等通信方式往往伴随较大的系统开销。共享内存（Shared Memory）是进程间通信（IPC）中最高效的一种方式，允许多个进程直接共享一块物理内存空间，从而极大地提高数据传递的速度。\n一、共享内存的基本概念 共享内存是一种将特定的物理内存片段映射到多个进程虚拟地址空间的 IPC 机制。不同于管道或消息队列等需通过系统内核复制数据的方式，进程通过共享内存可以直接访问同一块内存，不需要通过内核中转，因此读写效率极高。\n然而，共享内存本身并不提供同步机制，也就是说，当多个进程并发访问共享内存时，可能会产生数据竞争问题，因此需要借助其他同步机制（如信号量、互斥锁）来确保数据一致性。\n1.1 共享内存的优势 速度快：由于进程可以直接读写同一块内存，因此不需要进行数据复制。 高效：适用于需要频繁、大量传递数据的场景。 简单的内存模型：共享内存只需一次分配，多个进程就可以同时访问相同的数据。 1.2 共享内存的不足 无同步机制：共享内存没有自带的锁机制，需要额外的同步工具来防止数据竞争。 需要手动管理：进程退出后，必须显式释放共享内存，避免内存泄漏。 内存受限：共享内存的大小通常受系统参数（如 SHMMAX）限制，需合理分配和使用。 二、Linux 中的共享内存系统调用 在 Linux 中，使用共享内存需要借助一组系统调用，这些系统调用提供了从创建、映射到销毁共享内存的完整流程。\n2.1 shmget: 创建或获取共享内存段 shmget 函数用于创建或获取共享内存段。它返回一个共享内存标识符（shmid），该标识符将用于后续的操作。\n1 int shmget(key_t key, size_t size, int shmflg); key：标识共享内存的键值。多个进程通过相同的键值来访问同一块共享内存。 size：共享内存的大小（以字节为单位）。 shmflg：权限和创建标志，常用 0666 | IPC_CREAT，表示可读写并创建共享内存（若不存在）。 返回值：成功时返回共享内存段的 ID（shmid），失败时返回 -1。\n2.2 shmat: 将共享内存连接到进程地址空间 shmat 函数用于将共享内存段连接到当前进程的地址空间中，成功后返回一个指向共享内存的指针，进程可以通过该指针读写共享内存。\n1 void *shmat(int shmid, const void *shmaddr, int shmflg); shmid：由 shmget 返回的共享内存段标识符。 shmaddr：指定共享内存连接到进程地址空间的地址，通常设为 nullptr，由操作系统自动选择合适的地址。 shmflg：连接标志，常用 0。 返回值：成功时返回共享内存的指针，失败时返回 (void*)-1。\n2.3 shmdt: 从进程地址空间分离共享内存 shmdt 函数用于将共享内存段从当前进程的地址空间分离。\n1 int shmdt(const void *shmaddr); shmaddr：共享内存的起始地址，由 shmat 返回。 返回值：成功时返回 0，失败时返回 -1。\n2.4 shmctl: 控制共享内存段 shmctl 函数用于控制共享内存段的行为，最常见的用法是删除共享内存段，释放系统资源。\n1 int shmctl(int shmid, int cmd, struct shmid_ds *buf); shmid：共享内存标识符。 cmd：控制命令，常用 IPC_RMID 删除共享内存段。 buf：与共享内存段相关的信息结构体，用于设置或读取共享内存段的状态。 返回值：成功时返回 0，失败时返回 -1。\n三、共享内存示例：进程间数据共享 接下来通过一个简单的示例程序演示如何使用共享内存实现进程间通信。一个进程写入数据到共享内存，另一个进程读取这些数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; // 定义共享内存结构体 struct SharedData { int num; char message[100]; }; int main() { // 1. 创建共享内存段 int shmid = shmget(0x1234, sizeof(SharedData), 0666 | IPC_CREAT); if (shmid == -1) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to create shared memory.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // 2. 将共享内存连接到当前进程的地址空间 SharedData *data = static_cast\u0026lt;SharedData*\u0026gt;(shmat(shmid, nullptr, 0)); if (data == (void*)-1) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to attach shared memory.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // 3. 写入数据到共享内存 data-\u0026gt;num = 42; std::strcpy(data-\u0026gt;message, \u0026#34;Hello from shared memory!\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;Data written to shared memory: num = \u0026#34; \u0026lt;\u0026lt; data-\u0026gt;num \u0026lt;\u0026lt; \u0026#34;, message = \u0026#34; \u0026lt;\u0026lt; data-\u0026gt;message \u0026lt;\u0026lt; std::endl; // 4. 分离共享内存段 shmdt(data); return 0; } 上述代码说明如下：\n创建共享内存段：通过 shmget 创建大小为 SharedData 的共享内存段，键值为 0x1234。 连接共享内存：使用 shmat 将共享内存映射到当前进程的地址空间。 写入数据：将数据写入共享内存中的 num 和 message 字段。 分离共享内存：调用 shmdt 函数，将共享内存从当前进程的地址空间中分离。 另一个进程读取共享内存数据如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; struct SharedData { int num; char message[100]; }; int main() { // 1. 获取已经存在的共享内存段 int shmid = shmget(0x1234, sizeof(SharedData), 0666); if (shmid == -1) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to retrieve shared memory.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // 2. 将共享内存连接到当前进程的地址空间 SharedData *data = static_cast\u0026lt;SharedData*\u0026gt;(shmat(shmid, nullptr, 0)); if (data == (void*)-1) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to attach shared memory.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // 3. 读取共享内存中的数据 std::cout \u0026lt;\u0026lt; \u0026#34;Data read from shared memory: num = \u0026#34; \u0026lt;\u0026lt; data-\u0026gt;num \u0026lt;\u0026lt; \u0026#34;, message = \u0026#34; \u0026lt;\u0026lt; data-\u0026gt;message \u0026lt;\u0026lt; std::endl; // 4. 分离共享内存段 shmdt(data); return 0; } 上述代码说明如下：\n获取共享内存段：通过 shmget 获取已经存在的共享内存段，键值为 0x1234。 连接共享内存：使用 shmat 连接共享内存，允许进程访问数据。 读取数据：读取共享内存中的 num 和 message。 分离共享内存：通过 shmdt 将共享内存从当前进程分离。 四、共享内存中的注意事项 同步问题：共享内存并不提供同步机制。如果多个进程同时访问共享内存，可能会导致数据竞争。应使用同步机制（如信号量、互斥锁）来保证数据的一致性。\n清理工作：不要忘记在进程结束时使用 shmdt 分离共享内存，并在最后一个进程完成后使用 shmctl 释放共享内存，避免内存泄漏。\n内存限制：共享内存的大小受到系统设置的限制，如 SHMMAX，需要管理员权限来调整这些限制。\n安全性问题：共享内存段可以通过键值共享，因此应设置合适的权限以避免未经授权的进程访问。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%88%9D%E6%8E%A2/","summary":"在操作系统中，进程是独立的执行实体，拥有自己的独立地址空间，无法直接访问其他进程的内存。然而，在多进程程序中，有时需要多个进程之间共享数据，","title":"共享内存初探"},{"content":"\r在 Linux 系统编程中，fork() 函数是创建新进程的基础工具之一。它允许进程在运行时创建自己的副本，即子进程，从而实现并行处理。今天，我们来详细探讨 fork() 的工作原理，为什么子进程与父进程共享相同的虚拟地址空间，但实际使用的物理内存是独立的。\n一、什么是 fork() 函数？ fork() 是 Linux/UNIX 系统中创建新进程的系统调用。它会复制调用它的进程，生成一个几乎完全相同的副本。调用 fork() 的进程被称为父进程，新创建的进程被称为子进程。fork() 函数的声明如下：\n1 pid_t fork(void); 该函数的返回值有三种情况：\n父进程中返回子进程的PID：在父进程中，fork() 返回新创建子进程的进程 ID（PID）。 子进程中返回0：在子进程中，fork() 返回 0。 失败返回-1：如果 fork() 失败，返回 -1，并设置 errno 以标识错误原因。 二、虚拟内存与物理内存的概念 为了理解 fork() 函数的行为，首先需要了解虚拟内存和物理内存之间的关系。\n虚拟内存：每个进程都拥有独立的虚拟地址空间，操作系统通过虚拟内存机制，使得每个进程看起来拥有整个内存空间的独占权限。虚拟地址空间与实际的物理内存是分离的，虚拟地址通过操作系统和硬件（内存管理单元，MMU）映射到物理内存。\n物理内存：这是系统中的实际内存，存放程序的运行数据。虚拟内存中的地址通过硬件和操作系统的转换映射到物理内存的实际地址。\n通过虚拟内存，多个进程可以独立运行，不会相互影响，同时也实现了进程间的内存隔离和资源共享。\n三、fork() 函数的核心工作原理 当你调用 fork() 时，系统会执行以下步骤来创建子进程：\n复制虚拟地址空间：子进程的虚拟地址空间是父进程的精确副本。它包含相同的代码段、数据段和堆栈，虚拟地址一一对应。但是，子进程和父进程有各自独立的虚拟内存视图，彼此之间不会直接影响。\n写时复制（Copy-On-Write, COW）：为了节省资源，fork() 并不会立即为子进程分配新的物理内存。相反，父进程和子进程共享同一块物理内存。这种共享仅限于只读的内容（如代码段），当子进程或父进程尝试写入时，操作系统会将共享的物理页复制到新的内存位置。这种机制称为写时复制，极大地提高了内存利用效率。\n子进程继承父进程资源：子进程继承了父进程的大部分资源，包括打开的文件描述符、环境变量、信号处理程序等。但与父进程不同，子进程有自己独立的进程 ID、父进程 ID 以及一些与进程管理相关的信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; int main() { int x = 0; // 变量 x 会被父子进程共享 pid_t pid = fork(); if (pid == -1) { std::cerr \u0026lt;\u0026lt; \u0026#34;Fork failed!\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } else if (pid == 0) { // 子进程 x++; std::cout \u0026lt;\u0026lt; \u0026#34;Child process: x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } else { // 父进程 wait(NULL); // 等待子进程结束 std::cout \u0026lt;\u0026lt; \u0026#34;Parent process: x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } return 0; } 在这个例子中，变量 x 在 fork() 之后会在父进程和子进程中分别存在。由于写时复制的机制，子进程中的 x 只有在被修改时才会被复制，导致父子进程中的 x 变得不同。\n四、为什么子进程与父进程的虚拟地址空间相同？ 一致性与简化进程模型：当 fork() 创建子进程时，子进程继承了父进程的执行上下文。如果子进程的虚拟地址与父进程不同，那么所有引用代码或数据的指针、引用都会失效，这将大大增加系统维护和编程的复杂性。保持子进程与父进程的虚拟地址一致，简化了进程模型。\n资源共享的高效管理：虚拟地址空间相同，可以让父子进程通过写时复制机制有效地共享资源。当进程只读取数据时，物理内存的共享不会被破坏，减少了内存的开销。当进程写入数据时，只有被写的页面会被复制到新的物理内存中，避免了不必要的开销。\n进程隔离与安全性：尽管父子进程拥有相同的虚拟地址空间，但通过操作系统的内存管理机制，父子进程的物理内存是独立的。即使某个进程修改了数据，它的修改也不会影响到另一个进程。\n五、fork() 的实际应用场景 fork() 函数通常用于创建多进程的应用程序。在许多经典的 UNIX 工具和服务器程序中，fork() 被用来创建并行任务。\n5.1 Web 服务器中的 fork() 许多早期的 Web 服务器使用 fork() 创建一个新的子进程来处理每个传入的客户端请求。这样，服务器可以同时处理多个客户端请求，父进程负责监听新的连接，子进程处理每个连接的请求。\n5.2 多任务处理 通过 fork() 创建多个子进程，系统可以同时执行多个任务。每个子进程拥有独立的资源和进程状态，可以并发执行。\n5.3 进程隔离 fork() 也被用于实现进程隔离，使得不同的进程可以在同一台机器上运行而不会相互干扰。例如，fork() 常用于实现 shell 的子进程，用户可以在 shell 中运行各种命令，而不会影响到 shell 本身。\n六、fork() 示例：父进程与子进程的基本行为 以下是一个 fork() 函数的简单示例，演示了如何创建子进程，以及父进程和子进程如何并行运行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; int main() { pid_t pid = fork(); if (pid == -1) { std::cerr \u0026lt;\u0026lt; \u0026#34;Fork failed!\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } else if (pid == 0) { // 子进程代码 std::cout \u0026lt;\u0026lt; \u0026#34;Child process with PID: \u0026#34; \u0026lt;\u0026lt; getpid() \u0026lt;\u0026lt; std::endl; sleep(2); // 模拟子进程的工作 std::cout \u0026lt;\u0026lt; \u0026#34;Child process exiting...\u0026#34; \u0026lt;\u0026lt; std::endl; } else { // 父进程代码 std::cout \u0026lt;\u0026lt; \u0026#34;Parent process with PID: \u0026#34; \u0026lt;\u0026lt; getpid() \u0026lt;\u0026lt; \u0026#34;, waiting for child...\u0026#34; \u0026lt;\u0026lt; std::endl; wait(NULL); // 等待子进程结束 std::cout \u0026lt;\u0026lt; \u0026#34;Child process finished. Parent process continuing...\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 在这个示例中，父进程通过 fork() 创建了一个子进程。父进程继续执行，并等待子进程结束后再继续自己的工作。子进程则在 sleep(2) 模拟工作后退出。\n七、总结 fork() 是 Linux 系统中用于创建新进程的基本系统调用，子进程与父进程共享相同的虚拟地址空间，但实际的物理内存是独立的。 写时复制（COW）机制允许父子进程共享相同的物理内存，直到某一方尝试写入时才进行内存的实际复制，从而提高了内存利用效率。 通过 fork()，程序可以并发处理任务、实现进程隔离，并灵活地控制资源管理。 ","permalink":"https://oheyu.github.io/zh/posts/tech/fork%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","summary":"在 Linux 系统编程中，fork() 函数是创建新进程的基础工具之一。它允许进程在运行时创建自己的副本，即子进程，从而实现并行处理。今天，我们来详细探","title":"Fork函数的工作原理"},{"content":"\r最近写代码，对左值（lvalue） 和 右值（rvalue） 两个概念感到有些拿不准，总结一下。\n一、左值（lvalue）与右值（rvalue）的基本定义 1.1 左值（lvalue） 左值是指具有持久内存地址的对象。通俗地讲，左值代表的是可以“被赋值”的对象，它们通常是变量或可以通过引用访问的对象。左值具备持久性，可以通过引用或指针操作，因此它们可以出现在赋值语句的左侧。\n左值拥有明确的内存位置，并且可以重复使用。 它们通常是标识符（如变量）或对象的引用。 1 2 int a = 42; // 变量 a 是左值，它有一个明确的内存地址 a = 100; // 这里，a 在赋值语句的左侧，它是左值 1.2 右值（rvalue） 右值是指那些没有持久内存地址的临时值或表达式的结果。它们通常是不能被赋值的，因此不能出现在赋值表达式的左侧。右值的生命周期短暂，通常在表达式求值后便会销毁。\n右值不具备持久性，常常是临时对象或字面常量。 右值通常出现在表达式的右侧，例如数字常量、函数的返回值或算术表达式的结果。 1 2 int b = 5 + 3; // 这里的 5 + 3 是右值，它没有持久的内存地址 int c = 42; // 42 是字面常量，也是右值 二、左值与右值的特性对比 特性 左值（lvalue） 右值（rvalue） 持久性 左值具有持久内存地址，可通过指针或引用访问 右值是临时对象，通常在表达式求值后销毁 赋值能力 左值可以出现在赋值表达式的左侧 右值不能作为赋值表达式的左侧 可引用性 左值可以通过左值引用（T\u0026amp;）来引用 右值只能通过右值引用（T\u0026amp;\u0026amp;，C++11 引入）引用 典型示例 变量、指针、对象引用 常量、临时对象、表达式的结果 三、左值与右值在函数参数中的应用 3.1 左值引用（lvalue reference） C++ 中的左值引用（T\u0026amp;）允许函数通过引用参数操作调用者的对象，这样可以避免对象拷贝，提升效率。通过左值引用，函数可以直接操作左值对象。\n1 2 3 4 5 6 7 8 9 void modify(int\u0026amp; x) { x += 10; } int main() { int a = 5; modify(a); // a 是左值，被传递给左值引用参数 return 0; } 在上例中，modify 函数通过引用直接修改了 a，避免了对象拷贝。\n3.2 右值引用（rvalue reference） C++11 引入了右值引用（T\u0026amp;\u0026amp;），允许右值也可以被引用。右值引用的最大应用场景是移动语义，即通过移动而不是复制来处理资源，从而优化程序性能，特别是在处理大对象或容器时。\n1 2 3 4 5 6 7 8 void process(int\u0026amp;\u0026amp; x) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing rvalue: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } int main() { process(5); // 5 是右值，可以传递给右值引用参数 return 0; } 在上述代码中，process 函数接受一个右值引用，它可以安全地操作临时对象，避免不必要的拷贝。\n四、移动语义与右值引用 移动语义是 C++11 引入的一个重要特性，允许通过 “移动” 而不是 “拷贝” 来传递或返回对象的资源，避免了大量的内存分配和数据拷贝操作，极大地提高了性能。\n在实现移动语义时，右值引用提供了基础支持。通过移动构造函数和移动赋值操作符，程序员可以实现资源从一个对象转移到另一个对象。\n1 2 3 4 5 6 class MyClass { public: MyClass() { /* 构造函数 */ } MyClass(MyClass\u0026amp;\u0026amp; other) noexcept { /* 移动构造函数 */ } MyClass\u0026amp; operator=(MyClass\u0026amp;\u0026amp; other) noexcept { /* 移动赋值操作符 */ return *this; } }; 在移动语义中，资源（如动态分配的内存、文件句柄等）可以从一个对象移动到另一个对象，而不会进行深拷贝，这在处理大数据对象时尤为高效。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; // std::move int main() { std::vector\u0026lt;int\u0026gt; v1 = {1, 2, 3}; std::vector\u0026lt;int\u0026gt; v2 = std::move(v1); // v1 的资源被移动到 v2 std::cout \u0026lt;\u0026lt; \u0026#34;v1 size: \u0026#34; \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; std::endl; // v1 现在为空 std::cout \u0026lt;\u0026lt; \u0026#34;v2 size: \u0026#34; \u0026lt;\u0026lt; v2.size() \u0026lt;\u0026lt; std::endl; // v2 拥有原来 v1 的数据 } std::move 将左值显式地转换为右值引用，触发对象的移动语义。上例中，v1 的资源被移动到 v2，而不是通过拷贝来传递。\n五、完美转发与 std::forward 完美转发（perfect forwarding）是 C++11 中另一项重要的功能，它允许函数模板将其参数完美地转发给其他函数，保持参数的左值或右值特性。实现完美转发的关键工具是 std::forward。\n1 2 3 4 5 6 7 #include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; // std::forward template \u0026lt;typename T\u0026gt; void wrapper(T\u0026amp;\u0026amp; arg) { process(std::forward\u0026lt;T\u0026gt;(arg)); // 完美转发 } 在这个例子中，wrapper 函数可以将 arg 的左值/右值特性保留并传递给 process，确保调用时不会发生不必要的拷贝或移动操作。\n六、左值、右值与 C++ 标准库 C++ 标准库在许多地方使用了左值和右值引用的概念来优化性能。最常见的例子是 STL 容器，如 std::vector、std::string 等，它们通过移动构造函数和移动赋值操作符来避免不必要的拷贝。\n使用 std::move 和移动语义：\n1 2 std::string s1 = \u0026#34;Hello\u0026#34;; std::string s2 = std::move(s1); // s1 的内容被移动到 s2 此外，std::forward 用于实现完美转发，帮助标准库函数（如 std::bind 和 std::function）保持参数的左右值属性。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/","summary":"最近写代码，对左值（lvalue） 和 右值（rvalue） 两个概念感到有些拿不准，总结一下。 一、左值（lvalue）与右值（rvalue）的基","title":"左值与右值"},{"content":"\r在现代 C++ 多线程编程中，锁机制是确保线程安全访问共享资源的关键手段。C++ 标准库为开发者提供了多种锁管理工具，其中最常用的是 std::lock_guard 和 std::unique_lock。这两个类都用于管理互斥锁（std::mutex），以确保多个线程对共享资源的同步访问，但它们在使用场景和灵活性方面存在显著的差异。\n一、什么是 std::lock_guard？ std::lock_guard 是 C++ 标准库中的一个轻量级工具，用于在一个作用域中管理互斥锁的生命周期。它在构造时自动锁定互斥锁，在销毁时自动解锁。这个工具的最大优势在于其简洁性和自动化管理，使得锁定和解锁的过程更加安全，避免了常见的手动锁管理错误。\n1.1 std::lock_guard 的基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx; void safe_increment(int\u0026amp; counter) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); // 自动锁定互斥锁 ++counter; // 安全访问共享资源 } // 作用域结束时自动解锁 int main() { int counter = 0; safe_increment(counter); std::cout \u0026lt;\u0026lt; \u0026#34;Counter: \u0026#34; \u0026lt;\u0026lt; counter \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，std::lock_guard 确保了在函数结束时，无论是正常退出还是因为异常提前退出，互斥锁都能够自动解锁。这种方式减少了手动管理锁的复杂性，确保线程安全。\n1.2 std::lock_guard 的主要特点 简单高效：一旦创建，锁定和解锁是自动化的，使用非常方便。 不可移动、不可复制：它的生命周期严格绑定到作用域，不能被移动或复制。 无手动解锁功能：一旦创建后，std::lock_guard 将一直持有锁，直到作用域结束时自动释放。 二、什么是 std::unique_lock？ std::unique_lock 是 C++ 标准库中更灵活的锁管理器，提供了对互斥锁的手动控制，包括延迟锁定、手动解锁和重新锁定的功能。与 std::lock_guard 相比，std::unique_lock 的灵活性使得它能够应对更复杂的线程同步场景，特别是在与条件变量（std::condition_variable）一起使用时。\n2.1 std::unique_lock 的基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx; void safe_increment(int\u0026amp; counter) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); // 锁定互斥锁 ++counter; // 安全访问共享资源 lock.unlock(); // 手动解锁 // 进行非线程安全的操作 lock.lock(); // 重新锁定 ++counter; // 再次线程安全地访问共享资源 } int main() { int counter = 0; safe_increment(counter); std::cout \u0026lt;\u0026lt; \u0026#34;Counter: \u0026#34; \u0026lt;\u0026lt; counter \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，std::unique_lock 提供了手动解锁和重新锁定的功能，使得开发者可以灵活地控制锁的持有时间和范围。这在处理复杂同步逻辑时非常有用。\n2.2 std::unique_lock 的主要特点 延迟锁定：可以在构造时选择不锁定互斥锁，后续手动锁定。 手动解锁：提供了 unlock() 方法，可以在需要时手动释放锁。 重新锁定：可以通过 lock() 方法在需要时重新获得锁。 可移动：std::unique_lock 支持移动语义，允许在不同的作用域之间传递或存储在容器中。 三、std::lock_guard 与 std::unique_lock 的区别 尽管 std::lock_guard 和 std::unique_lock 都是用于管理互斥锁的工具，但它们在灵活性和功能上有很大不同：\n特性 std::lock_guard std::unique_lock 锁定时机 构造时立即锁定 可延迟锁定 解锁方式 作用域结束时自动解锁 可手动解锁，也可在作用域结束时解锁 可移动性 不可移动 可移动 灵活性 简单，不灵活 更灵活，支持手动锁定和解锁 适用条件变量 不支持 支持，与条件变量一起使用 四、为什么条件变量需要 std::unique_lock 条件变量（std::condition_variable）是多线程编程中的一种常见同步机制，用于让线程在等待某个条件时进入等待状态，并在条件满足时继续执行。为了正确使用条件变量，需要能暂时释放互斥锁，以便其他线程能够修改条件。因此，必须使用 std::unique_lock 而不能使用 std::lock_guard，原因如下：\n条件变量需要释放锁：在调用 wait() 时，条件变量会临时释放锁以允许其他线程获取互斥锁并改变条件。std::lock_guard 无法手动释放锁，因此无法与条件变量一起使用，而 std::unique_lock 提供了这种灵活性。\n复杂的同步逻辑：条件变量通常用于实现复杂的线程同步逻辑，std::unique_lock 的手动锁定、解锁功能使得它可以应对这些复杂场景。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; std::mutex mtx; std::condition_variable cv; bool ready = false; void worker_thread() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); // 使用 unique_lock 锁定互斥锁 cv.wait(lock, []{ return ready; }); // 等待条件变量，自动释放并重新获得锁 std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is processing data\u0026#34; \u0026lt;\u0026lt; std::endl; } void set_ready() { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟一些工作 { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); // 使用 lock_guard 简单保护 ready = true; } cv.notify_one(); // 通知等待中的线程 } int main() { std::thread t1(worker_thread); std::thread t2(set_ready); t1.join(); t2.join(); return 0; } 在这个例子中，worker_thread 使用 std::unique_lock 与条件变量一起工作。当 cv.wait() 被调用时，它会释放锁并等待条件变量的通知。set_ready 线程通过 notify_one() 通知条件变量，唤醒等待中的线程。\n五、总结 std::lock_guard 提供了一种简洁的方式来管理互斥锁，适合用于简单的锁定场景。它的生命周期严格绑定到作用域，使用非常安全，但不适合处理需要手动控制锁的复杂场景。\nstd::unique_lock 提供了更大的灵活性，允许开发者手动锁定和解锁互斥锁，适合于复杂的多线程场景，特别是在需要条件变量时使用。\n","permalink":"https://oheyu.github.io/zh/posts/tech/lock_guard%E4%B8%8Eunique_lock/","summary":"在现代 C++ 多线程编程中，锁机制是确保线程安全访问共享资源的关键手段。C++ 标准库为开发者提供了多种锁管理工具，其中最常用的是 std::lock_guard 和 std::un","title":"Lock_guard与unique_lock"},{"content":"\r在 C++ 中，const和constexpr是两个非常重要的关键字，它们的主要功能是保证变量和表达式在不同上下文中的不可修改性。然而，虽然这两个关键字有相似之处，但它们在实现和使用场景上有显著的不同。\n一、什么是 const？ const 关键字用于声明不可修改的变量，确保一旦初始化后变量的值不会再被改变。其初始化既可以在编译时完成，也可以在运行时进行，具体取决于初始值是否在编译时已知。\n运行时或编译时初始化：const 变量的值可以在编译时或运行时确定。 不可修改性：一旦初始化，变量的值不可更改。 作用域灵活：const 变量可以出现在局部和全局作用域中。 1 2 const int a = 42; // 编译时常量 const int b = getValue(); // 运行时常量，getValue() 在运行时返回值 二、什么是 constexpr？ C++11 引入了 constexpr 关键字，用于定义编译时常量表达式。与 const 不同，constexpr 保证变量的初始化必须在编译时完成，并且可以用于函数，确保函数在编译时进行求值。\n编译时计算：constexpr 变量的值必须在编译时确定，适用于编译期常量的场景。 函数修饰：constexpr 可以修饰函数，允许函数在编译期执行计算。 更严格的限制：constexpr 只能用于常量表达式，因此比 const 更严格。 1 2 constexpr int x = 10; // 编译时常量 constexpr int y = square(5); // 调用 constexpr 函数，编译时求值 三、const 与 constexpr 的主要区别 特性 const constexpr 初始化时间 编译时或运行时 只能在编译时 可修改性 不可修改 不可修改 应用场景 运行时常量或编译时常量 仅编译时常量 函数修饰 不适用 可用于修饰函数，使其在编译时求值 灵活性 可以与运行时数据配合使用 只能与编译时确定的数据使用 适用范围 可以在大多数上下文中使用 仅适用于需要编译时常量的上下文 错误处理 运行时可能抛出错误 编译时即检测到错误，减少运行时错误 四、对比示例：const 与 constexpr 的使用 通过一个实际示例进一步对比它们的使用场景：\n1 2 3 4 5 const int a = 42; // a 是编译时或运行时常量 constexpr int b = 10; // b 是编译时常量 int arr1[a]; // 如果 a 是运行时常量，数组声明可能非法 int arr2[b]; // 合法，b 是编译时常量 在此例中，a 的初始化可以在运行时确定，因此在某些场景下不能用作编译时常量。而 b 通过 constexpr 定义，保证其在编译时确定，因此可以用作数组大小。\n五、const 与 constexpr 的适用场景 5.1 什么时候使用 const 当你不需要编译时常量，但希望变量在整个程序执行过程中不可修改时，使用 const。 const 适用于大多数需要不可变性的场景，例如配置参数或局部不可修改的变量。 1 2 const int max_connections = 100; const std::string config = readConfig(); // 配置文件的内容在运行时读取 5.2 什么时候使用 constexpr 当你需要编译时常量，例如数组大小、模板参数或用于优化计算的常量时，使用 constexpr。 constexpr 保证了值在编译时确定，可以用于需要编译期计算的复杂函数中。 1 2 3 4 5 6 7 constexpr int max_buffer_size = 1024; constexpr int square(int x) { return x * x; } int buffer[square(32)]; // 使用编译时常量进行数组声明 六、总结 const：适用于任何需要不可修改值的场合，可以在运行时或编译时初始化，但在运行时使用时并不一定是编译时常量。 constexpr：更严格的关键字，确保变量或函数在编译时求值，适合用于性能优化以及编译期常量的场景。 ","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84const%E4%B8%8Econstexpr/","summary":"在 C++ 中，const和constexpr是两个非常重要的关键字，它们的主要功能是保证变量和表达式在不同上下文中的不可修改性。然而，虽然这两个关","title":"CPP中的const与constexpr"},{"content":"\rsizeof 运算符是一个极为常用且强大的工具。它能够在编译时计算任意数据类型或对象在内存中占用的字节数。\n一、什么是 sizeof 运算符？ sizeof 是一个内置于 C++ 的运算符，用于获取数据类型或对象在内存中所占的字节数。它在编译时计算结果，意味着无需等待运行时，就能确定某一类型或对象的大小。这一特性使得 sizeof 在系统编程、内存管理及平台无关的编程中扮演了重要角色。\n二、sizeof 运算符的使用场景 2.1 基本数据类型 C++ 提供了多个基本数据类型（如 int、char、float、double 等），不同的平台可能为相同的数据类型分配不同大小的内存。通过 sizeof，我们可以在编译时确定数据类型在当前平台上的大小。\n1 2 3 std::cout \u0026lt;\u0026lt; \u0026#34;Size of int: \u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Size of char: \u0026#34; \u0026lt;\u0026lt; sizeof(char) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Size of double: \u0026#34; \u0026lt;\u0026lt; sizeof(double) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; 不出幺蛾子的话，在 32 位系统上，int 通常占用 4 个字节，而 double 可能占用 8 个字节。不同编译器和平台的差异使得 sizeof 成为编写可移植代码的关键工具。\n2.2 用户定义的类型（结构体和类） sizeof 还可以用于计算用户定义类型（如 struct、class、union）的大小。这在系统编程中尤为重要，帮助我们理解复杂数据结构在内存中的布局。需要注意的是，结构体的大小可能会因编译器的内存对齐（padding）策略而变化。\n1 2 3 4 5 6 7 struct MyStruct { int a; char b; double c; }; std::cout \u0026lt;\u0026lt; \u0026#34;Size of MyStruct: \u0026#34; \u0026lt;\u0026lt; sizeof(MyStruct) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; 内存对齐和填充：在某些系统上，为了提高内存访问效率，编译器可能会在结构体的成员之间插入填充字节（padding）。这使得结构体的实际大小通常大于其成员的字节和。了解这一机制对优化数据结构在系统内存中的布局尤为重要。\n2.3 数组 使用 sizeof 可以获取数组的总大小（即元素大小乘以数组元素个数）。但必须注意，sizeof 只能返回静态数组的总大小。如果数组是动态分配的，sizeof 只会返回指针的大小，而不是数组的大小。\n1 2 int arr[10]; std::cout \u0026lt;\u0026lt; \u0026#34;Size of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; 重要注意：如果数组是通过指针传递给函数的，sizeof 返回的将是指针的大小，而不是数组的大小。这一点对于处理动态内存分配尤为重要。\n2.4 指针 sizeof 可以用于指针类型，返回指针本身的大小，而不是指针所指向的数据类型的大小。通常在 32 位系统上，指针大小为 4 字节；而在 64 位系统上，指针大小为 8 字节。\n1 2 int* ptr; std::cout \u0026lt;\u0026lt; \u0026#34;Size of pointer: \u0026#34; \u0026lt;\u0026lt; sizeof(ptr) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; 无论指针指向的是什么类型的数据，sizeof 返回的始终是指针本身的大小。这在动态内存分配中，尤其是多级指针的使用时，需要特别注意。\n2.5 字符串字面量 C++ 支持使用 sizeof 获取字符串字面量的大小，这包括字符串本身的字符数以及末尾的空字符 \\0。\n1 std::cout \u0026lt;\u0026lt; \u0026#34;Size of string literal \u0026#39;Hello\u0026#39;: \u0026#34; \u0026lt;\u0026lt; sizeof(\u0026#34;Hello\u0026#34;) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; // 输出 6 在这个例子中，sizeof(\u0026quot;Hello\u0026quot;) 返回的大小为 6，因为它包括了末尾的空字符 \\0。\n三、sizeof 运算符的限制 尽管 sizeof 是一个非常强大的工具，但它并非在所有场景下都适用。在某些特殊情况下，使用 sizeof 会产生意料之外的结果。\n3.1 动态分配的数组 对于动态分配的数组，sizeof 返回的仅仅是指针的大小，而不是数组的大小。这是因为 sizeof 无法在编译时确定堆上分配的数组的大小。\n1 2 3 int* arr = new int[10]; std::cout \u0026lt;\u0026lt; \u0026#34;Size of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; // 返回指针的大小，而不是数组的大小 delete[] arr; 解决方案：如果需要获取动态数组的大小，可以通过额外的变量存储数组的长度，或使用 C++ 提供的标准容器（如 std::vector），它们可以在运行时管理数组的大小。\n3.2 不完全类型 sizeof 不能用于不完全类型（Incomplete Type），如前向声明的类或结构体。这是因为编译器无法知道不完全类型的内存布局。\n1 2 3 struct MyStruct; // 前向声明 // std::cout \u0026lt;\u0026lt; sizeof(MyStruct) \u0026lt;\u0026lt; std::endl; // 错误，MyStruct 是不完全类型 尝试对不完全类型使用 sizeof 会导致编译错误，因此必须确保类型在使用 sizeof 之前已经完全定义。\n3.3 函数 sizeof 运算符不能用于函数类型。函数本质上是指向内存中的一段指令，sizeof 只能操作数据类型或对象，而不能直接获取函数的大小。\n1 2 3 void myFunction() {} // std::cout \u0026lt;\u0026lt; sizeof(myFunction) \u0026lt;\u0026lt; std::endl; // 错误，不能对函数使用 sizeof 四、特殊情况：虚函数表指针的大小 对于包含虚函数的类，编译器会在类的对象中添加一个指向虚函数表的指针（vptr）。这个指针占用了内存，且 sizeof 计算的对象大小包含了 vptr，开发者也无法直接访问或操作它的大小。\n1 2 3 4 5 class Base { virtual void func() {} }; std::cout \u0026lt;\u0026lt; \u0026#34;Size of Base: \u0026#34; \u0026lt;\u0026lt; sizeof(Base) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; 在这个例子中，sizeof(Base) 返回的是包含虚函数表指针的对象大小。\n五、sizeof 的其他最佳实践 在编译时确定大小：sizeof 在编译时执行，因此其结果在运行时是不可变的。这意味着 sizeof 可以用于数组声明、静态断言和模板元编程中，提供了极大的灵活性和性能优化。\n与 decltype 结合使用：在 C++11 及更高版本中，sizeof 可以与 decltype 结合使用，以确保类型的安全性。例如：\n1 2 int x = 5; std::cout \u0026lt;\u0026lt; \u0026#34;Size of x: \u0026#34; \u0026lt;\u0026lt; sizeof(decltype(x)) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; 括号使用：对于类型名，必须使用括号，如 sizeof(int)；而对于变量，括号是可选的，如 sizeof x 和 sizeof(x) 都是合法的。\n","permalink":"https://oheyu.github.io/zh/posts/tech/sizeof%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"sizeof 运算符是一个极为常用且强大的工具。它能够在编译时计算任意数据类型或对象在内存中占用的字节数。 一、什么是 sizeof 运算符？ sizeof 是一个内置于 C++ 的运算符，","title":"Sizeof运算符"},{"content":"\r不论是那个编程语言，函数返回值是一个极其重要的概念，它不仅影响代码的逻辑，还直接关系到程序的性能。在不同的场景下，函数返回值的处理方式会对程序的效率、内存使用以及可维护性产生显著的影响。\n今儿个，列位上雅座，我们来唠一唠 C++ 中函数返回值的不同存储位置、寄存器优化、栈的使用以及如何利用现代 C++ 特性（如移动语义、RVO 等）进行性能优化。\n一、C++ 函数返回值的基本机制 C++ 函数在执行完毕后，可以通过返回值将计算结果传递给调用者。返回值可以是基本数据类型（如 int、float、double）、指针、引用，甚至是自定义的类或结构体对象。如何存储和传递这些返回值，取决于返回值的大小和类型。\n1.1 返回值的存储位置 根据返回值类型和编译器优化策略，函数返回值的存储位置一般有两种选择：\n寄存器（Register）存储：当函数返回值是基本数据类型（如 int、float）或者小型对象时，编译器通常会将返回值存储在寄存器中。寄存器是 CPU 内部的高速存储器，使用寄存器可以显著提高返回值的传递速度。\n1 2 3 int add(int a, int b) { return a + b; } 在这个例子中，返回的 int 值可能直接存储在 CPU 寄存器中，而不会经过内存操作。\n栈（Stack）存储：当返回值是大型对象（如结构体或复杂类对象）时，编译器可能会将返回值存储在栈上。栈是系统为程序分配的内存区域，主要用于存储局部变量和函数调用的返回值。如果返回值太大而不能直接存储在寄存器中，编译器会在栈上分配内存。\n1 2 3 4 5 6 7 8 struct BigStruct { int data[1000]; }; BigStruct createBigStruct() { BigStruct bs; return bs; } 在这个例子中，BigStruct 结构体非常大，编译器可能会将其返回值存储在栈上，以减少寄存器的占用。\n1.2 返回值优化（RVO）和移动语义 在返回大型对象时，频繁的拷贝操作会导致程序性能下降。C++ 提供了多种优化技术来减少不必要的内存操作，其中最常见的是 返回值优化（Return Value Optimization, RVO） 和 移动语义（Move Semantics）。\n返回值优化（RVO）：RVO 是一种编译器优化技术，它允许编译器在函数返回对象时，避免创建临时对象的开销。编译器会直接在调用点构造返回对象，而不是在函数内部先构造再拷贝回调用方。\n1 2 3 BigStruct createBigStruct() { return BigStruct(); // 编译器可能直接在调用点构造对象 } 在这个例子中，返回的 BigStruct 是一个临时对象，编译器可以通过 RVO 在调用点直接构造它，而不会创建中间的临时对象，节省了性能开销。\n移动语义（Move Semantics）：在 C++11 之后，C++ 引入了移动语义，允许对象的资源从一个对象移动到另一个对象，而不是进行深拷贝。这大大减少了内存拷贝的次数，尤其是在函数返回大型对象时。\n1 2 3 4 BigStruct createBigStruct() { BigStruct bs; return std::move(bs); // 使用移动语义，避免不必要的拷贝 } 在这里，std::move 明确告诉编译器可以“移动”对象 bs 的资源而不是复制它，这有效地减少了栈上的内存开销。\n二、引用返回与指针返回的使用 在 C++ 中，函数可以通过值传递、引用传递或指针传递返回结果。其中，引用返回和指针返回的使用能够避免返回值的拷贝开销，提高性能。但它们也存在一些风险，需要谨慎使用。\n1. 引用返回的注意事项 避免返回局部变量的引用：返回局部变量的引用会导致悬挂引用问题，因为局部变量的生命周期在函数结束时结束，返回其引用会指向无效的内存。\n1 2 3 4 int\u0026amp; invalidFunction() { int x = 10; return x; // 错误：x 是局部变量，函数返回后它的内存无效 } 返回类成员的引用：在类成员函数中，可以返回类成员的引用。但需要注意多线程的访问冲突问题，特别是在多个线程同时访问时。\n1 2 3 4 5 6 class MyClass { private: int value; public: int\u0026amp; getValue() { return value; } }; const 引用返回：如果不希望调用者修改返回值，可以使用 const 引用返回，提供只读访问。\n1 2 3 const int\u0026amp; getConstValue() const { return value; } 2. 指针返回的注意事项 指针生命周期：返回指向局部变量的指针同样会导致悬挂指针问题。应避免返回局部变量的指针，除非该变量是动态分配的。\n1 2 3 4 int* invalidFunction() { int x = 10; return \u0026amp;x; // 错误：返回局部变量的地址 } 动态分配内存的指针返回：当函数返回动态分配的内存时，调用者必须负责释放内存，以避免内存泄漏。对于复杂的动态内存管理，可以使用智能指针（如 std::unique_ptr 和 std::shared_ptr）来避免手动管理内存。\n1 2 3 int* allocateMemory() { return new int[100]; // 返回动态分配的内存，调用者负责释放 } 空指针检查：在指针返回时，调用者应始终检查返回的指针是否为 nullptr，以避免访问无效内存导致程序崩溃。\n1 2 3 4 5 6 int* findElement(int* arr, int size, int value) { for (int i = 0; i \u0026lt; size; ++i) { if (arr[i] == value) return \u0026amp;arr[i]; } return nullptr; // 如果没找到，返回空指针 } ","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/","summary":"不论是那个编程语言，函数返回值是一个极其重要的概念，它不仅影响代码的逻辑，还直接关系到程序的性能。在不同的场景下，函数返回值的处理方式会对程","title":"CPP函数返回值的存储位置与优化策略"},{"content":"\r在 Linux 和 Unix 系统中，系统资源的合理分配和限制是确保系统稳定性和性能的关键。而 ulimit 命令正是用于管理和控制用户进程的资源限制的工具。通过 ulimit，系统管理员可以有效地防止单个用户或进程过度消耗系统资源，避免造成系统的整体崩溃或性能下降。\n一、什么是 ulimit？ ulimit 是一个内置于 shell 的命令，用于查看或设置进程可以使用的各种系统资源的限制。它允许管理员对文件大小、进程数、内存使用量等进行控制，从而为每个用户或进程设定资源上限。这些限制可以帮助防止单个用户或进程滥用系统资源，造成系统性能问题。\nulimit 的限制可以分为两类：\n软限制（Soft Limit）：这是当前有效的资源限制，用户可以在不超过硬限制的前提下自行修改。 硬限制（Hard Limit）：这是资源的绝对最大限制，只有超级用户才能提升硬限制。 ulimit 的基本语法如下：\n1 ulimit [选项] [限制值] 选项：指定要操作的资源类型。 限制值：设定资源的限制值。 二、ulimit 各个参数详解 ulimit 提供了一系列选项，允许管理员对不同类型的资源进行限制。以下是一些常见的 ulimit 参数及其用途：\n-a：显示所有当前的资源限制\n使用 ulimit -a 可以查看当前 shell 会话中所有资源的软限制。这是排查系统资源问题的一个有力工具。\n1 ulimit -a -c：核心转储文件大小限制\n核心转储文件是程序崩溃时生成的内存映像文件，用于调试程序。-c 选项控制核心转储文件的最大大小。\n设置核心转储文件大小为 0（禁用核心转储）：\n1 ulimit -c 0 设置核心转储文件最大为 100 MB：\n1 ulimit -c 102400 -d：数据段大小限制\n-d 选项设置进程数据段的最大大小。数据段是用来存储全局变量和静态变量的内存区域。\n设置数据段大小为 2 GB：\n1 ulimit -d 2097152 -f：最大文件大小限制\n-f 选项控制进程创建的文件的最大大小。超过此限制时，文件无法继续增长。\n设置文件最大为 50 MB：\n1 ulimit -f 51200 -l：最大锁定内存大小\n-l 选项设置进程可以锁定到物理内存中的最大内存量，这部分内存不会被交换到硬盘上。适用于需要高性能的应用。\n设置最大锁定内存为 1 GB：\n1 ulimit -l 1048576 -m：最大物理内存大小\n现代系统很少使用 -m 选项。它原本用于限制进程可以使用的物理内存大小。\n设置最大物理内存为 2 GB：\n1 ulimit -m 2097152 -n：最大打开文件数\n每个进程可以打开的文件描述符数量受到 -n 选项的限制。这是一个非常重要的设置，尤其是在处理高并发网络服务时。\n设置最大打开文件数为 1024：\n1 ulimit -n 1024 -s：栈大小限制\n栈用于存储函数调用信息和局部变量。-s 选项控制进程栈的最大大小，限制过小可能导致递归程序崩溃。\n设置栈大小为 8 MB：\n1 ulimit -s 8192 -t：最大运行时间限制\n-t 选项限制进程可以运行的最长时间（以秒为单位）。超出此时间后，进程将被系统强制终止。\n设置最大运行时间为 3600 秒（1 小时）：\n1 ulimit -t 3600 -u：最大进程数限制\n-u 选项限制用户可以创建的最大进程数。这可以防止用户创建过多的进程，导致系统资源枯竭。\n设置最大进程数为 500：\n1 ulimit -u 500 -v：最大虚拟内存大小\n-v 选项控制进程使用的最大虚拟内存量，包括程序代码、数据段、堆、栈等所有内存映射的内容。\n设置最大虚拟内存为 4 GB：\n1 ulimit -v 4194304 三、如何永久修改 ulimit 限制 ulimit 命令的限制通常只在当前 shell 会话中有效。如果想要使这些限制永久生效，可以通过以下方式实现：\n3.1 编辑 /etc/security/limits.conf 文件 对于系统级别的限制，可以在 /etc/security/limits.conf 文件中添加用户或组的资源限制配置。例如：\n1 2 3 4 5 # 为用户设置最大文件描述符数和最大进程数限制 username soft nofile 1024 username hard nofile 2048 username soft nproc 500 username hard nproc 1000 4.2 修改用户的 shell 配置文件 如果想为某个特定用户设置资源限制，可以将 ulimit 命令添加到用户的 .bashrc、.profile 或其他 shell 启动脚本中。例如：\n1 2 # 设置用户的最大文件描述符数 ulimit -n 1024 四、ulimit 的实际应用场景 4.1 优化高并发网络服务 对于高并发的服务器应用（如 Web 服务器、数据库等），打开的文件描述符数限制可能是性能瓶颈。通过适当增加 -n 选项的值，可以允许服务器处理更多的并发连接。\n4.2 防止资源滥用 为了防止单个用户或进程滥用系统资源，管理员可以设置进程数限制（-u）和内存使用限制（-v）。这在多用户系统中尤为重要，因为一个恶意或错误的程序可能耗尽系统资源，导致其他用户无法正常工作。\n4.3 调试程序的核心转储 开发人员在调试程序时，核心转储文件是诊断崩溃问题的重要工具。通过适当调整 -c 选项，允许生成核心转储文件，可以帮助开发人员获取崩溃时的内存状态，定位问题。\n","permalink":"https://oheyu.github.io/zh/posts/tech/ulimit%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","summary":"在 Linux 和 Unix 系统中，系统资源的合理分配和限制是确保系统稳定性和性能的关键。而 ulimit 命令正是用于管理和控制用户进程的资源限制的工具。通过 ulimit，","title":"Ulimit：资源限制与性能优化"},{"content":"\r在C++编程中，内联函数（inline function）是一个强大的优化工具，它允许编译器将函数调用直接展开为内联代码，从而减少函数调用的开销，提高程序的执行效率。尽管内联函数可以显著提升某些场景下的性能，但它也有局限性，必须慎重使用。@_@\n一、内联函数的基本概念 内联函数是一种特别的函数，它通过使用 inline 关键字向编译器发出一个请求，要求将函数体直接嵌入到调用点，而不是生成通常的函数调用开销。这样可以避免参数压栈、函数调用和返回值的传递，减少函数调用的开销，尤其是在函数体较小且调用频繁时，内联可以带来性能的提升。\n要将函数声明为内联函数，需要在函数定义之前添加 inline 关键字：\n1 2 3 inline int add(int a, int b) { return a + b; } 通常建议将内联函数的声明和定义放在同一个头文件中，这是因为内联函数需要在编译时可见。如果定义放在源文件中，编译器可能无法在其他文件中看到函数定义，导致不能内联。\n二、内联函数的特点 减少函数调用的开销：函数调用通常涉及以下步骤：参数的压栈和传递、跳转到函数的入口地址、执行函数代码、返回值传递和跳回调用点、弹栈和恢复上下文。对于小型、频繁调用的函数，这些开销可能显得相对较大。内联函数通过直接将代码嵌入到调用点，可以完全消除这些调用开销，从而提高效率。\n增加代码体积：内联函数的本质是将函数代码复制到每个调用点，因此如果一个内联函数被频繁调用，那么其代码将会在每个调用位置展开，导致代码体积膨胀，增加可执行文件的大小。这种现象被称为代码膨胀（code bloat）。\n编译器的裁定：inline 关键字只是对编译器的建议，而不是强制命令。编译器会根据函数的复杂性、大小等因素来决定是否真正进行内联。通常，编译器会拒绝将以下函数内联：函数体过大、包含递归的函数、包含复杂控制流（如循环、条件分支）的函数\n内联函数无法递归：内联函数不适合递归调用。因为内联意味着将函数的代码直接展开，而递归调用会导致无限次的内联展开，编译器会拒绝这样的内联尝试。\n三、内联函数与函数栈的关系 在普通函数调用中，栈帧是函数调用的核心概念。当调用一个函数时，系统为该函数创建一个新的栈帧，保存函数的局部变量、参数、返回地址等。函数执行完毕后，栈帧被销毁，函数的控制权返回给调用者。\n内联函数通过将函数代码直接嵌入调用点，从而避免了栈帧的创建和销毁。没有栈帧的开销，意味着减少了内存操作，消除了跳转和返回的开销。因此，内联函数的执行更加高效。\n然而，内联函数并不会在运行时管理任何函数调用栈。这在以下场景尤为重要：\n对于小型函数，内联可以显著减少栈内存的使用。 但对于复杂函数，使用普通函数而非内联可以减少代码膨胀，并且使得栈帧管理更加清晰和可控。 四、内联函数的优缺点 4.1 优点 提高执行效率：内联函数通过减少函数调用的开销，可以加快程序的运行速度，特别是在函数体较小且调用频繁的情况下。\n减少函数栈开销：由于不需要生成栈帧，内联函数可以减少栈空间的使用，尤其在嵌套调用频繁的场景中效果显著。\n方便调试：内联函数通过在调用点展开代码，使得调试时能够直接看到展开后的代码，而不需要跳转到函数定义处。\n4.2 缺点 增加代码体积：由于内联函数的代码会在每个调用点展开，因此如果一个函数被频繁调用，代码体积可能会大幅增加。这会导致程序的内存占用增加。\n递归函数不能内联：内联函数不支持递归调用，因为递归会导致无限次展开，这不仅违反了内联的初衷，还会让编译器无法处理。\n难以调试：尽管内联函数能够减少跳转操作，但在一些调试工具中，展开的内联代码可能让调用栈的结构变得不那么清晰，调试时可能带来一定困难。\n五、何时使用内联函数？ 尽管内联函数具有加速程序执行的潜力，但它的使用也需要非常谨慎。以下是一些适用场景：\n5.1 频繁调用的小型函数 如果一个函数的函数体非常短小，并且会频繁调用，那么内联可以显著减少开销。例如，简单的访问器函数或数学计算函数：\n1 inline int getX() { return x; } 5.2 性能关键路径中的函数 在一些对性能敏感的代码路径中，可以考虑将关键函数声明为内联，以最大化性能。\n5.3 避免递归和复杂控制流 避免将递归函数、包含复杂控制流（如循环、异常处理等）的函数声明为内联。编译器很可能会忽略这些请求，或者产生不期望的效果。\n5.4 适当权衡代码体积与性能 内联函数能够提升性能，但也会增加代码体积。在嵌入式系统等资源有限的环境中，需要特别谨慎地使用内联函数，避免内存浪费。\n六、总结 内联函数是C++中一种有效的性能优化工具，它通过减少函数调用的开销来提升程序执行速度。然而，它并非万能的解决方案，内联函数可能导致代码膨胀和编译器忽略请求等问题。在使用内联函数时，需要根据具体场景进行权衡，既要考虑执行效率，又要关注代码体积和内存占用。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/","summary":"在C++编程中，内联函数（inline function）是一个强大的优化工具，它允许编译器将函数调用直接展开为内联代码，从而减少函数调用的开","title":"CPP中的内联函数"},{"content":"\r在 C++ 编程中，内存管理始终是一个关键问题，尤其是在手动管理动态分配内存时，容易引发内存泄漏、悬空指针等问题。为了解决这些问题，C++11 引入了智能指针，包括 unique_ptr, shared_ptr, 和 weak_ptr，它们极大地简化了资源管理，并在大多数情况下防止了内存泄漏。\n一、unique_ptr：独享所有权的智能指针 1.1 概念 unique_ptr 是一种独占所有权的智能指针，这意味着在任意时间点，只有一个 unique_ptr 可以指向某个动态分配的对象。unique_ptr 在其生命周期结束时会自动释放它所管理的资源，确保不会发生内存泄漏。\n1.2 特点 独占所有权：unique_ptr 不允许复制，仅允许移动（即右值引用）。 自动释放资源：当 unique_ptr 离开其作用域时，它会自动释放指向的资源，不需要显式调用 delete。 高效且安全：由于 unique_ptr 不允许多个指针共享同一个对象，它消除了引用计数的开销，同时避免了悬空指针和重复释放的问题。 1.3 用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; class AA { public: string m_name; AA(const string\u0026amp; name) : m_name(name) { cout \u0026lt;\u0026lt; \u0026#34;构造函数调用：\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; } ~AA() { cout \u0026lt;\u0026lt; \u0026#34;析构函数调用：\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; } }; int main() { // 通过 make_unique 创建 unique_ptr unique_ptr\u0026lt;AA\u0026gt; ptr = make_unique\u0026lt;AA\u0026gt;(\u0026#34;西施\u0026#34;); // 通过 move 将所有权转移 unique_ptr\u0026lt;AA\u0026gt; ptr2 = move(ptr); // ptr 失去所有权，ptr2 拥有对象 if (ptr == nullptr) cout \u0026lt;\u0026lt; \u0026#34;ptr 是空指针\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;结束程序时，ptr2 会自动释放资源\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 1.4 技巧 std::move 转移所有权：unique_ptr 不支持复制，但可以通过 std::move 进行所有权的转移。 release() 和 reset()：release() 用于释放 unique_ptr 对对象的控制权，并返回裸指针；reset() 用于重新管理一个新对象或将 unique_ptr 置为空。 数组支持：unique_ptr 支持数组管理，使用 unique_ptr\u0026lt;T[]\u0026gt; 可以安全地管理动态数组，并在离开作用域时自动释放。 二、shared_ptr：共享所有权的智能指针 2.1 概念 shared_ptr 提供了一种共享所有权的模型，多个 shared_ptr 可以同时指向同一个对象。shared_ptr 通过内部的引用计数来跟踪有多少指针共享这个对象，当最后一个 shared_ptr 超出作用域时，对象才会被释放。\n2.2 特点 共享所有权：多个 shared_ptr 可以同时指向同一个对象，引用计数会相应增加或减少。 引用计数机制：当引用计数变为零时，对象会被自动销毁。 线程安全：shared_ptr 的引用计数操作是原子操作，在多线程环境下是安全的。 2.3 用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; class AA { public: string m_name; AA(const string\u0026amp; name) : m_name(name) { cout \u0026lt;\u0026lt; \u0026#34;构造函数调用：\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; } ~AA() { cout \u0026lt;\u0026lt; \u0026#34;析构函数调用：\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; } }; int main() { shared_ptr\u0026lt;AA\u0026gt; ptr1 = make_shared\u0026lt;AA\u0026gt;(\u0026#34;西施\u0026#34;); shared_ptr\u0026lt;AA\u0026gt; ptr2 = ptr1; // 引用计数加1 cout \u0026lt;\u0026lt; \u0026#34;ptr1 引用计数：\u0026#34; \u0026lt;\u0026lt; ptr1.use_count() \u0026lt;\u0026lt; endl; // 输出 2 cout \u0026lt;\u0026lt; \u0026#34;ptr2 引用计数：\u0026#34; \u0026lt;\u0026lt; ptr2.use_count() \u0026lt;\u0026lt; endl; // 输出 2 ptr1.reset(); // 释放 ptr1 对对象的引用，但对象不会被销毁 cout \u0026lt;\u0026lt; \u0026#34;ptr1 引用计数：\u0026#34; \u0026lt;\u0026lt; ptr1.use_count() \u0026lt;\u0026lt; endl; // 输出 0 cout \u0026lt;\u0026lt; \u0026#34;ptr2 引用计数：\u0026#34; \u0026lt;\u0026lt; ptr2.use_count() \u0026lt;\u0026lt; endl; // 输出 1 } 2.4 技巧 use_count()：可以用 use_count() 查看某个对象的引用计数。 reset() 和 swap()：reset() 可以用于更改对象的所有权，swap() 则用于交换两个 shared_ptr 的管理对象。 线程安全：shared_ptr 本身的引用计数是线程安全的，但如果多个线程同时读写 shared_ptr 所指向的对象，则需要额外的同步机制。 三、weak_ptr：非所有权的智能指针 3.1 概念 weak_ptr 是专门为了解决 shared_ptr 中的循环引用问题引入的，它是一种弱引用，不会影响对象的引用计数。weak_ptr 仅仅是观察一个对象的存在，不能直接访问对象，需要通过 lock() 转换为 shared_ptr 才能使用。\n3.2 循环引用问题 循环引用发生在两个 shared_ptr 互相持有对方的情况，导致引用计数永远无法归零，从而造成内存泄漏。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; class BB; class AA { public: weak_ptr\u0026lt;BB\u0026gt; m_p; // 使用 weak_ptr 打破循环引用 string m_name; AA(const string\u0026amp; name) : m_name(name) { cout \u0026lt;\u0026lt; \u0026#34;构造函数调用：\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; } ~AA() { cout \u0026lt;\u0026lt; \u0026#34;析构函数调用：\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; } }; class BB { public: weak_ptr\u0026lt;AA\u0026gt; m_p; string m_name; BB(const string\u0026amp; name) : m_name(name) { cout \u0026lt;\u0026lt; \u0026#34;构造函数调用：\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; } ~BB() { cout \u0026lt;\u0026lt; \u0026#34;析构函数调用：\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; } }; int main() { shared_ptr\u0026lt;AA\u0026gt; ptrA = make_shared\u0026lt;AA\u0026gt;(\u0026#34;西施A\u0026#34;); shared_ptr\u0026lt;BB\u0026gt; ptrB = make_shared\u0026lt;BB\u0026gt;(\u0026#34;西施B\u0026#34;); ptrA-\u0026gt;m_p = ptrB; ptrB-\u0026gt;m_p = ptrA; cout \u0026lt;\u0026lt; \u0026#34;无循环引用，程序正常结束\u0026#34; \u0026lt;\u0026lt; endl; } 3.3 weak_ptr 的使用 lock()：weak_ptr 提供 lock() 函数，将 weak_ptr 转换为 shared_ptr，如果对象仍然存在则返回有效的 shared_ptr，否则返回空指针。 expired()：weak_ptr 可以用 expired() 检查资源是否已经过期。 非所有权：weak_ptr 不会影响引用计数，可以安全地用来观察资源的生命周期。 四、总结 智能指针是 C++ 现代编程中处理资源管理的关键工具，能够有效防止内存泄漏并简化复杂的内存管理任务。unique_ptr 提供了最高效的独占所有权管理，而 shared_ptr 则用于需要共享所有权的场景，weak_ptr 则解决了 shared_ptr 的循环引用问题。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%9D%E6%8E%A2/","summary":"在 C++ 编程中，内存管理始终是一个关键问题，尤其是在手动管理动态分配内存时，容易引发内存泄漏、悬空指针等问题。为了解决这些问题，C++11 引入了","title":"CPP智能指针初探"},{"content":"\r在 C++ 编程中，内存泄漏是一个经常遇到的重大问题，特别是在涉及动态内存管理的场景中。如果程序在分配内存后没有及时释放，可能导致系统内存逐渐被耗尽，最终影响程序和系统的性能，甚至导致崩溃。\n一、什么是内存泄漏？ 内存泄漏是指程序动态分配了内存资源，但未能正确释放，导致这些资源在程序的整个生命周期中都无法被再次使用。尽管这些内存仍被系统占用，程序却无法再访问或释放它们。随着程序的长时间运行，内存泄漏会导致系统的可用内存逐渐减少，最终导致性能问题甚至程序崩溃。\n二、内存泄漏的表现 内存泄漏的影响并不会立即显现，但随着程序的持续运行，它会表现为以下几种问题：\n系统性能下降：程序使用的内存逐渐增加，系统可用内存减少，导致系统整体性能下降。 程序崩溃：在内存泄漏严重时，程序可能耗尽所有可用内存，导致系统强制终止该程序或系统无法正常运行。 不可预测的行为：内存不足可能导致程序出现异常行为，例如响应速度减慢、无缘无故的崩溃等。 三、常见的内存泄漏原因 内存泄漏通常是由于对内存的错误管理引起的，下面是几种常见的原因。\n3.1 动态内存分配后未释放 这是最典型的内存泄漏场景。当程序通过 new 或 malloc 动态分配内存后，没有相应的 delete 或 free 来释放内存，导致泄漏。\n1 2 int* ptr = new int(10); // 动态分配内存 // 如果没有 delete，内存不会被释放 3.2 异常处理中的内存泄漏 如果在异常发生时，分配的内存没有被正确释放，会导致内存泄漏。异常可能会跳过释放代码，直接进入异常处理代码块。\n1 2 3 4 5 6 7 8 9 10 void process() { int* ptr = new int(10); try { // 可能抛出异常的代码 throw std::runtime_error(\u0026#34;Error\u0026#34;); } catch (...) { // 没有 delete ptr，导致内存泄漏 throw; } } 3.3 指针被重新分配而未释放原始内存 当一个指针被重新分配新内存时，如果没有先释放之前指向的内存，之前分配的内存将无法访问并导致泄漏。\n1 2 3 int* ptr = new int(10); ptr = new int(20); // 忘记释放原来分配的内存 delete ptr; // 只释放了最后分配的内存 3.4 循环引用（智能指针中的常见问题） 循环引用是指对象相互持有对方的引用，导致这些对象无法被正确析构和释放。这在使用智能指针时尤其常见，特别是在 std::shared_ptr 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;memory\u0026gt; class A; class B { public: std::shared_ptr\u0026lt;A\u0026gt; a_ptr; }; class A { public: std::shared_ptr\u0026lt;B\u0026gt; b_ptr; }; void example() { std::shared_ptr\u0026lt;A\u0026gt; a = std::make_shared\u0026lt;A\u0026gt;(); std::shared_ptr\u0026lt;B\u0026gt; b = std::make_shared\u0026lt;B\u0026gt;(); a-\u0026gt;b_ptr = b; b-\u0026gt;a_ptr = a; // 循环引用，导致无法释放内存 } 四、检测内存泄漏 为了确保程序的健壮性和内存使用的有效性，检测内存泄漏是必不可少的环节。下面介绍几种常用的检测手段。\n4.1 使用内存分析工具 Valgrind：这是一个流行的内存检测工具，能够检测内存泄漏、未初始化的内存使用等问题。 AddressSanitizer：由编译器支持的运行时工具，可以快速定位内存泄漏和其他内存相关错误。 Visual Studio 内存诊断工具：用于检测 Windows 环境下的内存问题。 4.2 手动代码审查 代码审查：通过检查代码中的 new 和 delete、malloc 和 free 的配对情况来手动排查内存泄漏。 内存管理策略：通过代码审查确保遵循好的内存管理习惯，避免裸指针，推荐使用智能指针。 五、预防内存泄漏的有效措施 5.1 使用智能指针 C++11 引入的智能指针极大地简化了内存管理，避免了手动释放内存时的出错机会。智能指针（如 std::unique_ptr 和 std::shared_ptr）能够自动管理内存，当指针不再被使用时，自动释放内存。\n1 2 3 4 5 6 #include \u0026lt;memory\u0026gt; void process() { std::unique_ptr\u0026lt;int\u0026gt; ptr = std::make_unique\u0026lt;int\u0026gt;(10); // 自动管理内存，无需显式 delete } 5.2 避免裸指针 尽量避免使用裸指针。特别是对于复杂的类设计和动态内存分配，使用智能指针不仅能够提高代码的健壮性，还能自动管理对象的生命周期。\n1 2 3 4 5 6 7 #include \u0026lt;memory\u0026gt; class MyClass { std::unique_ptr\u0026lt;int\u0026gt; ptr; public: MyClass() : ptr(std::make_unique\u0026lt;int\u0026gt;(10)) {} }; 5.3 遵循 RAII（资源获取即初始化）原则 RAII 是 C++ 内存管理的一大原则。使用类的构造函数分配资源，析构函数释放资源，可以确保在异常情况下，资源仍然能够被正确释放。\n1 2 3 4 5 6 7 8 9 10 class Resource { int* data; public: Resource() : data(new int(10)) {} ~Resource() { delete data; } // 析构时释放资源 }; void process() { Resource res; // res 析构时会自动释放 data 指向的内存 } 六、总结 内存泄漏是 C++ 程序中的常见问题，但通过良好的内存管理策略和工具，内存泄漏问题是可以有效避免的。使用智能指针、遵循 RAII 原则以及使用内存检测工具，可以极大地减少内存泄漏的风险。此外，定期的代码审查也能帮助发现潜在的内存管理问题。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%86%B7%E4%B8%8D%E4%B8%81%E5%84%BF%E7%9A%84%E5%86%85%E5%AD%98%E5%B0%B1%E6%B3%84%E6%BC%8F%E4%BA%86/","summary":"在 C++ 编程中，内存泄漏是一个经常遇到的重大问题，特别是在涉及动态内存管理的场景中。如果程序在分配内存后没有及时释放，可能导致系统内存逐渐被耗尽","title":"冷不丁儿的内存就泄漏了"},{"content":"\r一、引言 冒泡排序（Bubble Sort）是一种基础且直观的排序算法，它通过反复遍历待排序的数组，每次比较相邻的元素，如果顺序错误则交换它们的位置，最终较大的元素逐渐\u0026quot;冒泡\u0026quot;到数组的末尾。这个过程会重复进行，直到整个数组有序。\n二、冒泡排序的原理 冒泡排序的核心思想是反复遍历数组，通过两两比较相邻的元素，将较大的元素逐渐移动到数组的末尾。每次遍历之后，未排序部分的最大值被移动到正确的位置。随着遍历的次数增加，剩下的未排序部分逐渐减少，直至整个数组有序。\n算法的基本步骤如下：\n从数组的起始位置开始，依次比较相邻的两个元素。 如果前一个元素大于后一个元素，则交换它们的位置。 继续向后比较相邻的元素，直到数组的末尾。 完成一次遍历后，数组的最后一个元素是最大的，固定它的位置。 重复上述过程，忽略已经排好序的元素，直到没有需要交换的元素为止。 三、时间复杂度与性能优化 冒泡排序的时间复杂度为：\n最坏时间复杂度：O(n²)，当输入数组是逆序时，每次都需要进行最大次数的比较和交换。 平均时间复杂度：O(n²)，对于无序数组，通常需要反复遍历和交换。 最佳时间复杂度：O(n)，当数组已经是有序时，仅需要一次遍历即可。 为了提升性能，可以通过引入标志位优化，即在每次遍历时，若没有发生任何元素的交换，则表示数组已经有序，可以提前终止遍历。这样可以避免在数组有序时不必要的遍历。\n4. 冒泡排序的完整代码展示 下面展示了使用 C++ 实现的冒泡排序代码，并引入了标志位 swapped 用于性能优化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 冒泡排序函数 void bubbleSort(std::vector\u0026lt;int\u0026gt;\u0026amp; my_array) { size_t length {my_array.size()}; // 获取数组的长度 bool swapped; // 标志位，表示本次遍历是否有元素交换 for (size_t i {0}; i \u0026lt; length - 1; ++i) { // 外层循环控制每一轮的遍历 swapped = false; // 每次新的一轮开始，初始化为 false for (size_t j {0}; j \u0026lt; length - i - 1; ++j) { // 内层循环比较相邻元素 if (my_array[j] \u0026gt; my_array[j + 1]) { // 如果前一个元素大于后一个元素 std::swap(my_array[j], my_array[j + 1]); // 交换它们的位置 swapped = true; // 如果发生了交换，标志位设为 true } } if (!swapped) break; // 如果本轮没有发生交换，说明数组已经有序，提前退出 } } int main() { size_t size; // 数组的大小 std::cout \u0026lt;\u0026lt; \u0026#34;Enter the size of array to be sorted from smallest to biggest: \u0026#34;; std::cin \u0026gt;\u0026gt; size; if (size \u0026lt;= 0) { // 检查输入的数组大小是否合理 std::cerr \u0026lt;\u0026lt; \u0026#34;The size of array should be greater than 0.\u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } std::vector\u0026lt;int\u0026gt; my_array(size); // 创建大小为 size 的数组 std::cout \u0026lt;\u0026lt; \u0026#34;Please enter \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; integer numbers: \u0026#34;; for (size_t i {0}; i \u0026lt; size; ++i) { // 输入数组的元素 std::cin \u0026gt;\u0026gt; my_array[i]; } bubbleSort(my_array); // 调用冒泡排序函数对数组进行排序 std::cout \u0026lt;\u0026lt; \u0026#34;The array after sorted is: \u0026#34;; for (const int\u0026amp; num : my_array) { // 输出排序后的数组 std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 五、代码分析 主函数 main():\n用户输入数组的大小 size，并检查输入是否合理（即数组大小必须大于 0）。 用户随后输入数组的元素，将这些元素存储在 std::vector\u0026lt;int\u0026gt; 容器中。 调用 bubbleSort() 函数对数组进行排序。 最后，输出排序后的数组。 bubbleSort() 函数:\n使用双重循环实现冒泡排序。外层循环控制遍历的轮次，内层循环则是对相邻元素进行比较和交换。 使用 swapped 标志位来检测某轮遍历中是否发生过交换。如果某轮遍历没有交换任何元素，则说明数组已经是有序状态，此时可以提前退出循环，避免不必要的遍历。 六、冒泡排序的优缺点 优点：\n冒泡排序的实现简单、直观，适合用于初学者学习基本的排序思想和算法。 对于已经接近有序的数组，可以通过标志位优化，减少排序的时间复杂度。 缺点：\n冒泡排序在处理大型数组时效率较低，尤其是对于完全无序的数组，算法需要进行大量的比较和交换，导致时间复杂度为 O(n²)。 即使在优化后，冒泡排序的性能也不如一些更高效的排序算法（如快速排序、归并排序等）。 七、结论 冒泡排序虽然不是最优的排序算法，但它简单易懂，具有一定的优化空间。通过使用标志位优化，我们可以在处理已经有序或部分有序的数组时提高算法的性能。对于小规模数据，冒泡排序依然是一种可用的排序方案。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","summary":"一、引言 冒泡排序（Bubble Sort）是一种基础且直观的排序算法，它通过反复遍历待排序的数组，每次比较相邻的元素，如果顺序错误则交换它们的","title":"冒泡排序"},{"content":"\rC++ 的模板机制是其强大功能的核心之一，它允许编写通用的代码，并根据不同的类型进行实例化。然而，C++ 中的模板使用过程中，有时我们可以依赖编译器进行模板参数推导，而有时却必须显式指定模板参数。这种现象背后有一套明确的规则和限制。目前来说，我有些摸不着头脑了，今天我尝试着解释一下。\n一、模板参数推导机制 C++ 编译器在调用模板函数时，通常能够通过函数实参的类型推导出模板参数类型。这种自动推导机制使得代码更加简洁，无需显式指定模板参数。这是 C++ 模板机制带来的主要便利之一。\n1.1 模板参数的推导规则 模板参数推导的基本原则是：编译器通过函数实参的类型来推导模板参数类型。如果实参类型与模板参数存在对应关系，编译器就能够自动推导出模板参数。\n示例：\n1 2 3 4 5 6 7 8 9 template \u0026lt;typename T\u0026gt; T add(const T\u0026amp; a, const T\u0026amp; b) { return a + b; } int main() { int x = 10, y = 20; auto result = add(x, y); // T 被推导为 int } 在此例中，函数 add 接受两个相同类型的参数，编译器通过实参 x 和 y 的类型（int）推导出模板参数 T 为 int，因此调用时不需要显式指定模板参数。\n1.2 引用与指针类型的推导 模板参数的推导不仅限于基本类型。当模板参数是引用或指针类型时，编译器会通过实参的基础类型来推导模板参数。\n1 2 3 4 5 6 7 8 9 template \u0026lt;typename T\u0026gt; void printPointer(T* ptr) { std::cout \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; std::endl; } int main() { int value = 42; printPointer(\u0026amp;value); // T 被推导为 int } 在此例中，模板函数 printPointer 接受一个指向类型 T 的指针，通过实参 \u0026amp;value 的类型，编译器推导出 T 为 int。\n二、必须显式指定模板参数的场景 尽管在许多情况下编译器可以自动推导模板参数，但在一些特殊情况下，编译器无法推导模板参数的类型。此时，我们必须显式指定模板参数类型。\n2.1 缺少足够的类型信息 当模板函数没有参数时，编译器没有足够的信息推导出模板参数。这种情况下，必须显式指定模板参数类型。\n1 2 3 4 5 6 template \u0026lt;typename T\u0026gt; void printType(); int main() { printType\u0026lt;int\u0026gt;(); // 必须显式指定 T，因为没有参数提供类型信息 } 这里，printType 函数没有任何参数，因此编译器无法推导模板参数 T，需要显式指定为 int。\n2.2 函数返回类型无法参与推导 C++ 的模板参数推导机制只能从函数参数类型推导模板参数，函数的返回类型不参与推导。这意味着即使返回类型明确，也必须显式指定模板参数。\n示例：\n1 2 3 4 5 6 template \u0026lt;typename T\u0026gt; T createObject(); int main() { auto obj = createObject\u0026lt;int\u0026gt;(); // 必须显式指定 T } 尽管 obj 的类型可以从返回类型推导，但编译器无法根据返回类型推导模板参数，因此必须在调用 createObject 时显式指定 T。\n2.3 参数类型与模板参数无关 在某些情况下，函数的参数类型与模板参数并不直接相关，编译器无法推导出模板参数。例如，当传递的参数类型不能提供足够的类型信息时。\n1 2 3 4 5 6 template \u0026lt;typename T\u0026gt; void processPointer(T* ptr); int main() { processPointer(nullptr); // 必须显式指定 T，因为 nullptr 没有类型信息 } nullptr 并不提供足够的类型信息，无法推导出 T，因此需要显式指定 processPointer\u0026lt;int\u0026gt;(nullptr)。\n2.4 函数作为模板参数 当模板函数本身作为参数传递时，编译器无法通过上下文推导模板参数类型，需要显式指定。\n1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename T\u0026gt; bool compare(const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b; } template \u0026lt;typename Iterator, typename Compare\u0026gt; void sort(Iterator begin, Iterator end, Compare comp); int main() { std::vector\u0026lt;int\u0026gt; vec = {3, 1, 4, 1, 5}; sort(vec.begin(), vec.end(), compare\u0026lt;int\u0026gt;); // 必须显式指定 compare\u0026lt;int\u0026gt; } 在这个例子中，由于 compare 是一个模板函数，编译器无法自动推导它的模板参数 T，因此需要显式指定为 int。\n三、C++11 中的默认模板参数 为了减少显式指定模板参数的需求，C++11 引入了默认模板参数的概念。通过为模板参数提供默认值，可以在未显式指定模板参数时让编译器使用默认值。\n1 2 3 4 5 6 7 8 template \u0026lt;typename T = int\u0026gt; T multiply(const T\u0026amp; a, const T\u0026amp; b) { return a * b; } int main() { auto result = multiply(3, 4); // T 被默认推导为 int } 在此例中，模板 T 被赋予了默认值 int，因此在调用 multiply(3, 4) 时，编译器自动使用 int 作为模板参数。\n四、模板推导中的特殊情况：万能引用（Universal Reference） C++11 引入了万能引用（或称为转发引用，forwarding reference），这为模板参数推导带来了一些新的复杂性。万能引用的模板参数可以绑定到左值或右值，并能保留实参的值类型，这使得模板函数更具通用性。\n1 2 3 4 5 6 7 8 9 10 template \u0026lt;typename T\u0026gt; void forward(T\u0026amp;\u0026amp; arg) { process(std::forward\u0026lt;T\u0026gt;(arg)); } int main() { int x = 10; forward(x); // T 被推导为 int\u0026amp; forward(20); // T 被推导为 int } 在这种情况下，T\u0026amp;\u0026amp; 是一个万能引用，编译器会根据传递的实参类型推导出 T。当传递左值 x 时，T 被推导为 int\u0026amp;，而当传递右值 20 时，T 被推导为 int。\n五、总结 C++ 的模板参数推导机制是其模板系统中的一个重要特性，极大地简化了模板函数的使用。然而，在某些特殊情况下，编译器无法推导出模板参数，这时就必须显式指定模板参数。理解模板参数推导的规则与限制，可以帮助我们在编写和使用模板代码时做出更好的选择，确保代码的简洁性与正确性。\n关键点总结：\n模板参数推导：编译器通过函数实参的类型自动推导模板参数，减少显式指定的需要。 显式指定的场景：当编译器缺少足够的信息时，例如没有函数参数、返回类型不参与推导或使用 nullptr 等特殊值时，必须显式指定模板参数。 默认模板参数：C++11 引入了默认模板参数，进一步减少显式指定模板参数的场景。 万能引用：C++11 的万能引用在模板推导中具有特殊性，使得模板函数能够根据实参的值类别灵活处理左值与右值。 ","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC%E4%B8%8E%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/","summary":"C++ 的模板机制是其强大功能的核心之一，它允许编写通用的代码，并根据不同的类型进行实例化。然而，C++ 中的模板使用过程中，有时我们可以依赖编译器","title":"CPP模板参数推导与显示指定的原理及应用场景"},{"content":"\r在 C 和 C++ 编程中，return、exit()、_exit() 以及 _Exit() 都可以用于终止程序或函数的执行，但它们的行为、作用范围以及对资源的处理方式存在显著差异。\n一、return：从函数中返回控制权 return 是 C/C++ 中用于从函数返回控制权给调用者的关键字。它不仅仅用于结束函数执行，还能将值返回给调用者。特别是在 main() 函数中，return 还会将状态码返回给操作系统。\n1.1 return 的基本特点 作用范围：return 仅在函数内部使用，它会将控制流返回到调用函数的地方。如果在 main() 函数中使用，return 会结束程序，并向操作系统返回状态码。 自动资源管理：当 return 被调用时，局部对象的析构函数会自动调用，释放相关资源。这确保了对象的生命周期在函数结束时得到正确管理。 控制流的返回：return 不会终止整个程序，它只结束当前函数的执行，并返回控制权给调用函数。 1.2 return 的应用示例 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; void myFunction() { std::cout \u0026lt;\u0026lt; \u0026#34;Inside myFunction\u0026#34; \u0026lt;\u0026lt; std::endl; return; // 返回控制权到调用者 } int main() { myFunction(); std::cout \u0026lt;\u0026lt; \u0026#34;Back in main\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; // 返回状态码 0 给操作系统 } 在这个例子中，return 从 myFunction() 返回到 main()，而 main() 的 return 0 结束程序并向操作系统返回 0，表示成功执行。\n1.3 资源清理 局部对象：在函数退出时，所有局部对象会自动析构，调用它们的析构函数。这确保了函数内的资源得到正确管理。 全局对象：如果在 main() 中使用 return，全局对象的析构函数也会被调用，确保整个程序的资源被正确清理。 二、exit()：终止整个程序 exit() 是 C 和 C++ 中用于立即终止整个程序执行的标准库函数。它可以在程序的任何地方调用，并返回状态码给操作系统，但与 return 不同，exit() 不仅仅退出函数，而是直接终止整个程序。\n2.1 exit() 的行为特点 全局终止：exit() 会立即终止程序的所有执行，不会返回到调用它的函数。它不会等待当前的函数执行完毕，而是直接结束整个进程。 全局清理：exit() 会执行全局对象的析构函数、刷新所有 I/O 缓冲区，并关闭打开的文件。同时，它还会调用通过 atexit() 注册的终止处理程序（cleanup functions）。 不可恢复：一旦调用 exit()，程序不会再恢复执行。因此，任何 exit() 后面的代码都不会被执行。 2.2 exit() 的使用示例 1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; // 包含 exit() 的头文件 int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Program starting\u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); // 立即终止程序并返回状态码 1 std::cout \u0026lt;\u0026lt; \u0026#34;This will not be printed\u0026#34; \u0026lt;\u0026lt; std::endl; // 不会被执行 } 在这个示例中，exit(1) 立即终止程序，并返回 1 给操作系统，表示程序发生错误。后续的 std::cout 语句不会被执行。\n三、_exit() 和 _Exit()：跳过清理的快速退出 _exit() 和 _Exit() 是系统级的终止函数，它们与 exit() 的主要区别在于它们不进行全局清理工作，也不会调用对象的析构函数或终止处理程序。它们通常用于多进程编程中，尤其是子进程中。\n3.1 _exit() 和 _Exit() 的区别 _exit()：是 POSIX 标准中定义的函数，通常用于子进程调用。在子进程中调用 exit() 会导致不必要的终止处理程序和缓冲区刷新，因此 _exit() 直接终止进程，不进行这些操作。 _Exit()：是 C 标准库中的函数，行为与 _exit() 类似，都是直接终止程序。两者的差异主要在于它们的标准来源。 3.2 主要特点 立即终止：_exit() 和 _Exit() 都会立即终止程序执行，不会执行任何 I/O 清理、析构函数或终止处理程序。 常用于多进程编程：在多进程环境中，子进程不应影响父进程的资源，因此 _exit() 和 _Exit() 是快速终止子进程的理想工具。 3.3 _exit() 的使用示例 1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 包含 _exit() int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Program starting\u0026#34; \u0026lt;\u0026lt; std::endl; _exit(1); // 立即终止程序，不进行清理 std::cout \u0026lt;\u0026lt; \u0026#34;This line will not be executed\u0026#34; \u0026lt;\u0026lt; std::endl; } 在这个例子中，_exit(1) 直接终止程序，不进行 I/O 缓冲刷新和对象析构。与 exit() 的区别在于，它不会执行任何形式的清理工作。\n四、return、exit()、_exit() 与 _Exit() 的对比 功能 return exit() _exit()/_Exit() 作用范围 当前函数 整个程序 整个程序 返回控制权 返回给调用者 不返回，直接终止程序 不返回，直接终止程序 局部对象析构 是 否 否 全局对象析构 是（main()） 是 否 I/O 缓冲刷新 是 是 否 终止处理程序调用 否 是 否 常见应用场景 函数返回，控制流跳转 正常或异常终止整个程序 进程立即终止，多用于多进程编程 五、总结 在 C 和 C++ 编程中，理解 return、exit()、_exit() 和 _Exit() 之间的区别对于控制程序流和正确管理资源至关重要。\nreturn：用于函数的正常返回，确保局部对象被正确销毁，适合常规的控制流管理。 exit()：用于立即终止程序，适用于需要终止整个程序的情况，并执行必要的全局清理操作。 _exit() 和 _Exit()：用于立即终止程序，不执行任何清理工作，通常用于子进程或异常情况下的快速退出。 ","permalink":"https://oheyu.github.io/zh/posts/tech/returnexit_exit%E4%BB%A5%E5%8F%8A_exit/","summary":"在 C 和 C++ 编程中，return、exit()、_exit() 以及 _Exit() 都可以用于终止程序或函数的执行，但它们的行为、作用范围以及对资源的处理方式存","title":"Return、exit、_exit以及_Exit"},{"content":"\r在 Unix 和 Linux 系统中，每个命令或程序在执行后都会返回一个退出状态码（Exit Status Code），用于指示该命令的执行结果。echo $? 是一个简单但非常有用的命令组合，专门用于检查最后执行的命令的退出状态码。对于调试脚本、程序，以及系统管理任务，echo $? 提供了一种快捷方式来了解命令的成功或失败情况。\n一、退出状态码（Exit Status Code）概述 在 Unix 和 Linux 中，每个命令或程序执行完后都会返回一个退出状态码，通常用来表示该命令的执行结果。退出状态码是一个整数，主要分为两类：\n0：表示命令或程序成功执行。 非0：表示命令执行失败，且不同的非0状态码通常代表不同类型的错误。 1.1 为什么需要退出状态码？ 退出状态码是系统与用户或脚本之间的沟通桥梁，帮助判断一个命令或程序是否正确完成。对于复杂的脚本和系统任务，准确处理每个命令的退出状态码可以有效减少错误传播，并确保在失败时采取适当的纠错措施。\n二、echo $? 命令的工作原理 $? 是 Bash 等 Unix/Linux Shell 环境中的一个特殊变量，用于存储最近一次命令或程序的退出状态码。echo $? 则是将该变量的值输出到终端，显示最后一个命令的返回结果。\n2.1 echo $? 的基本用法 1 2 3 4 $ ls file1.txt file2.txt $ echo $? 0 在这个例子中，ls 命令执行成功，因此 echo $? 输出 0。如果我们执行一个不存在的命令或文件操作失败，echo $? 则会返回非0的状态码。\n1 2 3 4 $ ls nonexistent_file ls: cannot access \u0026#39;nonexistent_file\u0026#39;: No such file or directory $ echo $? 2 在这个例子中，ls 命令因试图访问不存在的文件而失败，echo $? 返回了错误代码 2，表示运行时遇到错误。\n三、退出状态码的作用与范围 在 Unix 系统中，退出状态码通常为 0 到 255 的整数。系统内建程序与命令的退出码范围广泛，非0退出码会根据不同的命令产生不同的含义。\n0：命令成功执行。 1-255：通常用于表示各种错误，具体数值由不同的程序或脚本定义。例如： 1：一般错误，适用于大多数非特定错误。 2：误用命令，如 ls nonexistent_file。 退出状态码的重要作用不仅在于判断命令成功与否，还能帮助诊断系统问题。在大型脚本或复杂系统中，通过分析退出状态码可以有效地追踪错误的根源。\n四、echo $? 在实际场景中的应用 4.1 在脚本中的使用 在编写 Bash 脚本时，检测命令的退出状态码是控制流的一种常用方式。通过 echo $? 或直接访问 $? 变量，脚本可以根据命令的成功或失败执行不同的逻辑。\n示例：\n1 2 3 4 5 6 7 8 9 #!/bin/bash echo \u0026#34;Running ls command...\u0026#34; ls if [ $? -eq 0 ]; then echo \u0026#34;ls command succeeded.\u0026#34; else echo \u0026#34;ls command failed.\u0026#34; fi 在这个脚本中，ls 命令执行后，脚本通过 $? 检查它的退出状态码。如果 ls 成功执行，则输出相应的成功信息；如果失败，则输出失败信息。\n4.2 流程控制与错误处理 除了简单的状态码输出外，$? 还可以用于更加复杂的流程控制。例如，在链式命令执行中，通过 $? 检查每一步的状态可以确保只有前一个命令成功时才继续执行后续命令。\n1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash # 先运行第一个命令 first_command if [ $? -ne 0 ]; then echo \u0026#34;First command failed. Aborting script.\u0026#34; exit 1 fi # 如果第一个命令成功，继续执行第二个命令 second_command 这种错误处理机制确保当关键任务失败时，脚本能够及时退出，并防止进一步的错误扩散。\n4.3 管道中的退出状态码处理 在管道操作中，$? 通常返回最后一个命令的退出状态码。然而，如果你需要检查每个命令的状态，可以使用 PIPESTATUS 数组。\n示例：\n1 2 3 4 5 6 $ false | true $ echo $? 0 $ echo ${PIPESTATUS[@]} 1 0 在这个例子中，false 命令失败，但 true 成功。在普通的 echo $? 中只会显示最后一个命令 true 的结果（即 0）。而通过 PIPESTATUS，可以获取所有管道命令的状态码。\n五、特殊场景中的状态码 5.1 exit 命令与自定义退出状态码 在编写脚本时，你可以通过 exit 命令设置自定义的退出状态码。这在脚本中非常有用，可以让脚本根据特定的错误场景返回不同的状态码。\n1 2 3 4 5 6 7 8 9 #!/bin/bash # 检查参数数量 if [ \u0026#34;$#\u0026#34; -lt 2 ]; then echo \u0026#34;Usage: $0 arg1 arg2\u0026#34; exit 1 fi # 成功执行 echo \u0026#34;Arguments: $1 and $2\u0026#34; exit 0 在这个脚本中，exit 1 用于表示错误的参数数量，exit 0 表示脚本成功执行。\n5.2 非标准状态码 某些应用程序可能返回超出 0-255 范围的状态码，这通常是由于应用程序内部错误或异常导致的。这类状态码虽然不常见，但也可能引发系统或脚本的不正常行为。在设计脚本时，确保考虑状态码的处理方式非常重要。\n六、总结 echo $? 是 Unix/Linux 中一个简单却强大的命令，用于快速获取最近执行命令的退出状态码。通过检查退出状态码，开发者可以轻松判断命令的执行结果，从而有效地控制脚本的行为，避免潜在的错误扩散。\n","permalink":"https://oheyu.github.io/zh/posts/tech/linux%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%A0%81/","summary":"在 Unix 和 Linux 系统中，每个命令或程序在执行后都会返回一个退出状态码（Exit Status Code），用于指示该命令的执行结果。echo $? 是一个简单但非常有用","title":"Linux退出状态码"},{"content":"\r在 C++ 中，拷贝构造函数和赋值构造函数是管理对象复制行为的两个核心机制。它们的正确实现对于保障程序的健壮性与资源管理的正确性至关重要。\n一、拷贝构造函数 1.1 拷贝构造函数的定义 拷贝构造函数用于在创建对象时，通过使用已有对象来初始化新对象。它是对象在创建过程中被调用的特殊构造函数，通常的声明形式如下：\n1 ClassName(const ClassName \u0026amp;other); 这里的 other 是对另一个同类型对象的引用。 拷贝构造函数通过已有对象的值来初始化新的对象。 1.2 拷贝构造函数的使用场景 拷贝构造函数会在以下情况下被隐式调用：\n当对象以值传递方式传递给函数时。 当函数以值返回对象时。 当对象被显式初始化时，例如 ClassName obj2 = obj1;。 1.3 默认的拷贝构造函数 如果未显式定义拷贝构造函数，编译器会为类自动生成一个默认的拷贝构造函数。默认的行为是逐成员拷贝（浅拷贝），即直接复制对象中的每个成员变量。对于基本类型（如 int、double），这种浅拷贝行为通常是合适的，但对于包含动态内存（如指针）的类，浅拷贝会导致多个对象共享同一块内存，可能引发双重释放和内存泄漏等问题。\n1.4 自定义拷贝构造函数 当类管理动态资源（如堆内存、文件句柄）时，通常需要实现深拷贝，即为新对象分配独立的资源。这时需要自定义拷贝构造函数。\n1 2 3 4 5 6 7 8 9 10 11 12 class MyClass { private: int* data; public: // 自定义拷贝构造函数 MyClass(const MyClass \u0026amp;other) { data = new int(*other.data); // 深拷贝，分配新内存并复制内容 } ~MyClass() { delete data; // 确保释放动态分配的内存 } }; 在这个示例中，拷贝构造函数分配了新的内存，并将 other 对象的内容复制到新对象中，从而避免了浅拷贝导致的问题。\n二、赋值构造函数（拷贝赋值运算符） 2.1 赋值构造函数的定义 赋值构造函数用于将一个对象的值赋给另一个已经存在的对象。与拷贝构造函数不同，赋值构造函数不会创建新对象，而是修改已有对象的内容。通常的声明形式如下：\n1 ClassName\u0026amp; operator=(const ClassName \u0026amp;other); 返回类型是对象的引用，以支持链式赋值（如 a = b = c;）。 2.2 赋值构造函数的使用场景 赋值构造函数会在以下场景中被调用：\n当一个对象被赋值给另一个已有对象时，例如 obj1 = obj2;。 2.3 默认的赋值构造函数 与拷贝构造函数类似，编译器会生成一个默认的拷贝赋值运算符，执行逐成员赋值（浅拷贝）。对于简单类型，这种操作是安全的，但对于动态内存或资源管理类，则需要特别小心，避免出现内存泄漏或双重释放等问题。\n2.4 自定义赋值构造函数 自定义赋值构造函数通常需要包含以下几步：\n检查自赋值，防止对象对自己赋值。 释放对象中已有的资源。 分配新资源并复制数据。 返回当前对象的引用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyClass { private: int* data; public: // 自定义赋值运算符 MyClass\u0026amp; operator=(const MyClass \u0026amp;other) { if (this == \u0026amp;other) { // 自赋值检查 return *this; } delete data; // 释放已有资源 data = new int(*other.data); // 深拷贝 return *this; // 返回当前对象 } ~MyClass() { delete data; // 释放资源 } }; 在这个示例中，赋值构造函数确保了资源的正确释放和分配，同时避免了自赋值问题。\n三、拷贝构造函数与赋值构造函数的对比 特性 拷贝构造函数 赋值构造函数 调用时机 创建新对象时，通过已有对象初始化 已有对象之间的赋值操作 内存管理 通常涉及资源的分配（为新对象分配内存） 通常涉及资源的释放和重新分配 返回类型 无需返回值 返回当前对象的引用（*this） 自赋值检查 不需要 必须检查（避免对象对自身赋值） 四、资源管理与自定义操作 对于资源管理类（如涉及动态内存、文件句柄等），需要特别关注拷贝构造函数和赋值运算符的实现，确保在对象拷贝或赋值时资源能够被正确地管理。\n4.1 深拷贝与浅拷贝 浅拷贝：仅复制指针的地址，导致多个对象共享同一份资源。这可能导致双重释放问题。 深拷贝：为每个对象分配独立的资源，确保对象之间的拷贝和赋值互不干扰。 4.2 禁用拷贝与赋值 在某些情况下，可能希望完全禁止对象的拷贝和赋值操作。例如，对于单例模式或管理不可复制资源的类，可以通过将拷贝构造函数和赋值运算符声明为 delete 来禁用这些操作。\n示例：\n1 2 3 4 5 class MyClass { public: MyClass(const MyClass\u0026amp;) = delete; // 禁用拷贝构造函数 MyClass\u0026amp; operator=(const MyClass\u0026amp;) = delete; // 禁用赋值构造函数 }; 这样，任何对该类对象的拷贝或赋值操作都会在编译时报错。\n五、总结 拷贝构造函数用于通过已有对象初始化新对象，是对象的构造过程的一部分。赋值构造函数用于将一个对象的值赋给另一个已有的对象，是对象的赋值过程。 对于类中包含动态资源的情况，必须实现自定义的拷贝构造函数和赋值构造函数，以确保资源的正确管理。 使用 delete 可以禁用拷贝和赋值操作，确保对象不可复制。 ","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","summary":"在 C++ 中，拷贝构造函数和赋值构造函数是管理对象复制行为的两个核心机制。它们的正确实现对于保障程序的健壮性与资源管理的正确性至关重要。 一、拷贝构","title":"CPP中的拷贝构造函数与赋值构造函数"},{"content":"\r在 C++ 开发中，库文件是用于封装可重用代码的文件，帮助开发者在多个项目中共享和重用函数、类或数据结构。库文件主要分为两类：静态库（Static Library） 和 动态库（Dynamic Library）。\n一、静态库 1.1 静态库的概念 静态库是一种在编译时将库的代码直接链接到目标程序中的文件。静态库的内容在编译时复制到每个使用该库的程序中，意味着每个程序都有自己独立的库代码副本。静态库通常使用 .a（Linux/Unix）或 .lib（Windows）扩展名。\n1.2 静态库的创建 创建静态库通常包括以下步骤：\n编译源代码为目标文件： 使用 g++ -c 命令编译源代码生成目标文件：\n1 g++ -c myfile.cpp -o myfile.o -c 参数告诉编译器只编译文件而不链接生成可执行文件。\n使用 ar 命令打包目标文件为静态库： 使用 ar 命令创建静态库：\n1 ar rcs libmylib.a myfile.o 其中，libmylib.a 是静态库的名称，rcs 是创建或替换归档文件的选项。\n1.3 静态库的使用 在使用静态库时，编译器会将库文件的代码嵌入到最终的可执行文件中。链接静态库的方式如下：\n1 g++ main.cpp -L. -lmylib -o myprogram -L. 指定库文件的搜索路径为当前目录。 -lmylib 表示链接库 libmylib.a（省略了前缀 lib 和扩展名 .a）。 -o myprogram 指定生成的可执行文件名。 使用静态库时，需要确保在源代码中包含库的头文件：\n1 #include \u0026#34;mylib.h\u0026#34; 1.4 静态库的优缺点 优点：\n加载速度快：因为静态库在编译时被嵌入到程序中，运行时不需要额外的库加载步骤。 独立性强：静态链接的程序独立运行，不依赖外部库文件的存在。 缺点：\n可执行文件体积较大：每个使用静态库的程序都包含库的完整代码，导致二进制文件体积增大。 更新不便：当库文件需要更新时，所有使用该库的程序都需要重新编译和发布。 二、动态库 2.1 动态库的概念 动态库（也称为共享库）在程序运行时动态加载到内存中，多个进程可以共享同一个库的实例。动态库通常使用 .so（Linux/Unix）或 .dll（Windows）扩展名。与静态库不同，动态库的代码不直接嵌入可执行文件中，而是在运行时由系统加载。\n2.2 动态库的创建 创建动态库需要以下步骤：\n编译源代码为位置无关代码： 使用 -fPIC 选项编译生成位置无关代码（Position Independent Code）：\n1 g++ -fPIC -c myfile.cpp -o myfile.o 将目标文件链接为动态库： 使用 g++ -shared 命令创建动态库：\n1 g++ -shared -o libmylib.so myfile.o -shared 参数告诉编译器生成动态库，libmylib.so 是动态库的名称。\n2.3 动态库的使用 编译时需要链接动态库，方法如下：\n1 g++ main.cpp -L. -lmylib -o myprogram 其中，-L. 和 -lmylib 与使用静态库时相同。\n此外，在运行时，系统需要知道动态库的位置。如果库文件不在系统默认的路径中，可以使用 LD_LIBRARY_PATH 环境变量设置库的搜索路径：\n1 export LD_LIBRARY_PATH=./:$LD_LIBRARY_PATH 2.4 动态库的优缺点 优点：\n内存占用小：多个进程可以共享同一个动态库，减少内存使用。 更新方便：动态库可以独立更新，无需重新编译依赖它的程序。程序会在下次运行时加载新的库。 缺点：\n运行时依赖：如果动态库在程序运行时不可用，程序可能无法正常启动。 加载开销：动态库需要在运行时加载，可能会增加程序启动时间。 三、静态库与动态库的对比 特性 静态库 动态库 链接方式 编译时静态链接，库代码嵌入程序中 运行时动态链接，库代码在运行时加载 文件扩展名 .a（Linux/Unix），.lib（Windows） .so（Linux/Unix），.dll（Windows） 可执行文件体积 较大，包含库的全部代码 较小，依赖外部库文件 内存使用 每个程序独立包含库代码 多个进程共享同一份库代码 库的更新 需要重新编译所有依赖库的程序 可以独立更新库文件 运行时依赖 无外部依赖，独立执行 程序运行时需要动态库 加载时间 无需加载，程序启动时更快 程序启动时加载库，可能略有延迟 四、动态库与静态库的应用场景 4.1 何时使用静态库 静态库适用于以下场景：\n高性能场景：程序启动时间至关重要，且不希望在运行时加载额外库。 独立性要求高：程序需要在不同环境下运行而不依赖外部库文件，例如嵌入式系统或分发独立的应用程序包。 4.2 何时使用动态库 动态库适用于以下场景：\n内存优化：多个进程同时运行并共享同一份库，节省内存。 频繁更新：库代码可能需要频繁更新，而不希望每次更新后都重新编译依赖它的程序。 五、总结 静态库和动态库是 C++ 开发中两种常见的代码复用方式。静态库在编译时将库代码嵌入到可执行文件中，增加了文件体积但减少了运行时依赖。动态库在程序运行时加载，多个进程可以共享库资源，减少内存占用，并且便于独立更新。选择使用静态库还是动态库应根据项目的具体需求、性能要求和更新频率来决定。\n无论是使用静态库还是动态库，合理管理和打包库文件，确保正确地链接和加载库，都是开发高效、健壮的 C++ 应用程序的关键。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/","summary":"在 C++ 开发中，库文件是用于封装可重用代码的文件，帮助开发者在多个项目中共享和重用函数、类或数据结构。库文件主要分为两类：静态库（Static L","title":"静态库与动态库"},{"content":"\r在 C++ 面向对象编程中，类是封装数据和行为的核心概念。类的成员函数分为普通成员函数和静态成员函数两类，它们在访问方式、功能、以及使用场景上有着显著的不同。\n一、普通成员函数：面向对象的基础 普通成员函数是类实例的函数，它们与类的具体对象绑定，能够访问对象的成员变量和其他成员函数。普通成员函数是面向对象编程中最常用的函数类型，允许对每个对象进行个性化操作。\n1.1 特点 依赖对象：普通成员函数只能通过对象调用，它们操作的是特定对象的成员变量和方法。 隐式 this 指针：每个普通成员函数隐式传递一个 this 指针，指向调用该函数的对象，便于访问对象的成员。 访问权限广泛：普通成员函数可以访问类中的所有成员，无论是私有（private）、保护（protected）还是公有（public）成员。 1.2 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; class MyClass { private: int value; public: MyClass(int v) : value(v) {} // 普通成员函数 void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } void updateValue(int newValue) { value = newValue; } }; int main() { MyClass obj(10); obj.display(); // 输出 \u0026#34;Value: 10\u0026#34; obj.updateValue(20); obj.display(); // 输出 \u0026#34;Value: 20\u0026#34; return 0; } 在上面的代码中，display() 和 updateValue() 是普通成员函数，使用 obj 对象进行调用并修改对象的状态。\n二、静态成员函数：与类本身绑定的函数 静态成员函数属于类，而不是类的具体实例。它们可以在没有创建任何对象的情况下直接通过类名调用。由于静态成员函数与类本身相关，它们无法访问非静态成员，但可以访问静态成员变量。\n2.1 特点 不依赖对象：静态成员函数不依赖任何类实例，而是直接与类本身关联。 无 this 指针：由于静态成员函数不属于特定对象，因此在静态函数中不存在 this 指针。 访问静态成员变量：静态成员函数可以访问和修改类的静态成员变量，因为静态成员变量同样与类本身相关。 2.2 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; class MyClass { private: static int count; // 静态成员变量 public: MyClass() { ++count; } // 静态成员函数 static int getCount() { return count; } }; // 初始化静态成员变量 int MyClass::count = 0; int main() { MyClass obj1, obj2; std::cout \u0026lt;\u0026lt; \u0026#34;Number of objects: \u0026#34; \u0026lt;\u0026lt; MyClass::getCount() \u0026lt;\u0026lt; std::endl; // 输出 \u0026#34;Number of objects: 2\u0026#34; return 0; } 在这个示例中，getCount() 是一个静态成员函数，用于返回已创建的 MyClass 对象的数量。它通过类名 MyClass 直接调用，不需要对象实例。\n三、静态成员函数与普通成员函数的对比 特性 普通成员函数 静态成员函数 调用方式 通过对象调用 通过类名调用 依赖对象 依赖对象，使用 this 指针 不依赖对象，没有 this 指针 访问权限 可以访问类的所有成员，包括非静态成员 只能访问静态成员，不能访问非静态成员 使用场景 处理与特定对象状态相关的操作 处理与类相关的全局任务，或无状态的操作 生命周期 随对象的生命周期而存在 与类的生命周期相关，随类的存在而存在 四、静态成员函数的适用场景 静态成员函数适用于不需要依赖具体对象的操作场景，尤其是在处理与类本身相关的全局任务时表现突出。以下是静态成员函数的几个典型应用场景：\n4.1 工厂方法（Factory Method） 工厂方法模式常用于创建对象的实例。静态成员函数可以作为工厂方法，因为它们不需要依赖于对象，可以在类的范围内生成新实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; class Product { public: // 静态工厂方法 static Product* createProduct() { return new Product(); } void show() const { std::cout \u0026lt;\u0026lt; \u0026#34;Product created.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Product* p = Product::createProduct(); // 通过静态成员函数创建对象 p-\u0026gt;show(); delete p; return 0; } 工厂方法的优势在于无需创建工厂类实例，即可生成新对象，提高了效率和代码的可维护性。\n4.2 全局计数器 静态成员变量与静态成员函数的组合是实现全局计数器的典型方式，用于跟踪某个类的实例数量或其他全局信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; class Counter { private: static int count; public: Counter() { ++count; } ~Counter() { --count; } // 静态成员函数返回当前计数值 static int getCount() { return count; } }; int Counter::count = 0; int main() { Counter c1, c2; std::cout \u0026lt;\u0026lt; \u0026#34;Current count: \u0026#34; \u0026lt;\u0026lt; Counter::getCount() \u0026lt;\u0026lt; std::endl; // 输出 2 { Counter c3; std::cout \u0026lt;\u0026lt; \u0026#34;Current count: \u0026#34; \u0026lt;\u0026lt; Counter::getCount() \u0026lt;\u0026lt; std::endl; // 输出 3 } std::cout \u0026lt;\u0026lt; \u0026#34;Current count: \u0026#34; \u0026lt;\u0026lt; Counter::getCount() \u0026lt;\u0026lt; std::endl; // 输出 2 return 0; } 这种设计简洁明了，通过静态成员函数轻松实现全局数据的管理。\n4.3 单例模式（Singleton Pattern） 单例模式是确保一个类在系统中只有一个实例的设计模式。通常，单例模式通过静态成员函数来获取唯一实例，并保证全局访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; class Singleton { private: static Singleton* instance; Singleton() {} // 私有构造函数 public: static Singleton* getInstance() { if (instance == nullptr) { instance = new Singleton(); } return instance; } void showMessage() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, Singleton!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 初始化静态成员变量 Singleton* Singleton::instance = nullptr; int main() { Singleton* singleton = Singleton::getInstance(); singleton-\u0026gt;showMessage(); // 输出 \u0026#34;Hello, Singleton!\u0026#34; return 0; } 通过静态成员函数 getInstance()，我们确保 Singleton 类的唯一实例可以在全局范围内访问。\n五、总结 普通成员函数和静态成员函数各有其适用场景。普通成员函数依赖于对象实例，适合处理与特定对象状态相关的操作。而静态成员函数则是与类本身相关的操作，用于管理全局数据或无状态的任务，如工厂方法、单例模式和全局计数器等场景。\n普通成员函数：适用于访问和操作类的非静态成员，必须通过对象调用，具有 this 指针。 静态成员函数：适用于无需对象依赖的操作，可以直接通过类名调用，无法访问非静态成员，但可以访问静态成员。 ","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/","summary":"在 C++ 面向对象编程中，类是封装数据和行为的核心概念。类的成员函数分为普通成员函数和静态成员函数两类，它们在访问方式、功能、以及使用场景上有着显","title":"CPP中的静态成员函数与普通成员函数"},{"content":"\r在 UNIX/Linux 操作系统中，信号（Signal）是一种进程间的通信机制，用于通知进程特定的事件发生。信号是异步的，允许进程在无需轮询的情况下处理来自系统或其他进程的事件。今儿个，咱们来唠一唠信号的概念、处理方法、以及在 C++ 中的实现。\n一、什么是信号？ 信号是一种用于通知进程发生特定事件的软中断机制。信号可以由操作系统、硬件设备、用户（例如通过 Ctrl+C）或其他进程发出。信号允许进程异步地响应事件，例如异常情况、外部中断等。\n信号的主要特性包括： 异步性：信号可以在任意时刻被发送，接收进程并不需要主动查询。 软中断：信号不会强行中断进程，而是通知它处理特定的事件。 系统资源管理：信号机制帮助操作系统管理进程生命周期、资源、权限和状态。 二、信号的处理方式 当一个进程接收到信号时，操作系统为其提供了三种处理方式：\n2.1 默认处理 大多数信号都有默认的处理方式。例如，收到 SIGTERM 信号时，默认行为是终止进程；收到 SIGSEGV 信号时，进程会被终止并生成核心转储文件。程序可以选择不修改这些默认行为。\n2.2 自定义处理 进程可以通过定义信号处理函数（signal handler）来覆盖信号的默认处理方式。当进程接收到指定信号时，操作系统将调用用户定义的处理函数来执行自定义逻辑。\n2.3 忽略信号 某些信号允许进程选择忽略它们。例如，程序可以忽略 SIGPIPE 信号，避免在向关闭的套接字写数据时导致进程终止。\n三、使用 signal() 设置信号处理函数 在 UNIX/Linux 系统中，可以使用 signal() 函数来设置信号的处理方式。该函数允许开发者为特定信号定义自定义处理函数，或者选择恢复默认处理或忽略信号。\n3.1 signal() 函数的原型 1 sighandler_t signal(int signum, sighandler_t handler); signum：信号的编号，例如 SIGINT（中断信号）。 handler：信号处理函数，可以是自定义函数，SIG_IGN（忽略信号）或 SIG_DFL（恢复默认行为）。 四、信号处理函数的编写 信号处理函数是一个符合特定原型的函数，它在信号到达时被操作系统调用。该函数通常只接收一个参数，即信号的编号。\n信号处理函数的原型：\n1 void signalHandler(int signum); 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;csignal\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 自定义信号处理函数 void signalHandler(int signum) { std::cout \u0026lt;\u0026lt; \u0026#34;Received signal: \u0026#34; \u0026lt;\u0026lt; signum \u0026lt;\u0026lt; std::endl; // 处理信号的逻辑 } int main() { // 设置 SIGINT 信号的处理函数 signal(SIGINT, signalHandler); std::cout \u0026lt;\u0026lt; \u0026#34;Press Ctrl+C to send SIGINT signal...\u0026#34; \u0026lt;\u0026lt; std::endl; // 无限循环等待信号 while (true) { sleep(1); } return 0; } 在上面的代码中，当用户按下 Ctrl+C 时，SIGINT 信号被发送给程序，操作系统调用 signalHandler 函数来处理这个信号，输出收到信号的编号。\n五、常见信号及其默认行为 以下是一些常见的信号及其默认行为：\n信号编号 信号名称 描述 默认行为 SIGINT 中断信号 用户通过键盘（Ctrl+C）触发 终止进程 SIGTERM 终止信号 请求正常终止进程 终止进程 SIGKILL 强制终止 无法被捕捉或忽略，强制终止进程 立即终止进程 SIGSEGV 段错误 无效的内存访问，如访问非法地址 终止进程，并生成核心转储 SIGPIPE 管道破裂 写入一个读端已经关闭的管道 终止进程 SIGALRM 定时器信号 定时器到期 终止进程 六、信号处理中的注意事项 6.1 信号处理函数的简洁性 由于信号处理函数是异步调用的，在信号处理函数中，必须保证代码尽可能简短，避免复杂操作。例如，标准库中的很多函数（如 malloc、printf 等）在信号处理函数中是不安全的，因为它们可能会在多个信号到达时产生未定义行为。\n建议使用：\nwrite() 代替 printf()。 使用全局标志位记录信号状态，并在主循环中处理复杂逻辑。 6.2 线程安全与信号重入问题 信号处理函数是异步的，可能在执行过程中被新的信号打断（信号的重入问题）。为了避免这种情况，信号处理函数应避免使用非线程安全的函数，并考虑使用信号屏蔽机制来阻止其他信号的干扰。\n屏蔽信号： 可以使用 sigprocmask() 来屏蔽在信号处理期间不希望处理的信号，确保信号处理函数的执行是安全的。\n6.3 特殊信号的处理 某些信号如 SIGKILL 和 SIGSTOP 是无法被捕捉或忽略的。SIGKILL 是一种强制终止信号，通常用于无法通过其他信号终止的进程；SIGSTOP 则用于暂停进程，无法被进程自身阻止或处理。\n七、高级信号处理：使用 sigaction() 尽管 signal() 函数足以应对大多数简单的信号处理场景，但在实际开发中，使用 sigaction() 提供更强大的控制功能。sigaction() 允许开发者指定更复杂的信号处理行为，如信号阻塞、自动恢复等。\nsigaction() 函数的原型：\n1 int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); signum：信号编号。 act：新的信号处理行为。 oldact：保存旧的信号处理行为。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;csignal\u0026gt; #include \u0026lt;unistd.h\u0026gt; void signalHandler(int signum) { std::cout \u0026lt;\u0026lt; \u0026#34;Interrupt signal (\u0026#34; \u0026lt;\u0026lt; signum \u0026lt;\u0026lt; \u0026#34;) received.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { struct sigaction action; action.sa_handler = signalHandler; // 设置自定义处理函数 sigemptyset(\u0026amp;action.sa_mask); // 清空阻塞的信号集 action.sa_flags = 0; // 使用 sigaction 设置 SIGINT 的处理行为 sigaction(SIGINT, \u0026amp;action, NULL); while (true) { std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for signal...\u0026#34; \u0026lt;\u0026lt; std::endl; sleep(1); } return 0; } 在这个例子中，sigaction() 允许开发者对信号处理的控制更加细致，例如阻塞某些信号并恢复处理前的状态。\n八、总结 信号机制是 UNIX/Linux 操作系统中重要的进程间通信手段，通过它可以异步地处理系统级事件和进程间通信。C++ 提供了 signal() 和 sigaction() 等函数，帮助开发者方便地管理信号处理。理解信号的工作原理、捕捉和屏蔽信号的正确方式，有助于编写更健壮、更高效的系统程序。\n","permalink":"https://oheyu.github.io/zh/posts/tech/linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%9C%A8cpp%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"在 UNIX/Linux 操作系统中，信号（Signal）是一种进程间的通信机制，用于通知进程特定的事件发生。信号是异步的，允许进程在无需轮询的情况下处理来自系统","title":"Linux信号机制及其在CPP中的实现"},{"content":"\r在并发编程中，互斥锁（Mutex）是保证多个线程或进程访问共享资源时数据一致性的重要同步机制。它通过限制同时访问某段代码的线程数，避免数据竞争和不可预期的行为。在 C++ 中，互斥锁广泛用于多线程编程以保证线程安全。\n一、什么是互斥锁？ 互斥锁（Mutex）全称是 “Mutual Exclusion Lock”，是一种用于保证共享资源不被多个线程同时访问的锁机制。它的基本功能是在同一时刻只允许一个线程进入临界区，从而避免数据竞争。\n1.1 互斥锁的两种状态 互斥锁的状态非常简单：\n锁定状态（Locked）：当一个线程成功获取互斥锁时，其他线程将被阻塞，直到该线程释放锁。 解锁状态（Unlocked）：当持有锁的线程完成操作并释放锁后，其他等待的线程才能获取到锁并继续执行。 互斥锁的操作通常包括以下两种：\nlock()：尝试获取互斥锁。如果锁已经被其他线程持有，当前线程将进入等待状态，直到锁可用。 unlock()：释放锁，允许其他等待线程获取锁。 C++ 标准库提供了 std::mutex，用于实现基本的互斥锁功能。\n二、互斥锁的典型用法 互斥锁通常用于保护共享数据或共享资源，以防止多个线程同时访问并引发数据不一致的问题。以下是一些常见的应用场景：\n2.1 保护共享变量 在多线程程序中，如果多个线程同时访问和修改某个共享变量，会导致数据竞争，从而产生不可预测的结果。通过互斥锁，程序可以保证一次只有一个线程可以访问这个变量，确保数据安全。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx; // 创建一个互斥锁 int shared_data = 0; void updateData() { mtx.lock(); // 获取锁 ++shared_data; // 修改共享数据 mtx.unlock(); // 释放锁 } int main() { std::thread t1(updateData); std::thread t2(updateData); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;Shared data: \u0026#34; \u0026lt;\u0026lt; shared_data \u0026lt;\u0026lt; std::endl; // 输出 2 return 0; } 在这个示例中，mtx.lock() 确保在同一时刻只有一个线程可以更新 shared_data。\n2.2 线程间通信：生产者-消费者模型 生产者-消费者模式是一种经典的并发编程模型，多个线程可能会同时向一个共享缓冲区写入或读取数据。为了避免多个线程在操作缓冲区时导致数据竞争，需要使用互斥锁来保护对缓冲区的访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; std::mutex mtx; std::queue\u0026lt;int\u0026gt; buffer; std::condition_variable cond_var; void producer() { for (int i = 0; i \u0026lt; 10; ++i) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); buffer.push(i); // 添加数据到缓冲区 cond_var.notify_one(); // 通知消费者 } } void consumer() { while (true) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); cond_var.wait(lock, []{ return !buffer.empty(); }); // 等待缓冲区有数据 int data = buffer.front(); buffer.pop(); std::cout \u0026lt;\u0026lt; \u0026#34;Consumed: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; if (data == 9) break; // 消费完所有数据后退出 } } int main() { std::thread prod(producer); std::thread cons(consumer); prod.join(); cons.join(); return 0; } 在这个示例中，生产者线程和消费者线程通过互斥锁保护缓冲区，确保线程安全。\n三、互斥锁的实现原理 互斥锁的实现依赖于底层的硬件原子操作和操作系统提供的同步机制。以下是几种常见的实现方式：\n3.1 自旋锁（Spinlock） 自旋锁是一种简单的锁机制，当一个线程无法获取锁时，它会持续尝试获取锁而不让出 CPU。这种方式适用于锁持有时间非常短的场景，因为它避免了线程切换的开销。\n1 2 3 4 5 6 7 8 9 10 11 std::atomic_flag lock = ATOMIC_FLAG_INIT; void spinLock() { while (lock.test_and_set(std::memory_order_acquire)) { // busy-wait (自旋等待) } } void spinUnlock() { lock.clear(std::memory_order_release); } 3.2 休眠锁（Sleep Lock） 与自旋锁不同，休眠锁会在无法获取锁时将线程挂起，让操作系统调度其他线程执行。当锁可用时，线程被唤醒并尝试获取锁。这种方式适用于锁持有时间较长的场景。\n四、使用互斥锁的注意事项 4.1 避免死锁 死锁是指两个或多个线程相互等待对方释放资源而永远无法继续执行的情况。避免死锁的常用方法包括：\n锁的获取顺序保持一致：多个线程获取多个锁时，必须按照相同的顺序获取锁。 使用 std::lock 同时锁定多个互斥锁：std::lock 可以一次性获取多个锁，避免死锁。 1 2 3 4 5 6 7 8 std::mutex mtx1, mtx2; void safeThreadFunc() { std::lock(mtx1, mtx2); // 一次性获取多个锁 std::lock_guard\u0026lt;std::mutex\u0026gt; lock1(mtx1, std::adopt_lock); std::lock_guard\u0026lt;std::mutex\u0026gt; lock2(mtx2, std::adopt_lock); // 处理共享数据 } 4.2 使用 RAII 管理锁的获取与释放 为了避免忘记释放锁，推荐使用 RAII 模式。std::lock_guard 和 std::unique_lock 是标准库提供的锁管理类，它们能够在作用域结束时自动释放锁。\n1 2 3 4 5 6 std::mutex mtx; void safeFunction() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); // 自动获取和释放锁 // 临界区代码 } 4.3 减少锁的持有时间 为了提高程序的并发性能，应尽量缩小临界区的范围，减少锁的持有时间。长时间持有锁会导致其他线程无法及时获取资源，降低系统效率。\n1 2 3 4 5 6 7 8 void process() { prepareData(); // 处理不需要锁的部分 { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); // 临界区代码，尽量简短 } postProcessData(); } 4.4 考虑锁的粒度 锁的粒度指的是锁保护的资源范围。粒度过大，容易导致线程频繁等待；粒度过小，则可能增加死锁风险。选择合适的锁粒度，能够在性能和安全性之间取得平衡。\n五、结论 互斥锁是并发编程中不可或缺的同步工具，能够有效防止数据竞争，确保多线程环境下的资源安全。在实际开发中，使用互斥锁时需要格外小心，避免死锁、长时间持有锁以及锁管理不当等问题。通过合理使用互斥锁和 RAII 模式，我们可以编写出安全、健壮的并发程序，并且在多线程环境下确保数据的一致性和程序的稳定性。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E6%A6%82%E5%BF%B5%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","summary":"在并发编程中，互斥锁（Mutex）是保证多个线程或进程访问共享资源时数据一致性的重要同步机制。它通过限制同时访问某段代码的线程数，避免数据竞","title":"CPP中的互斥锁：概念、实现与使用技巧"},{"content":"\r在 C++ 编程中，函数调用栈是管理函数调用和返回的核心机制，它帮助程序高效管理函数的执行流程，包括参数传递、局部变量的存储和函数返回的控制。理解函数调用栈的工作原理不仅对调试程序至关重要，还对优化代码性能、处理递归问题、避免栈溢出等方面有着深远的影响。\n一、什么是函数调用栈？ 函数调用栈是计算机程序在运行时用来追踪函数调用和返回的内存区域。它是一种栈数据结构，遵循先进后出（LIFO，Last In First Out）的原则。\n每当程序调用一个函数时，系统会为该函数创建一个栈帧（stack frame），用于保存该函数的参数、局部变量、返回地址以及当前的 CPU 寄存器状态；当函数执行结束返回时，栈帧会被销毁。函数调用栈确保了函数的执行是线性且可追溯的。\n二、函数调用栈的结构 每次函数调用时，系统会在栈上创建一个栈帧。一个典型的栈帧包含以下四个部分：\n返回地址：每当函数被调用时，程序需要知道在函数执行完毕后返回的地址。返回地址通常是调用该函数的位置，它在栈帧中保存，以便函数结束后程序可以继续从正确的指令位置执行。\n函数参数：函数的参数在调用栈上也占有一部分内存区域。当函数被调用时，传入的参数会被复制到栈帧中，供函数体内部使用。\n局部变量：函数内部定义的局部变量也存储在栈帧中，这些变量的生命周期仅限于该函数执行的范围。当函数返回时，这些局部变量就会被销毁。\n寄存器状态：调用函数时，CPU 的寄存器状态需要保存下来，以便在函数返回后恢复原有的状态。这个操作确保了函数调用前后的执行环境保持一致。\n三、函数调用栈的工作原理 3.1 函数调用过程 当一个函数被调用时，系统会执行以下步骤：\n保存返回地址：将调用函数的返回地址压入栈中。 创建栈帧：为被调用的函数分配一个新的栈帧，保存函数参数、局部变量以及 CPU 的当前状态。 更新栈指针：栈指针会向下移动，指向新的栈顶。 3.2 函数执行过程 函数的局部变量和参数被分配在栈帧中，程序通过栈指针和帧指针访问这些变量。由于栈的内存分配和释放效率非常高，函数调用栈能够快速地创建和销毁栈帧。\n3.3 函数返回过程 当函数执行完毕后，系统会执行以下步骤：\n恢复寄存器状态：从栈帧中恢复函数调用前保存的寄存器状态。 恢复返回地址：弹出栈帧，程序跳转到返回地址继续执行。 栈帧销毁：栈指针恢复到函数调用前的状态，当前函数的栈帧被销毁。 四、栈溢出（Stack Overflow）及其原因 栈溢出是一种运行时错误，通常发生在函数调用栈超出系统分配的内存限制时。栈溢出的典型原因包括：\n4.1 递归调用过深 递归函数在每次递归调用时都会创建新的栈帧。如果递归深度过大，系统分配给栈的空间就可能不够，导致栈溢出。\n1 2 3 4 5 6 7 void recursiveFunction() { recursiveFunction(); // 无限递归 } int main() { recursiveFunction(); // 导致栈溢出 } 这个程序因无限递归不断消耗栈空间，最终导致栈溢出。\n4.2 局部变量过大 如果函数的局部变量占用了过多的栈空间，也会导致栈溢出，尤其是在嵌套函数调用较多时。\n1 2 3 void largeArrayFunction() { int largeArray[100000]; // 分配过大的局部数组 } 五、函数调用栈的实际应用与调试 5.1 调试函数调用栈 函数调用栈在调试程序时非常重要，特别是通过工具如 gdb、lldb 等调试器，可以查看当前的调用栈、了解程序的执行路径以及各个函数的参数和局部变量的状态。\n查看调用栈： 使用调试工具中的 backtrace 命令，可以查看程序在当前时刻的调用栈。\n示例（使用 gdb）：\n1 2 3 gdb ./my_program (gdb) run (gdb) backtrace 5.2 函数调用栈优化 减少递归深度：避免不必要的深度递归，或使用尾递归优化。 局部变量优化：避免在栈上分配过大的局部变量，特别是数组或大型对象。 5.3 递归优化（尾递归） 尾递归是一种特殊的递归形式，编译器可以通过优化将其转换为迭代，从而避免栈溢出。实现尾递归可以显著减少递归调用栈的深度。\n1 2 3 4 int tailRecursiveFactorial(int n, int result = 1) { if (n == 1) return result; return tailRecursiveFactorial(n - 1, n * result); // 尾递归 } 尾递归允许编译器在每次递归调用时直接复用栈帧，避免栈的无限增长。\n六、现代 C++ 与函数调用栈 6.1 栈与堆的协同工作 在 C++ 中，函数调用栈主要用于存储局部变量、参数和函数返回地址，而动态分配的对象存储在堆中。合理管理栈与堆的使用有助于提升程序的性能和内存利用效率。\n6.2 RAII（Resource Acquisition Is Initialization） RAII 是 C++ 中的一种资源管理惯用法，利用栈帧的自动销毁特性来管理资源。在函数返回时，栈帧中的局部对象会被自动析构，这使得资源的释放变得更加自动化和安全。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class FileHandler { public: FileHandler(const std::string\u0026amp; filename) { file = fopen(filename.c_str(), \u0026#34;r\u0026#34;); } ~FileHandler() { if (file) fclose(file); } private: FILE* file; }; void processFile(const std::string\u0026amp; filename) { FileHandler handler(filename); // RAII 方式管理文件资源 } 在函数返回时，FileHandler 的析构函数会自动关闭文件，避免了资源泄漏。\n七、总结 函数调用栈是 C++ 程序管理函数调用和返回的重要机制，它通过栈帧的形式保存每次函数调用的参数、局部变量和返回地址。理解函数调用栈的工作原理对编写高效的代码、避免栈溢出和调试程序至关重要。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/","summary":"在 C++ 编程中，函数调用栈是管理函数调用和返回的核心机制，它帮助程序高效管理函数的执行流程，包括参数传递、局部变量的存储和函数返回的控制。理解函","title":"函数调用栈"},{"content":"\r在多进程编程中，共享内存是一种常用的进程间通信机制，允许多个进程访问同一块物理内存。这种方式不仅能够提高效率，还可以减少数据在进程间拷贝的开销。然而，在使用共享内存时，数据类型的选择至关重要，特别是在涉及动态内存分配的复杂数据类型时，比如 std::string。不当的使用可能导致数据的不一致或内存问题。我们来详细分析为什么在共享内存中应避免使用 std::string，并建议使用 char[] 作为替代方案。\n一、共享内存的基本原理 共享内存段是一块特殊的物理内存区域，可以被多个进程映射到各自的虚拟地址空间中。由于这块内存是共享的，所有进程可以直接访问相同的物理内存数据，而不需要进行复杂的 IPC（进程间通信）或拷贝操作。这使得共享内存非常适合用于需要频繁交换大量数据的场景，如数据库缓存、图像处理等高性能需求的领域。\n二、std::string 的内存管理机制 std::string 是 C++ 标准库中的字符串类，提供了动态扩展、字符处理等功能。为了实现这些功能，std::string 通常涉及动态内存分配。\n动态内存分配：当字符串的大小超过某个阈值时，std::string 会在堆上动态分配内存来存储实际的字符串内容，而字符串对象本身只保存一个指向堆中字符数组的指针。 堆内存管理：堆内存的分配与释放由 std::string 内部自动处理，开发者无需显式干预。std::string 对象通过其内部的指针操作堆上的数据。 虽然 std::string 使用起来十分方便，但它依赖于动态内存分配的特性给共享内存带来了问题。\n三、多进程堆内存管理的独立性 在操作系统中，每个进程的堆内存是独立的，即便两个进程执行相同的代码，它们的堆内存空间也是不同的。即使两个进程共享了某块共享内存，它们的堆内存区域依然各自独立，无法相互访问。\n堆内存独立性：每个进程都有自己的堆，动态内存的分配和释放是由操作系统为每个进程单独管理的。因此，进程 A 中的堆地址在进程 B 中无效。即便两个进程拥有同样的 std::string 对象，其内部的指针也指向不同的堆内存区域。\n共享内存的局限性：当 std::string 对象存储在共享内存中时，虽然 std::string 本身可以在共享内存中访问，但其指向的堆内存并不在共享内存中。因此，当另一个进程试图访问该 std::string 时，访问的将是该进程的无效指针，这导致了未定义行为。\n1 2 3 struct SharedData { std::string text; }; 如果将上面结构体的 SharedData 置于共享内存中，两个进程访问 text 字段时会出现问题，因为每个进程中的 std::string 内部指针指向不同的堆内存，造成数据不一致或程序崩溃。\n四、为什么 std::string 在共享内存中不可靠？ 4.1 动态分配的指针问题 std::string 依赖堆来存储字符数据。每个进程有独立的堆内存空间，堆中的地址只在进程本地有效。因此，当进程 A 使用 std::string 分配堆内存并存储字符串时，另一个进程 B 即便能够通过共享内存访问 std::string 对象的元数据，但由于 std::string 的指针指向进程 A 的堆，进程 B 无法通过该指针访问到正确的数据。\n4.2 未定义行为 如果共享内存中的 std::string 在某个进程中被修改，而其他进程尝试访问或操作该字符串对象，结果是不可预期的，通常会引发以下问题：\n崩溃：由于进程之间无法共享堆指针，访问无效地址可能导致程序崩溃。 数据损坏：即使程序不崩溃，访问错误的数据区域可能导致数据被破坏，进而影响程序的正常运行。 内存泄漏：如果一个进程释放了 std::string 的内存，而其他进程仍然尝试访问该对象，会导致内存泄漏或访问空指针。 五、选择 char[] 作为替代方案 与 std::string 的动态内存分配机制不同，char[] 是一个简单的字符数组，直接存储字符数据，不依赖堆内存。因此，char[] 更适合在共享内存中使用。\n5.1 固定内存位置 当你使用 char[] 时，字符数组可以直接分配在共享内存中。每个进程都能够通过共享内存访问相同的物理内存，避免了堆内存的复杂性和不一致性问题。\n1 2 3 struct SharedData { char text[256]; // 固定大小的字符数组 }; 在此示例中，char[] 数组的内容完全存储在共享内存中，每个进程都能安全地读取和修改该数组的数据，且数据在所有进程中的内存位置一致。\n5.2 简单而高效 相比 std::string，char[] 没有动态分配的复杂性，字符数组的大小是固定的，所有数据都存储在共享内存中。使用 char[] 时，所有进程都共享相同的物理地址，避免了指针不一致的问题。\n六、实际开发中的建议 在多进程编程中，使用共享内存时应选择适当的数据结构，避免使用涉及动态分配内存的类型，如 std::string。为了确保数据一致性和进程间通信的可靠性，char[] 是更安全的选择。\n6.1 使用 char[] 的场景 简单字符串交换：当需要在多个进程间交换简单的文本数据时，使用 char[] 作为存储结构，可以保证字符串在所有进程间的一致性。 固定大小的数据块：如果数据量相对固定，使用 char[] 来代替 std::string 既能保证性能，又能避免内存泄漏等问题。 6.2 考虑数据大小的限制 使用 char[] 需要提前确定字符串的最大长度。如果字符串长度不确定，可以通过额外的协议或消息传递机制来处理变长数据。这是使用 char[] 时唯一需要考虑的限制。\n七、总结 在共享内存中使用 std::string 可能导致严重的内存管理问题，因为每个进程的堆内存是独立的，std::string 的动态内存分配会导致指针在不同进程间失效，进而引发未定义行为。相比之下，使用简单的 char[] 数组可以有效避免这些问题，保证进程间共享数据的一致性和安全性。\n通过理解共享内存的基本原理和 std::string 的内存管理机制，开发者可以避免常见的陷阱，选择正确的数据类型来构建稳定、可靠的多进程程序。在多进程通信中，char[] 是一个高效且安全的选择。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%BA%E5%95%A5%E8%A6%81%E9%81%BF%E5%85%8Dstring%E5%AF%B9%E8%B1%A1/","summary":"在多进程编程中，共享内存是一种常用的进程间通信机制，允许多个进程访问同一块物理内存。这种方式不仅能够提高效率，还可以减少数据在进程间拷贝的开","title":"CPP中共享内存的使用：为啥要避免string对象"},{"content":"\r在 C++ 编程中，仿函数（Function Objects, Functors）是一种强大的工具，它不仅可以像普通函数那样调用，还可以携带状态、使用类的继承和多态来实现更加复杂的逻辑。在很多情况下，仿函数比普通函数和函数指针更灵活、功能更强大，因此在现代 C++ 中得到了广泛的应用，尤其是在标准模板库（STL）中。\n一、什么是仿函数？ 仿函数是通过重载函数调用运算符 operator() 的类的对象，使得这些对象可以像函数一样被调用。仿函数的关键在于它可以携带状态，与普通函数不同，仿函数既具备函数的调用方式，又具备对象的持久性和灵活性。\n1.1 仿函数的基本实现 下面是一个简单的仿函数示例，定义了一个可以计算两个数乘积的类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; class Multiply { public: int operator()(int a, int b) const { return a * b; } }; int main() { Multiply multiply; // 创建仿函数对象 int result = multiply(3, 4); // 像调用函数一样使用仿函数 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; // 输出 12 return 0; } 在这个例子中，Multiply 类重载了 operator() 运算符，使其对象可以像普通函数那样被调用。multiply(3, 4) 直接返回两个整数的乘积。\n二、仿函数的优势 仿函数相较于普通函数或者函数指针，提供了更强大的功能。在 C++ 的实际开发中，仿函数具备以下几大优势：\n2.1 状态持久性 普通函数通常是无状态的，每次调用后都不会保存任何信息，而仿函数可以通过类的成员变量保存状态。举个例子，我们可以实现一个计数器仿函数，每次调用它都会递增计数值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; class Counter { private: int count; public: Counter() : count(0) {} int operator()(int increment) { count += increment; return count; } }; int main() { Counter counter; std::cout \u0026lt;\u0026lt; counter(1) \u0026lt;\u0026lt; std::endl; // 输出 1 std::cout \u0026lt;\u0026lt; counter(1) \u0026lt;\u0026lt; std::endl; // 输出 2 std::cout \u0026lt;\u0026lt; counter(5) \u0026lt;\u0026lt; std::endl; // 输出 7 return 0; } 这里的 Counter 仿函数在每次调用时，都会更新内部的 count 状态，保持了调用之间的累积信息。普通函数无法做到这一点，除非通过全局变量或静态变量来辅助。\n2.2 可继承性与多态性 仿函数不仅仅是一个函数调用，它实际上是一个类，因此可以使用 C++ 的面向对象特性。通过继承和多态，仿函数可以在不同场景下实现不同的行为。例如，我们可以定义不同的策略类，并使用仿函数在运行时灵活选择不同的行为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; class Strategy { public: virtual int operator()(int a, int b) const = 0; }; class Add : public Strategy { public: int operator()(int a, int b) const override { return a + b; } }; class Multiply : public Strategy { public: int operator()(int a, int b) const override { return a * b; } }; void executeStrategy(const Strategy\u0026amp; strategy, int a, int b) { std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; strategy(a, b) \u0026lt;\u0026lt; std::endl; } int main() { Add add; Multiply multiply; executeStrategy(add, 3, 4); // 输出 7 executeStrategy(multiply, 3, 4); // 输出 12 return 0; } 通过这种方式，仿函数不仅实现了不同的逻辑，还可以通过多态灵活扩展功能，使得程序更加灵活和可维护。\n2.3 性能优化 在 C++ 中，仿函数通常是内联的，这意味着编译器可以在编译时将仿函数直接展开，减少函数调用的开销。相比函数指针，仿函数在性能敏感的场景中更具优势，特别是在大规模循环或 STL 算法中频繁调用时，仿函数能带来显著的性能提升。\n三、仿函数在 STL 中的应用 仿函数在 C++ 的标准模板库（STL）中被广泛应用，特别是在算法和容器中。STL 中许多算法，如 std::sort、std::for_each 等，支持将仿函数作为参数传递，从而使算法更加灵活。\n3.1 自定义排序规则 STL 的 std::sort 可以接受一个仿函数作为参数，用来定义自定义的排序规则。以下示例展示了如何使用仿函数实现降序排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; class Compare { public: bool operator()(int a, int b) const { return a \u0026gt; b; // 降序 } }; int main() { std::vector\u0026lt;int\u0026gt; vec = {3, 1, 4, 1, 5, 9}; std::sort(vec.begin(), vec.end(), Compare()); // 使用仿函数进行排序 for (int n : vec) { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 输出 9 5 4 3 1 1 } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，Compare 仿函数定义了一个降序排序规则，并传递给 std::sort 进行排序操作。仿函数提供了一种灵活的方式来控制 STL 算法的行为。\n3.2 在回调机制中的应用 仿函数也可以用作回调函数，尤其在事件驱动编程模型或异步操作中，仿函数可以携带所需的状态，并在需要时执行相应的逻辑。\n四、高级仿函数：与模板和可变参数的结合 C++ 中的仿函数可以结合模板和可变参数，从而实现更加通用和灵活的功能。以下是一个支持任意数量参数的仿函数示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; class Printer { public: template\u0026lt;typename... Args\u0026gt; void operator()(Args... args) const { (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; args) \u0026lt;\u0026lt; std::endl; // 展开参数包并输出 } }; int main() { Printer print; print(1, 2, 3); // 输出 123 print(\u0026#34;Hello\u0026#34;, \u0026#34;, \u0026#34;, \u0026#34;world!\u0026#34;); // 输出 Hello, world! return 0; } 这个 Printer 仿函数可以接受任意数量的参数，并通过 C++17 的折叠表达式将参数输出到控制台。这展示了仿函数的灵活性和扩展性。\n五、总结 仿函数（Functors）在 C++ 中结合了函数调用的简单性和类的灵活性，具有状态保持、可继承性、多态性以及性能优化等诸多优势。它们广泛应用于标准模板库中的算法、回调机制以及高级模板编程中。\n状态保持：通过仿函数可以在调用之间保存状态，避免使用全局变量或静态变量。 可继承与多态：仿函数可以结合类的继承和多态，轻松实现不同的策略模式。 性能优化：由于仿函数通常是内联的，它们在性能上比函数指针更加高效，特别是在 STL 算法中频繁调用时。 掌握仿函数的使用，不仅能提高代码的灵活性，还能优化性能，是 C++ 高效编程的利器。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0functors/","summary":"在 C++ 编程中，仿函数（Function Objects, Functors）是一种强大的工具，它不仅可以像普通函数那样调用，还可以携带状态、使用类的继承和多态来","title":"CPP中的仿函数（Functors）"},{"content":"\r在 C++ 编程中，结构体（struct）是一种常用的数据结构，尤其是在需要组织和管理多个相关数据时。然而，当结构体中包含指向动态分配内存的指针时，如何正确使用 sizeof 和 memset 变得至关重要。误用这两个工具可能导致程序的潜在错误，甚至引发内存泄漏问题。\n一、结构体中的动态内存分配问题 我们可以从一个包含指针的简单结构体开始：\n1 2 3 4 struct Data { int* ptr; int size; }; 在这个结构体中，ptr 是一个指向动态内存的指针，而 size 用于表示分配的内存大小。典型的使用方式如下：\n1 2 3 Data d; d.size = 10; d.ptr = new int[d.size]; // 动态分配内存 在这个例子中，ptr 指向了堆中的一块动态内存，而 d 本身则存储在栈中或堆中（取决于其声明方式）。尽管这看起来简单，但在内存管理上隐藏着诸多陷阱。\n二、使用 sizeof 的陷阱 2.1 sizeof 的工作原理 sizeof 是一个用于获取变量或类型占用内存大小的运算符。在使用结构体时，它会返回结构体中所有成员的总和，例如：\n1 std::cout \u0026lt;\u0026lt; \u0026#34;Size of Data: \u0026#34; \u0026lt;\u0026lt; sizeof(Data) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; 在这个例子中，假设指针大小为 8 字节，int 为 4 字节，那么 sizeof(Data) 可能会返回 12 字节（或在某些系统上，由于内存对齐可能是 16 字节）。\n2.2 为什么 sizeof 可能没有意义 在涉及动态分配的情况下，sizeof 只能计算结构体中指针的大小，而无法计算指针所指向的内存的大小。换句话说，sizeof 返回的结果并不包含 ptr 指向的动态内存，我们可以看下面的例子：\n1 2 3 4 5 Data d; d.size = 10; d.ptr = new int[d.size]; std::cout \u0026lt;\u0026lt; \u0026#34;Size of Data: \u0026#34; \u0026lt;\u0026lt; sizeof(d) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; 尽管此时 d.ptr 指向了 10 个 int 的数组，但 sizeof(d) 仍然只会返回结构体本身的大小（即 12 或 16 字节），而不是包含动态分配的内存。因此，使用 sizeof 来估计包含动态分配内存的结构体的大小是没有意义的。\n三、使用 memset 的风险 3.1 memset 的工作原理 memset 是 C 标准库中的函数，用于将内存区域设置为指定的值，通常用于初始化或清除内存：\n1 memset(\u0026amp;d, 0, sizeof(d)); 在这个例子中，memset 将 d 的整个内存区域都设置为 0。这包括 ptr 和 size，然而这带来了潜在的风险。\n3.2 memset 导致内存泄漏的原因 当结构体中包含动态分配的指针时，直接对结构体使用 memset 可能导致内存泄漏和未定义行为。为啥？因为：\n指针被覆盖：memset 操作将 ptr 也设置为 0（NULL），导致指针原本指向的动态内存丢失，而这些内存无法再被释放，进而引发内存泄漏。 错误释放内存：在 memset 操作后，ptr 指针不再指向有效的内存，因此后续的 delete[] d.ptr 操作将产生未定义行为，程序可能崩溃。 1 2 3 4 5 6 7 Data d; d.size = 10; d.ptr = new int[d.size]; memset(\u0026amp;d, 0, sizeof(d)); // 覆盖整个结构体的内存 delete[] d.ptr; // 未定义行为，ptr 已经被设置为 NULL 在这个例子中，由于 memset 覆盖了 ptr，它不再指向有效的内存地址，因此 delete[] 操作的行为未定义，可能导致程序崩溃或内存泄漏。\n四、正确的初始化与内存管理方式 那么，我们咋个整嘞？为了避免 sizeof 和 memset 带来的问题，我们应采用更安全的内存管理方式，特别是在结构体中包含动态内存时。\n4.1 使用构造函数和析构函数 C++ 提供了构造函数和析构函数来安全地管理动态内存。我们可以通过将结构体转为类，并定义构造函数和析构函数来确保内存正确分配和释放。\n1 2 3 4 5 6 7 8 9 10 11 12 struct Data { int* ptr; int size; // 构造函数 Data(int s) : size(s), ptr(new int[s]) {} // 析构函数 ~Data() { delete[] ptr; } }; 在这个例子中，Data 类的构造函数会自动为 ptr 分配内存，而析构函数确保了内存被正确释放。这样可以有效避免内存泄漏和未定义行为。\n4.2 手动释放动态内存 如果你必须使用 memset 来清除结构体，在调用 memset 之前必须手动释放动态分配的内存。\n1 2 delete[] d.ptr; // 首先释放动态内存 memset(\u0026amp;d, 0, sizeof(d)); // 然后初始化结构体 通过先释放 ptr 指向的内存，再调用 memset，可以避免内存泄漏。\n五、使用智能指针 为了进一步简化内存管理，避免手动调用 new 和 delete，可以使用 C++11 引入的智能指针，例如 std::unique_ptr 或 std::shared_ptr。\n1 2 3 4 5 6 7 8 #include \u0026lt;memory\u0026gt; struct Data { std::unique_ptr\u0026lt;int[]\u0026gt; ptr; int size; Data(int s) : size(s), ptr(std::make_unique\u0026lt;int[]\u0026gt;(s)) {} }; 在这个例子中，std::unique_ptr 会自动管理内存的释放，避免内存泄漏，即使发生异常，智能指针也能够确保内存被正确释放。\n六、总结 在 C++ 中使用 sizeof 和 memset 操作包含指针的结构体时，开发者应当格外小心。sizeof 只能返回结构体本身的大小，而不包括动态内存的大小，因此对于包含指针的结构体使用 sizeof 是没有意义的。同样，memset 会覆盖结构体中的指针，导致指向动态内存的地址丢失，进而引发内存泄漏。\n为了避免这些问题，建议使用 C++ 提供的构造函数、析构函数来管理内存，或者使用智能指针来简化内存分配和释放。\n","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86sizeof%E4%B8%8Ememset%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1/","summary":"在 C++ 编程中，结构体（struct）是一种常用的数据结构，尤其是在需要组织和管理多个相关数据时。然而，当结构体中包含指向动态分配内存的指针时，","title":"CPP中结构体的内存管理：sizeof与memset的使用陷阱"},{"content":"\r在 C++ 开发中，执行外部程序（如二进制文件、系统命令或 Shell 脚本）是一个常见的需求，尤其是在 Linux 系统中。C++ 提供了多种方式来实现这一功能，其中最常用的是 system() 函数和 exec 函数族。今天，我们一起来唠一唠。\n一、system() 函数：简单但有风险的解决方案 system() 是标准 C 库中的一个函数，用于执行系统命令。它通过调用系统的 Shell 来执行传递给它的命令，是一种相对简单的调用方式。尽管方便易用，但也存在一些潜在的安全隐患，特别是在处理不受信任的用户输入时。\n1.1 system() 的函数声明 1 int system(const char *command); 参数：command 是一个字符串，表示要执行的系统命令。 返回值：如果 Shell 能被正确执行，system() 返回 Shell 进程的返回值。如果出现错误（如没有可用的 Shell），它将返回一个非零值。 1.2 示例 执行一个简单的 Linux 命令，比如列出当前目录下的文件：\n1 system(\u0026#34;ls -la\u0026#34;); 这个调用会在 Shell 中执行 ls -la，并显示结果。\n1.3 system() 的优缺点 优点：\n简单易用：system() 非常直观，你只需提供一个字符串作为命令，系统会帮你处理余下的操作。 兼容性：由于 system() 是标准 C 函数，它可以跨平台工作，尽管不同平台上的细节可能会有所不同。 缺点：\n安全问题：system() 的最大问题是安全性，特别是在处理用户输入时。如果用户输入的命令直接传递给 system()，攻击者可能注入恶意代码。例如，用户输入 \u0026quot;; rm -rf /\u0026quot; 就可能会删除整个文件系统。因此，建议不要将用户输入直接传递给 system()，除非做了严格的验证。 性能开销：system() 会启动一个新的 Shell 进程来执行命令，这意味着每次调用都有额外的性能开销，特别是在需要频繁执行命令的场景下，这种开销可能会变得显著。 1.4 使用场景 system() 适用于一些简单的、非频繁的命令执行任务，例如在程序结束时调用 system(\u0026quot;pause\u0026quot;) 来暂停终端。 但是，在安全和性能要求较高的场景中，尽量避免使用 system()，而是选择更安全的替代方案。 二、exec 函数族：更灵活和安全的替代方案 与 system() 不同，exec 函数族提供了更直接、底层的方式来执行外部程序。它们不会创建新的进程，而是用新程序替换当前进程的映像。exec 函数族中的函数会立即将当前进程的代码和数据替换为新执行的程序，除非调用失败，否则它不会返回到原来的程序。\n2.1 exec 函数族的常见函数 exec 函数家族有多个变体，最常用的两个是：\nexecl()：将程序路径和参数作为变长参数传递。 execv()：传递程序路径和参数数组。 2.2 execl() 和 execv() 的函数声明 1 2 int execl(const char *path, const char *arg0, ..., NULL); int execv(const char *path, char *const argv[]); path：要执行的程序的路径。 arg0, ... / argv[]：要传递给新程序的参数。execl() 接受一系列变长参数，而 execv() 则接受一个指针数组。 2.3 示例 执行 ls -la 命令，使用 execl() 和 execv() 的等效代码如下：\n使用 execl()：\n1 execl(\u0026#34;/bin/ls\u0026#34;, \u0026#34;ls\u0026#34;, \u0026#34;-la\u0026#34;, NULL); 这里 /bin/ls 是要执行的命令路径，\u0026quot;ls\u0026quot; 是命令名，\u0026quot;-la\u0026quot; 是参数，最后一个 NULL 表示参数列表的结束。\n使用 execv()：\n1 2 char *args[] = {\u0026#34;ls\u0026#34;, \u0026#34;-la\u0026#34;, NULL}; execv(\u0026#34;/bin/ls\u0026#34;, args); execv() 的参数通过数组传递，最后一个元素必须为 NULL，以表示参数的结束。\n2.4 exec 的返回值 exec 函数只有在执行失败时才返回 -1，并设置 errno 来指示错误原因。如果成功执行，当前进程的代码将被新程序替换，且不会返回。\n2.5 exec 的优缺点 优点：\n灵活性：exec 函数族允许程序直接替换当前进程映像，这是 system() 无法做到的。这在需要运行一个长期运行的外部程序而不希望产生新进程时非常有用。 安全性：相较于 system()，exec 函数族更加安全，因为它不会经过 Shell 解析命令，减少了命令注入的风险。 缺点：\n使用复杂：exec 函数的调用比 system() 要复杂一些，特别是在处理参数时，需要额外的代码来构造参数数组或变长参数列表。 不会返回：成功调用 exec 后，原来的进程代码段、数据段会被新程序替换，因此调用之后的代码不会被执行。 2.6 使用场景 exec 函数族适合在当前进程中直接调用外部程序的场景，特别是在希望替换当前进程并执行新程序时非常有效，例如在服务器程序中 fork 子进程并通过 exec 执行新的任务。 它常用于需要更细粒度控制外部程序执行的场合，如编写守护进程、任务调度系统等。 三、system() 与 exec 的对比 特性 system() exec() 进程控制 启动一个新的 Shell 进程 替换当前进程 使用复杂度 简单，只需传递命令字符串 较复杂，需要处理参数 安全性 存在命令注入风险 更安全，不经过 Shell 解析 返回值 命令执行的返回值 仅在执行失败时返回 创建新进程 是 否，替换当前进程 参数传递 字符串 参数数组或变长参数 性能 需要创建新进程，开销较大 替换当前进程，开销较小 四、总结 在 C++ 开发中，选择 system() 还是 exec 函数族取决于具体的应用场景：\n如果你需要执行简单的外部命令，并且不太关注性能和安全问题，system() 是一个方便的选择。但要确保命令来源安全，避免命令注入攻击。 如果你需要更灵活和安全的控制，或者希望替换当前进程执行外部程序，exec 函数族则是更好的选择。 ","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/","summary":"在 C++ 开发中，执行外部程序（如二进制文件、系统命令或 Shell 脚本）是一个常见的需求，尤其是在 Linux 系统中。C++ 提供了多种方式来实现这一功能，其中最常用","title":"CPP中执行外部程序"},{"content":"\r在 C++ 开发中，全局变量和静态变量的使用是一个常见且重要的话题。虽然它们有着各自独特的特性，但在实际项目中，合理运用这些变量可以帮助我们提高代码的可读性和维护性，反之则可能带来难以发现的错误和隐患。\n一、全局变量的作用与局限 1.1 优势 全局变量因其在程序各个模块间共享数据的便利性而被广泛使用。它们可以被定义在程序的任意源文件中，并通过 extern 声明在其他源文件中访问。全局变量在以下情况下特别有用：\n状态共享：当多个模块、函数或类需要访问相同的数据时，全局变量可以用作一个共享的状态存储。例如，应用程序的配置参数、日志对象等常常被定义为全局变量，以便全局访问。 减少参数传递：在某些情况下，使用全局变量可以减少函数间大量传递参数的复杂性，特别是在需要在不同模块间传递多个状态时。 1.2 局限与风险 然而，全局变量的使用也带来了不少风险：\n命名冲突：由于全局变量可以在程序的任何地方被访问，如果项目中有多个开发者同时维护不同模块，可能会导致命名冲突，造成无法预期的错误。尽管可以使用命名空间来缓解这个问题，但仍然不能完全避免冲突。 难以维护：全局变量增加了模块之间的耦合度，导致代码维护难度加大。随着项目的复杂度增加，全局变量可能会分散在多个文件中，追踪它们的修改变得更加困难，容易导致意外的行为。 测试不便：全局变量由于在全局范围内可访问，往往难以对单独模块进行单元测试。因为全局状态可能会导致测试之间互相影响，难以保持测试环境的隔离性。 1.3 开发中的最佳实践 在现代C++开发中，尽量减少全局变量的使用是公认的最佳实践。可以通过以下方法替代全局变量：\n单例模式：当需要共享一个全局状态时，可以使用单例模式（Singleton）来保证只有一个实例存在，并且可以通过控制访问权限来减少对全局变量的不必要修改。 依赖注入：通过依赖注入（Dependency Injection）将依赖的对象或数据传递给需要的模块，避免全局状态的共享。 使用常量：对于全局只读的数据，可以使用 const 或 constexpr 来保证全局变量不可被修改，降低风险。 二、 静态变量的优点与使用场景 静态变量提供了与全局变量类似的功能，但作用范围更加局限，可以有效避免全局变量带来的问题。静态变量根据它们的定义位置可以分为局部静态变量和全局静态变量。\n2.1 局部静态变量 局部静态变量定义在函数或代码块内，虽然它们的生命周期与程序相同，但作用域仅限于该函数或代码块内。这使得局部静态变量非常适合用来维护状态，尤其在以下场景中非常有用：\n递归函数中的状态保存：在递归算法中，局部静态变量可以用于保存函数调用之间的状态。例如，在递归计算斐波那契数列时，可以使用静态变量来保存中间计算结果，避免重复计算。 只初始化一次：局部静态变量只会在函数第一次调用时被初始化，这可以避免每次调用函数时重复初始化的开销。在一些性能关键的代码中，这种特性非常有用。 2.2 全局静态变量 全局静态变量则定义在全局作用域中，但与普通全局变量不同，它们的作用域仅限于当前文件。这种限制作用域的特性使得全局静态变量可以用于模块内部的实现细节，避免其他模块误用。例如，某些模块内部的缓存机制或计数器可以使用全局静态变量来实现，而外部模块无法访问这些数据。\n隐藏实现细节：通过将全局静态变量定义在文件内部，可以确保这些变量不会暴露给其他文件，有效减少了模块之间的耦合。 避免命名冲突：由于全局静态变量不能被外部文件访问，因此即使不同文件中定义了相同名字的静态变量，也不会发生冲突。 2.3 静态变量的最佳实践 控制作用域：在使用静态变量时，应该尽可能将它们的作用范围限制在需要的最小范围内。对于局部静态变量，确保它们只在特定的函数中使用；对于全局静态变量，确保它们只在当前文件中有效。 避免滥用：虽然静态变量在保持状态和减少全局依赖上很有用，但也要避免过度使用静态变量。特别是在多线程环境中，静态变量可能引发数据竞争和不可预期的行为。因此，在并发编程中，应该使用锁或其他同步机制来保护静态变量的访问。 三、多线程中的静态与全局变量 在多线程程序中，全局变量和静态变量的使用需要格外小心。如果多个线程同时访问和修改这些变量，可能会导致数据竞争和未定义行为。常见的解决方案是：\n线程安全的访问：在访问全局变量或静态变量时，使用互斥锁（std::mutex）或读写锁来保护共享数据，确保同一时刻只有一个线程可以修改变量。 原子操作：对于简单的全局或静态计数器，可以使用 C++ 提供的原子类型（如 std::atomic）来避免锁的使用，提升性能。 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/","summary":"在 C++ 开发中，全局变量和静态变量的使用是一个常见且重要的话题。虽然它们有着各自独特的特性，但在实际项目中，合理运用这些变量可以帮助我们提高代码","title":"全局变量与静态变量"},{"content":"\r内存，也就是我们常说的内存条，是计算机系统中至关重要的组成部分，它不仅用于存储程序的代码和数据，还负责数据的快速访问和处理。计算机内部以字节为单位存储信息。当我们在程序中声明某种类型的变量时，实际上是在向系统申请一定数量的内存空间（以字节为单位）来存储数据。在本质上，所有与程序相关的内容都是关于内存中信息的表示和管理。\n在程序运行时，内存被划分为不同的区域，每个区域有其特定的用途和管理方式。以下是C++程序中常见的内存分区及其详细介绍：\n代码区（Code Segment） 代码区，也称为 .text 段，是存储程序的执行代码的区域。这个区域是只读的，以防止程序在运行过程中被意外修改。例如，编译后的 main 函数的逻辑存放在代码区。代码区还可能包含一些只读的常量，例如字符串字面量。\n1 2 3 4 5 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 全局/静态存储区（Global/Static Storage） 全局变量和静态变量存放在全局/静态存储区。C++ 中，全局变量和静态变量通常存放在同一块内存区，不再区分初始化的和未初始化的部分。而在 C 语言中，全局变量被分为 .data 段（初始化）和 .bss 段（未初始化），但在 C++ 中，它们共同占用全局/静态存储区。\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; int globalVar = 0; // 全局变量 void function() { static int staticVar = 0; // 静态变量 staticVar++; std::cout \u0026lt;\u0026lt; staticVar \u0026lt;\u0026lt; std::endl; } int main() { function(); function(); return 0; } 栈区（Stack） 栈区用于存储函数调用时的局部变量、函数参数以及返回地址。栈区的内存分配和释放由编译器自动管理，遵循后进先出（LIFO）原则。当函数调用完成后，分配给该函数的栈空间会被释放。\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; void function(int a, int b) { int localVar = a + b; std::cout \u0026lt;\u0026lt; localVar \u0026lt;\u0026lt; std::endl; } int main() { function(3, 4); return 0; } 在上面的例子中，a、b 和 localVar 都是局部变量，存放在栈区。函数调用结束后，栈区中对应的内存空间会被回收。\n堆区（Heap） 堆区用于动态内存分配。当使用 new（在C++中）或者 malloc（在C中）分配内存时，这些内存块会位于堆区。与栈区不同，堆区的内存分配和释放需要程序员手动管理，否则可能导致内存泄漏。\n1 2 3 4 5 6 7 #include \u0026lt;iostream\u0026gt; int main() { int* dynamicArray = new int[10]; // 动态分配内存 // 使用动态数组... delete[] dynamicArray; // 释放内存 return 0; } 常量区（Constant Storage） 常量区用于存储编译时确定的常量数据，例如字符串字面量和其他常量。这些数据通常是只读的，以确保它们在程序运行过程中不会被修改。\n1 2 3 4 5 #include \u0026lt;iostream\u0026gt; int main() { char* c = \u0026#34;abc\u0026#34;; // \u0026#34;abc\u0026#34; 在常量区，c 在栈上。 return 0; } ","permalink":"https://oheyu.github.io/zh/posts/tech/cpp%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","summary":"内存，也就是我们常说的内存条，是计算机系统中至关重要的组成部分，它不仅用于存储程序的代码和数据，还负责数据的快速访问和处理。计算机内部以字节","title":"CPP内存模型"},{"content":"\r在 C/C++ 中，new/delete 与 malloc/free 的使用涉及内存分配和释放的机制，虽然它们的功能表面上类似，但在使用上存在许多本质上的区别，使用时务必配对使用，不可混用。\n一、new/delete 与 malloc/free 的对比分析 1.1 内存分配的来源 new/delete：内存从“自由存储区”（Free Store）分配。自由存储区是专门为 C++ 中对象管理的内存区域，它的管理由 C++ 的内存分配机制决定。new 分配的内存适合构造对象，因为它会自动调用构造函数。\nmalloc/free：内存从“堆”（Heap）分配。这是 C 语言标准中的内存分配机制，malloc 只知道要分配的字节数，不会涉及到对象的构造和析构。\n说到这里，不得不简单谈一下内存分区。事实上，内存分区没有一个统一的定义，根据 CSAPP 这本书，我们可以将内存分为：代码区、全局/静态存储区、堆区、栈区以及常量区。我们可以将前述的 ”自由存储区“ 视为堆区，但其不仅可以是堆区，还可以是静态存储区，这由 operator new 的具体实现决定。\n1.2 返回类型 new/delete：new 返回一个完全类型化的指针，即指向特定类型的对象，因此不需要手动进行类型转换。如果分配失败，new 会抛出异常（std::bad_alloc），这与返回 NULL 的方式不同。当然，我们也可使用关键字 std::nothrow 使其在分配失败时返回 nullptr。\nmalloc/free：malloc 返回 void* 指针，意味着需要手动将其转换为所需的类型。并且当 malloc 分配失败时，它会返回 NULL，这要求使用者在每次分配时检查返回值。\n1.3 内存大小的计算 new/delete：编译器在编译时根据类型自动计算所需的内存大小，因此不需要手动提供内存的大小。尤其在处理类对象时，编译器会根据对象的类型自动分配所需的空间。\nmalloc/free：调用 malloc 时，必须明确指定要分配的字节数，这意味着开发人员需要自己计算复杂类型的大小。这在处理数组或结构体时显得尤其繁琐。\n1.4 数组分配 new/delete：C++ 提供了 new[] 和 delete[] 来专门分配和释放数组，这些操作会调用每个对象的构造函数和析构函数，确保数组中每个元素被正确初始化和销毁。\nmalloc/free：malloc 分配数组时，需要开发者自己手动计算总的字节大小，而 free 不会调用析构函数，因此需要开发者手动管理数组元素的初始化和销毁。\n1.5 对象的构造与析构 new/delete：new 会自动调用对象的构造函数来初始化分配的内存，delete 则会调用析构函数来清理对象的资源。这一点对需要进行资源管理（如动态内存、文件句柄等）的类尤为重要。\nmalloc/free：malloc 仅仅分配内存，不会调用构造函数，因此对象不会自动初始化。同样，free 也不会调用析构函数，仅仅是释放分配的内存。\n1.6 内存重新分配 new/delete：new 没有提供重新分配内存的机制。对于重新分配，需要手动管理复制和删除旧的对象。这在处理复杂类型时会涉及拷贝构造函数和析构函数的调用。\nmalloc/free：malloc 可以与 realloc 一起使用，实现更大的内存块分配，而无需担心对象的构造和析构。对于简单的内存块操作，realloc 更为直观和方便。\n1.7 内存不足处理 new/delete：C++ 提供了 std::set_new_handler，可以自定义内存不足时的处理方式，这允许开发者在内存不足时采取一些措施（如释放内存或记录日志）。\nmalloc/free：malloc 没有类似的机制来处理低内存情况。当系统内存不足时，malloc 直接返回 NULL，用户无法在这一点插入自己的代码来进行处理。\n1.8 是否可以重载 new/delete：C++ 允许用户重载 operator new 和 operator delete，这样可以自定义内存分配和释放的行为。例如，可以实现自定义的内存池或内存跟踪机制。\nmalloc/free：malloc 和 free 是标准库函数，不能被合法重载，因此不支持自定义内存管理行为。\n","permalink":"https://oheyu.github.io/zh/posts/tech/free%E4%B8%8Emalloc%E4%BB%A5%E5%8F%8Anew%E4%B8%8Edelete/","summary":"在 C/C++ 中，new/delete 与 malloc/free 的使用涉及内存分配和释放的机制，虽然它们的功能表面上类似，但在使用上存在许多本质上的区别，使用时务必配对使用","title":"Free与malloc以及new与delete"},{"content":"\r在处理文本特别是涉及东亚语言时，对于 “半角” 和 “全角“ 这两个术语，使用计算机这么多年，我们也疑惑了这么多年。事实上，它们主要与字符在屏幕或页面上所占用的宽度有关。\n一、什么是半角字符？ 半角字符指的是那些占用标准字符宽度的字符。通常，这个宽度指的是一个英文字母或数字在单字节编码（如ASCII）中的显示宽度。半角字符广泛用于英文文本、数字以及常见的标点符号。例如：\n半角字母：A 半角数字：1 半角标点：. 二、什么是全角字符？ 全角字符则占用两个标准字符宽度。这种字符常用于显示汉字、日文假名、韩文字符以及特定的标点符号。全角字符在视觉上比半角字符宽，常用于中文、日文、韩文等东亚语言的文本中。例如：\n全角汉字：你 全角数字：１ 全角标点：， 三、半角与全角的比较 宽度：半角字符的宽度为一个单位，而全角字符的宽度为两个单位。 字符集：半角字符多见于ASCII字符集，而全角字符多见于Unicode字符集中。 应用场景：半角字符常用于英文文本，全角字符则多用于中文、日文、韩文等文本中。 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%8D%8A%E8%A7%92%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%85%A8%E8%A7%92%E5%AD%97%E7%AC%A6/","summary":"在处理文本特别是涉及东亚语言时，对于 “半角” 和 “全角“ 这两个术语，使用计算机这么多年，我们也疑惑了这么多年。事实上，它们主要与字符在屏幕或页","title":"半角字符与全角字符"},{"content":"\r在操作系统中，符号链接（Symbolic Link）是一种常用的文件系统功能，它允许用户通过快捷方式访问其他文件或目录。\n一、什么是符号链接？ 符号链接是一种特殊的文件类型，它包含了指向另一个文件或目录的路径。你可以将其视为指向目标文件或目录的快捷方式或别名。在 Unix/Linux 系统中，符号链接的文件类型标记为 l，例如 lrwxrwxrwx。\n我们可以从以下四个方面来了解符号链接：\n独立性：符号链接本身是一个独立的文件，与它指向的目标文件或目录相分离。它仅仅包含目标的路径信息。\n路径：符号链接存储的是目标文件的路径，这个路径可以是相对的或绝对的。\n文件类型：符号链接的文件类型是 symlink，这是文件系统支持的一种特殊文件类型。\n创建：可以使用 ln -s 命令在 Unix/Linux 系统中创建符号链接。例如：\n1 ln -s /path/to/targetfile linkname 假设我们有一个名为 linkfile 的符号链接，它指向文件 targetfile。可以使用如下命令查看符号链接：\n1 2 $ ls -l linkfile lrwxrwxrwx 1 user group 12 Jul 29 15:00 linkfile -\u0026gt; /path/to/targetfile 在这个示例中，linkfile 是符号链接，指向 /path/to/targetfile。\n二、什么是符号链接所引用的文件？ 符号链接所引用的文件是符号链接指向的实际文件或目录。它是符号链接的目标，包含了真实的数据或内容。\n符号链接所引用的文件包含实际的数据或内容。这是磁盘上存储的真正文件。\n假设 linkfile 指向 /path/to/targetfile，那么 /path/to/targetfile 就是符号链接所引用的文件。这个文件可以是文本文件、二进制文件、目录等。\n三、符号链接与符号链接所引用的文件的区别 在定义方面：\n符号链接：一个特殊的文件，它包含了指向另一个文件或目录的路径。 符号链接所引用的文件：符号链接指向的实际文件或目录，包含真实的数据或内容。 在功能方面：\n符号链接：作为快捷方式，让用户通过符号链接访问实际文件或目录。 符号链接所引用的文件：实际存储数据或文件内容。 在实际操作方面：\n符号链接：对符号链接本身的操作（如删除、移动）不会影响目标文件的内容，除非它影响了路径。 符号链接所引用的文件：对目标文件的操作（如修改、删除）会影响文件内容。 ","permalink":"https://oheyu.github.io/zh/posts/tech/linux%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E6%89%80%E5%BC%95%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6/","summary":"在操作系统中，符号链接（Symbolic Link）是一种常用的文件系统功能，它允许用户通过快捷方式访问其他文件或目录。 一、什么是符号链接？ 符","title":"Linux中的符号链接与符号链接所引用的文件"},{"content":"\rfg 命令是 Unix 和类 Unix 操作系统中的一个重要命令，用于将后台运行的任务（进程）恢复到前台。它的全称是 \u0026ldquo;foreground\u0026rdquo;。下面将全面介绍 fg 命令，包括所有可能的使用场景和具体示例。\n一、fg 命令概述 fg 命令主要用于以下场景：将后台任务恢复到前台、恢复被挂起的任务以及管理多任务环境中的任务优先级。\n二、基本语法 1 fg [job_spec] 其中 job_spec 是任务的标识符，可以是任务编号、命令名等。job_spec 的常见格式包括：\n%n：任务编号，例如 %1。 %string：任务名，以 string 开头的任务。 %?string：任务名，包含 string 的任务。 三、使用场景及具体例子 3.1 将最近的后台任务恢复到前台 当你有一个或多个任务在后台运行时，可以使用 fg 命令将最近的一个任务恢复到前台。\n1 2 3 4 5 sleep 100 \u0026amp; # 任务 sleep 100 在后台运行 fg # 将最近的后台任务恢复到前台 3.2 将指定的后台任务恢复到前台 你可以通过任务编号或任务名来指定要恢复到前台的任务。\n1 2 3 4 5 6 7 8 9 10 sleep 100 \u0026amp; sleep 200 \u0026amp; # 两个任务在后台运行 jobs # [1]+ Running sleep 100 \u0026amp; # [2]- Running sleep 200 \u0026amp; fg %1 # 将任务编号为 1 的任务（sleep 100）恢复到前台 3.3 恢复包含特定字符串的任务 如果你有多个任务，并且不记得具体编号，可以通过任务名的一部分来恢复任务。\n1 2 3 4 5 6 vi file1 \u0026amp; vi file2 \u0026amp; # 两个 vi 编辑器任务在后台运行 fg %?file2 # 将包含 \u0026#39;file2\u0026#39; 的任务恢复到前台 3.4 恢复被挂起的任务 有时，你可能会挂起一个正在前台运行的任务，然后将其恢复。\n1 2 3 4 5 6 7 8 sleep 1000 # 按下 Ctrl+Z 挂起任务 jobs # [1]+ Stopped sleep 1000 fg %1 # 将挂起的任务恢复到前台 3.5 在多任务环境中管理任务 在复杂的多任务环境中，可以通过 fg 命令来管理不同任务的优先级。\n1 2 3 4 5 6 7 8 9 10 # 启动几个长时间运行的任务 sleep 1000 \u0026amp; sleep 2000 \u0026amp; sleep 3000 \u0026amp; jobs # 列出所有后台任务 fg %3 # 将任务编号为 3 的任务恢复到前台 四、补充说明 任务编号：\n可以使用 jobs 命令查看所有后台和挂起的任务及其编号。 任务编号在当前 shell 会话中是唯一的，但在不同的 shell 会话中可能会重复。 任务状态：\nRunning：任务正在后台运行。 Stopped：任务被挂起。 Done：任务已完成。 组合使用：\nfg 命令通常与 \u0026amp;（后台运行符）、jobs（查看后台任务）和 bg（将任务放到后台）等命令一起使用，以实现灵活的任务管理。 ","permalink":"https://oheyu.github.io/zh/posts/tech/fg%E5%91%BD%E4%BB%A4/","summary":"fg 命令是 Unix 和类 Unix 操作系统中的一个重要命令，用于将后台运行的任务（进程）恢复到前台。它的全称是 \u0026ldquo;foreground\u0026rdquo;","title":"Fg命令"},{"content":"\r在网络编程中，特别是在使用套接字编程时，地址解析和管理是一个关键问题。为了简化这个过程，POSIX 标准定义了 addrinfo 结构体和相关函数。\n一、addrinfo 结构体简介 addrinfo 结构体用于存储地址信息，getaddrinfo 函数通过解析主机名和服务名生成这个结构体的链表。以下是 addrinfo 结构体的定义：\n1 2 3 4 5 6 7 8 9 10 struct addrinfo { int ai_flags; // 输入标志 int ai_family; // 地址簇（如 AF_INET、AF_INET6） int ai_socktype; // 套接字类型（如 SOCK_STREAM、SOCK_DGRAM） int ai_protocol; // 协议（如 IPPROTO_TCP、IPPROTO_UDP） socklen_t ai_addrlen; // 套接字地址的长度 struct sockaddr *ai_addr; // 套接字地址 char *ai_canonname; // 规范名 struct addrinfo *ai_next; // 指向下一个 addrinfo 结构的指针 }; 二、成员变量详细解析 （1）ai_flags：指定 getaddrinfo 函数的行为，可以是以下标志的组合：\nAI_PASSIVE: 如果设置了该标志，表示返回的套接字地址用于绑定（绑定到 INADDR_ANY 或 in6addr_any）。\nAI_CANONNAME: 返回主机的规范名称，通过 ai_canonname 成员指向。\nAI_NUMERICHOST: 以数字字符串形式返回主机地址，而不是名称。\nAI_NUMERICSERV: 以数字字符串形式返回服务地址，而不是名称。\nAI_V4MAPPED: 如果没有找到 IPv6 地址，则返回 IPv4 映射的 IPv6 地址。\nAI_ALL: 返回 IPv4 和 IPv6 地址。\nAI_ADDRCONFIG: 仅在系统中配置的地址类型上返回地址。\n1 2 3 struct addrinfo hints; memset(\u0026amp;hints, 0, sizeof hints); hints.ai_flags = AI_PASSIVE | AI_CANONNAME; （2）ai_family：指定地址簇，可以是以下值：\nAF_INET: IPv4 协议 AF_INET6: IPv6 协议 AF_UNSPEC: 未指定（既可以是 IPv4 也可以是 IPv6） 1 hints.ai_family = AF_INET; // 仅返回 IPv4 地址 （3）ai_socktype：指定套接字类型，可以是以下值：\nSOCK_STREAM: 流套接字（如 TCP） SOCK_DGRAM: 数据报套接字（如 UDP） SOCK_RAW: 原始套接字 其他类型根据系统而定 1 hints.ai_socktype = SOCK_STREAM; // 返回流套接字地址 （4）ai_protocol：指定协议，可以是以下值：\nIPPROTO_TCP: TCP 协议 IPPROTO_UDP: UDP 协议 其他协议根据系统而定 1 hints.ai_protocol = IPPROTO_TCP; // 返回 TCP 协议地址 （5）ai_addrlen：指定套接字地址的长度。\n这个成员变量一般由 getaddrinfo 函数设置，无需手动设置。\n（6）ai_addr：指向套接字地址的指针。\n同样的，这个成员变量一般由 getaddrinfo 函数设置，无需手动设置。\n（7）ai_canonname：指向主机的规范名称的指针。\n仅在设置 AI_CANONNAME 标志时返回。\n（8）ai_next：指向下一个 addrinfo 结构的指针，形成一个链表。\n也是啦，这个一般由 getaddrinfo 函数设置，无需手动设置。\n三、示例程序 以下是一个示例程序，展示如何使用 getaddrinfo 解析域名，并通过 addrinfo 结构体访问地址信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void resolveDomain(const std::string\u0026amp; domain, const std::string\u0026amp; service) { struct addrinfo hints, *res, *p; char ipstr[INET6_ADDRSTRLEN]; int status; memset(\u0026amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; // 支持IPv4和IPv6 hints.ai_socktype = SOCK_STREAM; // TCP hints.ai_flags = AI_PASSIVE | AI_CANONNAME; // 设置标志 if ((status = getaddrinfo(domain.c_str(), service.c_str(), \u0026amp;hints, \u0026amp;res)) != 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;getaddrinfo: \u0026#34; \u0026lt;\u0026lt; gai_strerror(status) \u0026lt;\u0026lt; std::endl; return; } std::cout \u0026lt;\u0026lt; \u0026#34;IP addresses for \u0026#34; \u0026lt;\u0026lt; domain \u0026lt;\u0026lt; \u0026#34; on service \u0026#34; \u0026lt;\u0026lt; service \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; std::endl; for (p = res; p != nullptr; p = p-\u0026gt;ai_next) { void *addr; std::string ipver; // 获取地址 if (p-\u0026gt;ai_family == AF_INET) { // IPv4 struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-\u0026gt;ai_addr; addr = \u0026amp;(ipv4-\u0026gt;sin_addr); ipver = \u0026#34;IPv4\u0026#34;; } else { // IPv6 struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-\u0026gt;ai_addr; addr = \u0026amp;(ipv6-\u0026gt;sin6_addr); ipver = \u0026#34;IPv6\u0026#34;; } // 转换IP为字符串 inet_ntop(p-\u0026gt;ai_family, addr, ipstr, sizeof ipstr); std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ipver \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; ipstr \u0026lt;\u0026lt; std::endl; if (hints.ai_flags \u0026amp; AI_CANONNAME \u0026amp;\u0026amp; p-\u0026gt;ai_canonname) { std::cout \u0026lt;\u0026lt; \u0026#34; Canonical name: \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;ai_canonname \u0026lt;\u0026lt; std::endl; } } freeaddrinfo(res); } int main(int argc, char *argv[]) { if (argc != 3) { std::cerr \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;domain\u0026gt; \u0026lt;port\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } std::string domain = argv[1]; std::string service = argv[2]; resolveDomain(domain, service); return 0; } 3.1 运行示例 编译：\n1 g++ -o resolveDomain resolveDomain.cpp 运行：\n1 ./resolveDomain example.com 80 示例输出\n1 2 3 4 5 IP addresses for example.com on service 80: IPv4: 93.184.216.34 Canonical name: example.com IPv6: 2606:2800:220:1:248:1893:25c8:1946 Canonical name: example.com ","permalink":"https://oheyu.github.io/zh/posts/tech/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90addrinfo%E7%BB%93%E6%9E%84%E4%BD%93/","summary":"在网络编程中，特别是在使用套接字编程时，地址解析和管理是一个关键问题。为了简化这个过程，POSIX 标准定义了 addrinfo 结构体和相关函数。 一、addr","title":"深入剖析addrinfo结构体"},{"content":"\r一、什么是监听描述符（Listening Descriptor）？ 监听描述符主要用于等待和接受传入的客户端连接请求。它在服务器启动时被创建和配置，但它不参与实际的数据传输。\n1.1 监听描述符的基本功能 监听描述符的主要作用是等待并接受传入的客户端连接请求。它不会直接处理数据，而是管理和控制连接的建立过程。\n1.2 监听描述符的创建和配置 创建套接字：通过调用 socket() 函数创建新的套接字。 绑定地址和端口：使用 bind() 函数将套接字绑定到特定的地址和端口。 进入监听状态：调用 listen() 函数使套接字进入监听状态，准备接受客户端的连接请求。 1.3 监听描述符的状态和行为 监听描述符始终处于被动监听状态，等待客户端发起连接请求。当有客户端尝试连接时，监听描述符将连接请求排入等待队列，等待进一步处理。\n1.4 应用场景 监听描述符通常用于服务器应用程序的初始化阶段，定义服务器在哪些网络接口和端口上等待连接。这一过程确保了服务器能够接收到来自客户端的连接请求。\n二、什么是已连接描述符（Connected Descriptor）？ 已连接描述符用于实际的客户端-服务器通信。它是在服务器接受到客户端的连接请求后，通过调用 accept() 函数生成的新的套接字描述符。\n2.1 基本功能 已连接描述符负责处理与特定客户端的所有数据传输操作，包括读取客户端发送的数据和向客户端发送数据。\n2.2 创建和配置 当监听描述符检测到一个传入的连接请求时，通过调用 accept() 函数生成一个新的已连接描述符。这个新的描述符与特定的客户端关联。\n2.3 状态和行为 已连接描述符处于活跃状态，可以进行双向数据传输操作。每个已连接描述符都是独立的，与单个客户端连接关联，直到连接关闭。\n2.4 应用场景 已连接描述符在服务器接收到连接请求后立即生成，用于处理该请求后的所有数据传输。每个客户端连接都会对应一个独立的已连接描述符，使服务器能够同时处理多个客户端连接。\n三、监听描述符与已连接描述符的区别 角色和职责：\n监听描述符：负责监听和接受新的连接请求，不处理实际的数据传输。 已连接描述符：负责处理已建立连接的实际数据传输，与特定客户端进行通信。 生命周期：\n监听描述符：在服务器的整个运行期间通常是持久的，一直在监听新的连接请求。 已连接描述符：生命周期相对较短，从连接建立到连接结束，处理完客户端通信后即关闭。 数量和管理：\n监听描述符：一个服务器通常只有一个监听描述符，负责监听特定的端口。 已连接描述符：服务器会有多个已连接描述符，每个客户端连接对应一个，这些描述符由监听描述符生成并管理。 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%9B%91%E5%90%AC%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E5%B7%B2%E8%BF%9E%E6%8E%A5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%9C%A8%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"一、什么是监听描述符（Listening Descriptor）？ 监听描述符主要用于等待和接受传入的客户端连接请求。它在服务器启动时被创建和配","title":"监听描述符与已连接描述符在网络编程中的区别"},{"content":"\r在软件开发过程中，组织和管理项目文件是一项至关重要的任务。一个良好的目录结构可以提高开发效率、简化项目维护、促进团队协作。在 C++ 项目中，目录结构的设计尤为重要，因为 C++ 项目通常包含多个源文件、头文件、库文件等。一个清晰、高效的 C++ 工程项目目录结构究竟是个什么样子？\n一、目录结构概述 一个典型的 C++ 项目目录结构可能如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 project_root/ ├── src/ │ ├── main.cpp │ ├── myclass.cpp │ └── utilities.cpp ├── include/ │ ├── myclass.h │ └── utilities.h ├── lib/ │ └── some_library.a ├── bin/ │ └── my_project_executable ├── CMakeLists.txt └── README.md 上述的项目目录结构算是最常见、最基础的。下面，让我们来逐一解析这些目录和文件的用途。\n二、src/：源代码文件夹 src 文件夹用于存放项目的源代码文件（通常是 .cpp 或 .cxx 文件）。这些文件包含项目的实现代码。通过将源代码文件集中存放在 src 文件夹中，可以清晰地组织和管理项目的核心逻辑。假设，我们有以下三个 .cpp 文件：\n（1）示例文件：main.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026#34;myclass.h\u0026#34; #include \u0026#34;utilities.h\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { MyClass obj; obj.doSomething(); utilityFunction(); return 0; } （2）示例文件：myclass.cpp\n1 2 3 4 5 6 #include \u0026#34;myclass.h\u0026#34; #include \u0026lt;iostream\u0026gt; void MyClass::doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Doing something!\u0026#34; \u0026lt;\u0026lt; std::endl; } （3）示例文件：utilities.cpp\n1 2 3 4 5 6 #include \u0026#34;utilities.h\u0026#34; #include \u0026lt;iostream\u0026gt; void utilityFunction() { std::cout \u0026lt;\u0026lt; \u0026#34;Utility function!\u0026#34; \u0026lt;\u0026lt; std::endl; } 二、include/：头文件文件夹 include 文件夹用于存放项目的头文件（通常是 .h 或 .hpp 文件）。头文件包含类、函数的声明和接口定义。将头文件和源文件分开存放有助于模块化开发，便于代码重用和维护。\n对应于 src/ 文件夹中的 myclass.cpp 以及 utilities.cpp，我们有以下头文件：\n（1）示例文件：myclass.h\n1 2 3 4 5 6 7 8 9 #ifndef MYCLASS_H #define MYCLASS_H class MyClass { public: void doSomething(); }; #endif // MYCLASS_H （2）示例文件：utilities.h\n1 2 3 4 5 6 #ifndef UTILITIES_H #define UTILITIES_H void utilityFunction(); #endif // UTILITIES_H 三、lib/：库文件文件夹 lib 文件夹用于存放项目依赖的库文件（通常是 .a、.so 或 .dll 文件）。这些库文件在编译和链接阶段会被使用。通过将库文件集中存放，可以更方便地管理和更新项目依赖。\n四、bin/：可执行文件文件夹 bin 文件夹用于存放编译生成的可执行文件或二进制文件。通过将生成的二进制文件集中存放，可以更容易地运行和测试项目。\n五、CMakeLists.txt：构建配置文件 CMakeLists.txt 是 CMake 构建系统的配置文件，用于定义项目的构建流程。CMake 是一个跨平台的自动化构建工具，能够生成各种构建系统的配置文件（如 Makefile、Visual Studio 工程文件等）。\n示例文件：CMakeLists.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 cmake_minimum_required(VERSION 3.10) # 设置项目名称和版本 project(MyProject VERSION 1.0) # 设置 C++ 标准 set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) # 包含头文件目录 include_directories(include) # 添加源文件 set(SOURCES src/main.cpp src/myclass.cpp src/utilities.cpp ) # 添加可执行文件 add_executable(MyProject ${SOURCES}) 六、README.md：项目说明文件 README.md 是项目的说明文件，通常使用 Markdown 语法编写。它包含项目的描述、安装使用说明、开发环境要求等信息。一个详细的 README 文件有助于其他开发者快速了解和上手项目。\n示例文件：README.md\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # MyProject This is a simple C++ project demonstrating a typical project directory structure. ## Getting Started ### Prerequisites - C++11 or higher - CMake 3.10 or higher ### Building the Project 1. Clone the repository: git clone https://github.com/yourusername/myproject.git cd myproject 2. Create a build directory and navigate into it: mkdir build cd build 3. Generate the build files using CMake: cmake .. 4. Build the project: make 5. Run the executable: ./MyProject 结论 一个良好的 C++ 项目目录结构可以显著提高开发效率、简化项目维护和促进团队协作。通过将源代码文件、头文件、库文件和可执行文件分开存放，并使用构建系统工具如 CMake，可以更好地组织和管理项目。希望本文介绍的典型 C++ 项目目录结构和示例代码能够帮助你更好地构建和维护 C++ 项目。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3%E5%92%8C%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84c++%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","summary":"在软件开发过程中，组织和管理项目文件是一项至关重要的任务。一个良好的目录结构可以提高开发效率、简化项目维护、促进团队协作。在 C++ 项目中，目录结","title":"理解和构建一个高效的C++工程项目目录结构"},{"content":"\rLinux 手册页（man pages）是每个 Linux 用户和开发者的重要资源。它们提供了关于各种命令、系统调用、库函数、文件格式等的详细信息。手册页分为多个章节，每个章节涵盖特定类型的内容。\n一. 用户命令（User Commands） 章节编号：1\n内容：普通用户可以运行的命令和程序。\n适用场景：查找和学习日常使用的命令，如 ls、cp、grep 等。\n示例：\n1 man 1 ls 二. 系统调用（System Calls） 章节编号：2\n内容：操作系统内核提供的系统调用。\n适用场景：编写与操作系统内核直接交互的低级程序，例如涉及文件操作、进程控制等。\n示例：\n1 man 2 open 三. 库函数（Library Functions） 章节编号：3\n内容：C 标准库（libc）函数及其他库函数。\n适用场景：使用 C 语言编程时，查找标准库函数的用法和参数，例如字符串处理、数学函数等。\n示例：\n1 man 3 printf 四. 特殊文件（Special Files） 章节编号：4\n内容：设备文件和驱动程序。\n适用场景：与硬件设备交互或开发驱动程序时，查找设备文件的详细信息。\n示例：\n1 man 4 tty 五. 文件格式（File Formats and Conventions） 章节编号：5\n内容：各种文件格式、配置文件和协议描述。\n适用场景：编写或解析特定格式的文件时，了解文件格式的细节。\n示例：\n1 man 5 passwd 六. 游戏和杂项（Games and Screensavers） 章节编号：6\n内容：游戏和屏幕保护程序。\n适用场景：查找和了解系统上安装的游戏或屏幕保护程序。\n示例：\n1 man 6 snake 七. 杂项（Miscellaneous） 章节编号：7\n内容：与系统相关的杂项信息，包括宏包、惯例和协议。\n适用场景：查找与网络协议、文件系统、进程间通信等相关的高级主题。\n示例：\n1 man 7 socket 八. 系统管理命令（System Administration Commands） 章节编号：8\n内容：系统管理员使用的命令。\n适用场景：进行系统维护、配置和管理时，查找管理员级别的命令。\n示例：\n1 man 8 mount 九. 内核例程（Kernel Routines） 章节编号：9\n内容：内核开发和模块编程相关的函数和宏。\n适用场景：进行 Linux 内核开发或编写内核模块时，查找内核函数和数据结构的详细信息。\n示例：\n1 man 9 printk 总结 用户命令：日常使用的命令和工具。 系统调用：与操作系统内核交互的函数。 库函数：标准库和其他库提供的函数。 特殊文件：设备文件和驱动程序信息。 文件格式：配置文件和文件格式描述。 游戏和杂项：系统上的游戏和屏幕保护程序。 杂项：高级主题和系统相关信息。 系统管理命令：管理员使用的命令。 内核例程：内核开发相关的信息。 ","permalink":"https://oheyu.github.io/zh/posts/tech/linux%E6%89%8B%E5%86%8C%E9%A1%B5%E6%8C%87%E5%8D%97%E4%BA%86%E8%A7%A3%E5%90%84%E7%AB%A0%E8%8A%82%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","summary":"Linux 手册页（man pages）是每个 Linux 用户和开发者的重要资源。它们提供了关于各种命令、系统调用、库函数、文件格式等的详细信息。手册页分为多个章","title":"Linux手册页指南：了解各章节及其使用场景"},{"content":"\r在使用 PyTorch 进行模型训练时，为什么需要设置训练模式？如何计算每个 epoch 的平均损失？今天，我们来唠一唠。\n一、模型的训练模式 在训练神经网络模型时，特别是在使用 PyTorch 框架时，我们通常会看到类似如下的代码：\n1 model.train() 这行代码将模型设置为训练模式。这对于一些特定的层，如 Dropout 和 Batch Normalization，尤为重要。让我们深入了解一下原因。\n1.1 Dropout 层 Dropout 是一种正则化技术，旨在防止过拟合。在训练过程中，Dropout 会随机地将一部分神经元的输出设为零，从而防止模型对训练数据过拟合。然而，在测试和评估模型时，我们希望使用所有的神经元。因此，Dropout 层在训练和测试时的行为有所不同：\n训练模式：随机屏蔽部分神经元。 评估模式：使用所有神经元，不进行屏蔽。 1.2 Batch Normalization 层 Batch Normalization 通过在每个小批次上标准化输入来加速训练和提高稳定性。在训练和测试时，它的行为也不同：\n训练模式：使用当前批次的数据计算均值和方差进行标准化。 评估模式：使用在训练过程中积累的全局均值和方差进行标准化。 因此，将模型设置为训练模式（model.train()）确保了这些层在训练时表现正确。如果忘记了这一步，可能会导致训练效果不佳或者评估结果不准确。\n二、计算每个 epoch 的平均损失 在训练过程中，我们需要跟踪模型的性能，其中一个常用的指标是损失（loss）。损失函数用于衡量模型预测值与实际值之间的误差。在每个 epoch 结束时，计算其平均损失是一个常见做法。以下是计算每个 epoch 平均损失的代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def train(model, device, trainloader, criterion, optimizer, num_epochs): model.train() train_losses = [] for epoch in range(num_epochs): running_loss = 0.0 for inputs, labels in tqdm(trainloader, desc=f\u0026#34;Epoch [{epoch+1}/{num_epochs}]\u0026#34;): inputs, labels = inputs.to(device), labels.to(device) optimizer.zero_grad() outputs = model(inputs) loss = criterion(outputs, labels) loss.backward() optimizer.step() running_loss += loss.item() epoch_loss = running_loss / len(trainloader) train_losses.append(epoch_loss) print(f\u0026#34;Epoch [{epoch+1}/{num_epochs}], Loss: {epoch_loss:.4f}\u0026#34;) return train_losses 2.1 详细解释： Epoch：一个 epoch 表示模型完整地遍历一次训练数据集。在一个 epoch 内，模型会处理多个批次（batch）的数据。\nBatch：为了处理大型数据集，训练数据通常被分割成多个小批次。每个批次中的数据量称为 batch size。\n在每个 epoch 的训练过程中，我们会累加每个批次的损失到 running_loss 中。running_loss 记录了当前 epoch 中所有批次的总损失。\nlen(trainloader) 表示训练数据加载器中批次的数量。为了计算当前 epoch 的平均损失，我们将 running_loss 除以批次的数量 len(trainloader)。这种方法提供了一个衡量标准，表示在整个训练周期内，模型在所有训练数据上的平均损失。\n2.2 代码解析： 1 epoch_loss = running_loss / len(trainloader) 这行代码计算当前 epoch 的平均损失。running_loss 是所有批次的总损失，将其除以批次数量，得到每个批次的平均损失。这有助于监控训练过程中损失的变化，判断模型是否在逐渐收敛。\n总结 在训练模式下，Dropout 和 Batch Normalization 层的行为与评估模式不同，确保这些层在训练过程中表现正确至关重要。\n","permalink":"https://oheyu.github.io/zh/posts/tech/pytorch%E4%B8%AD%E7%9A%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8D%9F%E5%A4%B1%E8%AE%A1%E7%AE%97/","summary":"在使用 PyTorch 进行模型训练时，为什么需要设置训练模式？如何计算每个 epoch 的平均损失？今天，我们来唠一唠。 一、模型的训练模式 在训练神经网络模型时，特别是","title":"PyTorch中的训练模式和损失计算"},{"content":"\r在 C++ 中，逗号运算符 , 是一个有趣且常见的运算符，它允许在一个语句中计算多个表达式。虽然它的使用相对简单，但在某些情况下可能会引起混淆。\n逗号运算符的基本原理 逗号运算符 , 会依次计算其左侧和右侧的表达式，整个表达式的结果是右侧表达式的值。其基本用法如下：\n1 expression1, expression2 步骤 1：计算 expression1 并丢弃其结果。 步骤 2：计算 expression2 并返回其结果。 考虑以下例子：\n1 int x = (1, 024); 其中，\n逗号运算符 (1, 024) 会首先计算 1，然后计算 024。 024 是一个八进制数（因为前导零），其值为 2*8 + 4 = 20（十进制）。 最终，int x = (1, 024); 等效于 int x = 20;。 此外，我们也可以使用逗号运算符进行赋值：\n1 2 int y; y = 1,024; 其中：\n赋值运算符 = 的优先级高于逗号运算符，因此 y = 1,024; 实际上等效于 (y = 1), 024;。 首先计算 (y = 1)，将 1 赋值给 y。 然后计算 024，其值为八进制的 20，但其结果被丢弃。 最终，y 的值是 1。\n总结 逗号运算符 , 在 C++ 中允许在一个语句中计算多个表达式，并返回右侧表达式的结果。其主要用途包括：\n在循环中进行多变量操作。 在赋值或初始化语句中对多个表达式进行计算。 在赋值语句中使用逗号运算符时，需要注意赋值运算符的优先级以及表达式的计算顺序，以避免意外结果。例如：\n1 2 int y; y = (1, 024); // y 将被初始化为 20（八进制） 1 2 int y; y = 1,024; // y 将被赋值为 1 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3cpp%E4%B8%AD%E7%9A%84%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E5%9C%A8%E8%B5%8B%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","summary":"在 C++ 中，逗号运算符 , 是一个有趣且常见的运算符，它允许在一个语句中计算多个表达式。虽然它的使用相对简单，但在某些情况下可能会引起混淆。 逗号运算","title":"理解CPP中的逗号运算符及其在赋值中的应用"},{"content":"\r在C语言编程中，NULL字符（通常表示为 \\0）是一个关键的概念，尤其在处理字符串时。它标志着字符串的结束，并在许多函数和算法中起着至关重要的作用。本篇博客将详细解释NULL字符的作用、典型使用场景以及需要注意的事项。\n一、什么是 NULL 字符？ NULL字符是一个值为零的字符，表示字符串的终止。在C语言中，字符串实际上是一个字符数组，而NULL字符的存在是为了标志这个字符数组的结尾。\n1 char str[] = \u0026#34;Hello, world!\u0026#34;; 上面这个字符串数组str在内存中实际存储如下：\n1 H e l l o , w o r l d ! \\0 这里的\\0就是NULL字符，它表示字符串的结束。\n二、NULL 字符的作用 2.1 标志字符串的结束 NULL字符用于标识字符串的结尾，使得C语言中的字符串处理函数（如strlen、strcpy、printf等）能够正确地处理字符串。\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026#34;Hello\u0026#34;; printf(\u0026#34;Length of string: %zu\\n\u0026#34;, strlen(str)); // 输出 5 return 0; } 2.2 避免缓冲区溢出 在处理输入输出时，通过限定字符串长度并添加NULL字符，可以有效防止缓冲区溢出等安全问题。\n1 2 3 char buffer[10]; strncpy(buffer, \u0026#34;This is a long string\u0026#34;, sizeof(buffer) - 1); buffer[sizeof(buffer) - 1] = \u0026#39;\\0\u0026#39;; // 确保以 NULL 结尾 2.3 方便字符串操作 大多数C标准库函数都依赖NULL字符来确定字符串的长度和边界，使用NULL字符能够简化字符串操作。\n三、使用场景 3.1 字符串初始化 在定义和初始化字符串时，编译器会自动在末尾添加NULL字符。\n1 char str[] = \u0026#34;Hello\u0026#34;; // 实际大小是 6, 包括末尾的 NULL 字符 3.2 字符串操作函数 函数如strcpy、strcat等都会处理NULL字符，确保字符串正确终止。\n1 2 3 4 char dest[20]; strcpy(dest, \u0026#34;Hello\u0026#34;); strcat(dest, \u0026#34;, world!\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, dest); // 输出 Hello, world! 3.3 读取和写入字符串 在读取用户输入或从文件中读取字符串时，需要确保输入数据以NULL字符结尾。\n1 2 3 char buffer[100]; fgets(buffer, sizeof(buffer), stdin); buffer[strcspn(buffer, \u0026#34;\\n\u0026#34;)] = \u0026#39;\\0\u0026#39;; // 用 NULL 字符替换换行符 四、注意事项 4.1 确保NULL字符存在 在字符串操作时，务必确保字符串以NULL字符结尾，否则可能导致未定义行为或内存访问错误。\n4.2 防止越界写入 在写入字符串数据时，要注意缓冲区大小，防止越界写入，确保不会覆盖NULL字符。\n4.3 正确处理多字节字符 在处理多字节字符（如UTF-8编码）时，要特别注意字符边界和NULL字符的位置。\n总结 NULL字符在C语言中起着重要作用，它标志着字符串的结束，使得字符串处理变得可靠和简便。通过理解NULL字符的作用和使用场景，并注意相关的安全问题，可以更好地编写健壮的C代码。希望这篇博客能帮助你更好地理解和使用NULL字符。\n代码示例 以下是一个结合所有上述概念的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAX_LEN 100 int main() { char buffer[MAX_LEN]; printf(\u0026#34;Enter a string: \u0026#34;); if (fgets(buffer, MAX_LEN, stdin) != NULL) { buffer[strcspn(buffer, \u0026#34;\\n\u0026#34;)] = \u0026#39;\\0\u0026#39;; // 确保以 NULL 结尾 printf(\u0026#34;You entered: %s\\n\u0026#34;, buffer); printf(\u0026#34;Length of string: %zu\\n\u0026#34;, strlen(buffer)); } else { printf(\u0026#34;Error reading input.\\n\u0026#34;); } return 0; } 这个示例从用户读取一个字符串，确保其以NULL字符结尾，并输出字符串及其长度。通过这种方式，可以安全地处理用户输入，避免常见的字符串操作错误。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84null%E5%AD%97%E7%AC%A6/","summary":"在C语言编程中，NULL字符（通常表示为 \\0）是一个关键的概念，尤其在处理字符串时。它标志着字符串的结束，并在许多函数和算法中起着至关重要的","title":"理解C语言中的NULL字符"},{"content":"\r在系统编程中，尤其是文件 I/O 操作中，我们经常需要处理大量数据的读取和写入。为了提高效率，常常使用缓冲机制。本文将详细探讨缓冲性质函数和非缓冲性质函数的区别，以及为何不能在同一文件描述符上交替使用这两种类型的函数。\n一、什么是缓冲性质函数？ 缓冲性质函数是指那些在内部维护一个缓冲区，用于存储从文件描述符读取的数据的函数。这些函数一次读取多个字节的数据到缓冲区中，然后根据用户的请求从缓冲区中返回所需的数据。这种机制可以减少系统调用的次数，从而提高 I/O 操作的效率。\n例如，假设我们有一个 rio_readnb 函数，其功能是从文件描述符 rp 读取最多 n 字节的数据到内存位置 usrbuf。该函数可能会如下实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ssize_t rio_readnb(int fd, void *usrbuf, size_t n) { // 内部维护一个缓冲区 static char buffer[BUFFER_SIZE]; static size_t buffer_count = 0; static char *buffer_ptr = buffer; size_t nleft = n; ssize_t nread; char *bufp = usrbuf; while (nleft \u0026gt; 0) { if (buffer_count == 0) { // 缓冲区为空，从文件描述符读取数据填充缓冲区 if ((nread = read(fd, buffer, sizeof(buffer))) \u0026lt; 0) { if (errno == EINTR) { continue; // 处理信号中断，重试读取 } else { return -1; // 读取错误 } } else if (nread == 0) { break; // 文件结束 } buffer_ptr = buffer; buffer_count = nread; } // 从缓冲区读取数据到用户缓冲区 size_t cnt = (nleft \u0026lt; buffer_count) ? nleft : buffer_count; memcpy(bufp, buffer_ptr, cnt); bufp += cnt; buffer_ptr += cnt; buffer_count -= cnt; nleft -= cnt; } return (n - nleft); // 返回读取的字节数 } 二、什么是非缓冲性质函数？ 非缓冲性质函数则不维护任何内部缓冲区，而是每次调用时直接从文件描述符读取数据并返回给用户。这些函数每次调用都触发系统调用，从而直接从文件描述符读取数据。\n例如，假设我们有一个 rio_readn 函数，其功能是直接从文件描述符读取 n 字节的数据到内存位置 usrbuf，可能会如下实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ssize_t rio_readn(int fd, void *usrbuf, size_t n) { size_t nleft = n; ssize_t nread; char *bufp = usrbuf; while (nleft \u0026gt; 0) { if ((nread = read(fd, bufp, nleft)) \u0026lt; 0) { if (errno == EINTR) { nread = 0; // 处理信号中断，重新读取 } else { return -1; // 读取错误 } } else if (nread == 0) { break; // 文件结束 } nleft -= nread; bufp += nread; } return (n - nleft); // 返回读取的字节数 } 三、缓冲性质函数与非缓冲性质函数为何不能交替使用？ 缓冲性质函数和非缓冲性质函数在同一文件描述符上交替使用会导致数据读取的不一致和错误。这是因为这两种类型的函数在处理文件描述符时的内部机制不同。\n3.1 数据不一致的问题 缓冲性质函数在读取数据时，会一次性从文件描述符读取多个字节的数据到内部缓冲区，然后再从缓冲区返回数据给用户。这意味着文件描述符的读指针会因为读取操作而移动到缓冲区数据的末尾位置。\n如果接着调用非缓冲性质函数，由于它不维护缓冲区，会直接从文件描述符的当前位置读取数据。这会导致以下问题：\n跳过数据：缓冲性质函数已经读取但尚未处理的数据会被非缓冲性质函数跳过，导致数据丢失。 重复读取：非缓冲性质函数移动了文件描述符的读指针，缓冲性质函数的缓冲区数据可能重复被读取。 3.2 示例说明 假设文件内容如下（每个字母代表一个字节）：\n1 abcdef 缓冲性质函数 rio_readnb 读取 4 个字节：\n内部缓冲区读取 abcd，并返回 abcd。 缓冲区现在可能还包含剩余的 ef。 接着调用非缓冲性质函数 rio_readn 读取 2 个字节：\n直接从文件描述符当前位置（即 ef）读取。 返回 ef。 再次调用 rio_readnb 读取 2 个字节：\n缓冲区已失效或被跳过，因为 rio_readn 直接从文件描述符读取，缓冲区未更新。 可能导致数据不一致或错误读取。 3.3 正确的使用方法 为了避免上述问题，应该遵循以下原则：\n保持一致性：在处理同一文件描述符时，要么始终使用缓冲性质函数，要么始终使用非缓冲性质函数。 避免交替使用：不要在同一文件描述符上交替使用这两种类型的函数，以确保数据读取的准确性和一致性。 结论 缓冲性质函数和非缓冲性质函数在处理文件描述符时的内部机制不同，交替使用可能导致数据不一致和错误。因此，在编写系统 I/O 操作时，应注意选择一致的函数类型，以确保数据读取的正确性和程序的稳定性。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%BC%93%E5%86%B2%E6%80%A7%E8%B4%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%9E%E7%BC%93%E5%86%B2%E6%80%A7%E8%B4%A8%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E4%BA%A4%E6%9B%BF%E4%BD%BF%E7%94%A8/","summary":"在系统编程中，尤其是文件 I/O 操作中，我们经常需要处理大量数据的读取和写入。为了提高效率，常常使用缓冲机制。本文将详细探讨缓冲性质函数和非缓冲性","title":"缓冲性质函数与非缓冲性质函数：为何不能交替使用"},{"content":"\rUbuntu 系统快照是一种用于捕捉和保存系统当前状态的技术。这种技术允许用户在将来某个时间点恢复到快照创建时的系统状态。这对于备份、系统更新前的保护、故障恢复以及测试环境的创建非常有用。\n一、系统快照定义 系统快照是操作系统在某个特定时间点上的完整状态，包括所有文件、配置和当前运行状态的副本。通过快照技术，可以快速地恢复系统到之前的某个状态。\n二、原理 系统快照的原理是基于写时复制（Copy-On-Write, COW）技术。当创建一个快照时，系统不会立即复制整个文件系统的数据，而是记录当前所有数据的元数据。只有在数据发生变化时，系统才会将变更部分的数据写入一个新的位置，并更新元数据指向新位置。这种方法节省了大量的存储空间和时间。\n三、实现方式 在 Ubuntu 中，实现系统快照的常见方法有以下几种：\n3.1 使用 LVM（Logical Volume Manager） LVM 提供了逻辑卷管理功能，允许创建卷组、逻辑卷和快照。\n（1）创建快照\n1 lvcreate --size 1G --snapshot --name snap /dev/vg0/lv0 --size：指定快照卷的大小。 --snapshot：指示创建快照。 --name：指定快照卷的名称。 /dev/vg0/lv0：原始逻辑卷的路径。 （2）恢复快照：\n1 lvconvert --merge /dev/vg0/snap --merge：将快照恢复到原始逻辑卷。 3.2 使用 Btrfs 文件系统 Btrfs 是一种现代的 CoW 文件系统，内置了快照功能。\n（1）创建快照：\n1 btrfs subvolume snapshot /path/to/source /path/to/snapshot /path/to/source：源子卷的路径。 /path/to/snapshot：快照的存储路径。 （2）恢复快照：\n1 2 btrfs subvolume delete /path/to/source btrfs subvolume snapshot /path/to/snapshot /path/to/source delete：删除源子卷。 snapshot：从快照创建新的子卷。 3.3 使用 Timeshift Timeshift 是一个专门用于桌面系统的快照工具，提供了图形用户界面（GUI）和命令行界面（CLI）。\n（1）安装 Timeshift：\n1 sudo apt install timeshift （2）创建快照：\n1 sudo timeshift --create --comments \u0026#34;My first snapshot\u0026#34; （3）恢复快照：\n1 sudo timeshift --restore --snapshot \u0026#34;My first snapshot\u0026#34; 四、应用场景 系统备份与恢复：\n在进行系统更新、安装新软件或进行重大配置更改之前创建快照，以便在出现问题时能够快速恢复系统。 测试环境：\n开发人员可以创建系统快照，以便在测试新功能或应用时，能够快速恢复到初始状态，节省重新配置环境的时间。 灾难恢复：\n快照技术可以用于灾难恢复，在系统遭受故障或数据损坏时，能够快速恢复到稳定状态。 虚拟化环境：\n在虚拟化环境中，快照可以用于保存虚拟机的状态，便于在虚拟机出问题时进行快速恢复。 五、优点与局限性 5.1 优点： 快速恢复：可以在几分钟内将系统恢复到之前的状态。 节省空间：通过 CoW 技术，仅保存变更的数据，节省存储空间。 自动化：可以设置定期快照，自动化备份过程。 5.2 局限性： 快照大小限制：快照卷的大小可能受到原始卷的限制，特别是在 LVM 中。 性能影响：频繁创建和恢复快照可能会对系统性能产生影响。 数据一致性：在系统繁忙时创建快照，可能会导致数据不一致，需要确保快照时的数据一致性。 总结 Ubuntu 系统快照是维护系统稳定性和数据安全性的重要工具，通过捕捉系统的当前状态，用户可以在需要时快速恢复到之前的状态。\n","permalink":"https://oheyu.github.io/zh/posts/tech/ubuntu%E7%B3%BB%E7%BB%9F%E5%BF%AB%E7%85%A7%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E7%8E%A9%E6%84%8F%E5%84%BF/","summary":"Ubuntu 系统快照是一种用于捕捉和保存系统当前状态的技术。这种技术允许用户在将来某个时间点恢复到快照创建时的系统状态。这对于备份、系统更新前的保护、","title":"Ubuntu系统快照是个什么玩意儿"},{"content":"\r在 Vim 中，我们可以使用重复上一次输入内容的命令来提高编辑效率。以下是几种常用的方法：\n一. 使用 . 命令 . 命令是 Vim 中最常用的重复命令。它可以重复上一次的普通模式命令。例如，如果在普通模式下删除了一个单词（dw），我们可以按 . 来重复这个操作。\n二. 使用 @: 命令 @: 命令可以重复上一次的命令行模式命令。例如，如果在命令行模式下输入了 :s/foo/bar/ 进行替换，我们可以按 @: 来重复这个替换操作。\n三. 使用 q 和 @ 命令记录和播放宏 我们也可以使用 q 命令开始录制宏，然后使用 @ 命令来播放宏，重复执行录制的命令序列，以下是详细步骤：\n录制宏：\n按 q 开始录制宏，后跟一个寄存器名（例如 a），即 qa。 执行你想录制的命令序列。 按 q 结束录制。 播放宏：\n按 @a 播放存储在寄存器 a 中的宏。 以重复删除某个单词为例：\n1 2 3 4 qa \u0026#34; 开始录制宏，寄存器名为 a dw \u0026#34; 删除一个单词 q \u0026#34; 结束录制 @a \u0026#34; 播放寄存器 a 中的宏 四. 使用 @@ 命令 @@ 命令可以重复上一次的宏。例如，如果我们刚刚使用了 @a 播放了宏，你可以按 @@ 来再次播放该宏。\n总结 在 Vim 中，有多种方法可以重复上一次的输入内容：\n使用 . 来重复上一次的普通模式命令。 使用 @: 来重复上一次的命令行模式命令。 使用宏（q 和 @）来录制和重复复杂的命令序列。 使用 @@ 来重复上一次播放的宏。 ","permalink":"https://oheyu.github.io/zh/posts/tech/vim%E9%87%8D%E5%A4%8D%E4%B8%8A%E4%B8%80%E6%AC%A1%E5%91%BD%E4%BB%A4/","summary":"在 Vim 中，我们可以使用重复上一次输入内容的命令来提高编辑效率。以下是几种常用的方法： 一. 使用 . 命令 . 命令是 Vim 中最常用的重复命令。它可以重复上一","title":"Vim重复上一次命令"},{"content":"\r梯度下降是一种核心优化算法，广泛应用于机器学习、深度学习和强化学习中。本文将详细介绍这三者的关系，以及梯度下降在这些领域中的具体应用和实现方式。\n一、机器学习、深度学习和强化学习的关系 1.1 机器学习（Machine Learning, ML） 机器学习是人工智能的一个分支，致力于开发算法和技术，使计算机能够从数据中学习和做出预测或决策，而无需明确的编程指令。其主要类别有：\n监督学习（Supervised Learning）：算法从标记数据中学习，进行分类和回归任务。 无监督学习（Unsupervised Learning）：算法从未标记数据中学习，进行聚类和降维任务。 半监督学习（Semi-supervised Learning）：结合少量标记数据和大量未标记数据进行学习。 强化学习（Reinforcement Learning）：算法通过与环境的互动，从奖励和惩罚中学习最佳策略。 1.2 深度学习（Deep Learning, DL） 深度学习是机器学习的一个子领域，使用多层神经网络（即深度神经网络）来学习复杂数据的表示和模式。其主要特点为：\n层次结构：通过多个隐藏层来提取数据的特征。 自动特征提取：无需人工设计特征，网络能够自动学习数据的表示。 大规模数据处理：适用于处理大量数据，如图像、语音和自然语言处理。 目前而言，最常见架构有两种：\n卷积神经网络（Convolutional Neural Networks, CNNs）：主要用于图像处理。 循环神经网络（Recurrent Neural Networks, RNNs）：主要用于处理序列数据。 1.3 强化学习（Reinforcement Learning, RL） 强化学习是机器学习的一个方法，通过智能体与环境的交互，从反馈信号（奖励或惩罚）中学习最佳行为策略，以最大化累积奖励。其主要特点：\n探索与利用：智能体需要在探索新策略和利用已知最佳策略之间进行平衡。 延迟奖励：动作的效果可能不是立即显现，而是经过一段时间后才表现出来。 策略学习：学习的是一个策略（policy），即在不同状态下采取不同动作的规则。 二、梯度下降在机器学习中的应用 在传统的机器学习中，梯度下降主要用于优化线性回归、逻辑回归和支持向量机等模型的参数。\n2.1 线性回归 线性回归旨在找到一条最佳拟合线来预测目标变量。目标是最小化损失函数（如均方误差）。梯度下降用于更新模型的权重，以逐渐逼近最优解。一般的，线性回归的损失函数可定义为如下形式：\n$$ J(\\theta) = \\frac{1}{2m} \\sum_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)})^2， $$\n梯度更新公式则为：\n$$ \\theta := \\theta - \\eta \\frac{1}{m} \\sum_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)}。 $$\n2.2 逻辑回归 逻辑回归用于分类任务，目标是最大化对数似然函数。梯度下降用于优化模型参数，使得模型能够更准确地进行分类。一般的，逻辑回归的损失函数（以交叉熵损失函数为例）可定义为如下形式：\n$$ J(\\theta) = -\\frac{1}{m} \\sum_{i=1}^{m} [y^{(i)} \\log(h_\\theta(x^{(i)})) + (1 - y^{(i)}) \\log(1 - h_\\theta(x^{(i)}))]， $$\n梯度更新公式则为：\n$$ \\theta := \\theta - \\eta \\frac{1}{m} \\sum_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)}。 $$\n三、梯度下降在深度学习中的应用 在深度学习中，梯度下降通过反向传播算法（backpropagation）来更新神经网络的权重和偏置。深度学习中的梯度下降有多种变体，如随机梯度下降（SGD）、动量梯度下降（Momentum）、自适应学习率方法（如Adam、RMSprop等）。\n3.1 反向传播（Backpropagation） 反向传播是一种计算梯度的高效算法，通过链式法则逐层计算损失函数对每个参数的梯度。其一般步骤为：\n前向传播：计算网络的输出，并根据目标计算损失。 反向传播：从输出层开始，逐层计算损失函数对各层参数的梯度。 参数更新：使用梯度下降算法更新每层的权重和偏置。梯度更新公式为 $\\theta := \\theta - \\eta \\nabla_\\theta J(\\theta)$。 3.2 优化算法 SGD（随机梯度下降）：每次更新只使用一个训练样本的梯度。 Momentum（动量）：在更新中加入前几次梯度的动量项，加速收敛并减小震荡。 $v_t = \\beta v_{t-1} + (1 - \\beta) \\nabla_\\theta J(\\theta)$ $\\theta := \\theta - \\eta v_t$ Adam：结合动量和自适应学习率的优化算法。 $m_t = \\beta_1 m_{t-1} + (1 - \\beta_1) \\nabla_\\theta J(\\theta)$ $v_t = \\beta_2 v_{t-1} + (1 - \\beta_2) (\\nabla_\\theta J(\\theta))^2$ $\\hat{m}_t = \\frac{m_t}{1 - \\beta_1^t}$ $\\hat{v}_t = \\frac{v_t}{1 - \\beta_2^t}$ $\\theta := \\theta - \\eta \\frac{\\hat{m}_t}{\\sqrt{\\hat{v}_t} + \\epsilon}$ 四、梯度下降在强化学习中的应用 在强化学习中，梯度下降主要用于策略优化和价值函数逼近。具体应用包括策略梯度方法和深度强化学习。\n4.1 策略梯度方法（Policy Gradient Methods） 策略梯度方法直接优化策略，通过最大化预期累积奖励来更新策略参数。这里有个策略梯度定理（放在这里，供了解）：\n$$ \\nabla_\\theta J(\\theta) = \\mathbb{E}{\\tau \\sim \\pi\\theta} \\left[ \\sum_{t=0}^{T} \\nabla_\\theta \\log \\pi_\\theta(a_t|s_t) R(\\tau) \\right] $$\n以及 REINFORCE 算法：\n$$ \\theta := \\theta + \\eta \\sum_{t=0}^{T} \\nabla_\\theta \\log \\pi_\\theta(a_t|s_t) R_t $$\n4.2 价值函数逼近（Value Function Approximation） 使用函数逼近方法（如神经网络）来估计价值函数或动作价值函数，通过梯度下降优化这些函数逼近的参数。主要代表是深度 Q 网络（DQN）：\n$$ L(\\theta) = \\mathbb{E}{(s, a, r, s\u0026rsquo;)} \\left[ \\left( r + \\gamma \\max{a\u0026rsquo;} Q(s\u0026rsquo;, a\u0026rsquo;; \\theta^-) - Q(s, a; \\theta) \\right)^2 \\right] $$\n这里，梯度下降用于最小化这个损失函数，从而更新 Q 网络的参数：\n$$ \\theta := \\theta - \\eta \\nabla_\\theta L(\\theta) $$\n4.3 Actor-Critic 方法 Actor-Critic 方法结合了策略梯度和价值函数逼近，将策略（Actor）和价值函数（Critic）分开学习。Actor 使用策略梯度方法更新策略参数：\n$$ \\theta_{\\pi} := \\theta_{\\pi} + \\eta \\nabla_\\theta \\log \\pi_\\theta(a|s) \\delta $$\n而 Critic 则使用 TD 方法或其他价值函数逼近方法更新价值函数参数：\n$$ \\theta_{V} := \\theta_{V} + \\beta \\delta \\nabla_\\theta V(s) $$\n总结 机器学习：梯度下降用于优化传统机器学习模型的参数，如线性回归和逻辑回归。 深度学习：梯度下降通过反向传播优化深层神经网络的权重和偏置，常用的变体包括 SGD、Momentum 和Adam 等。 强化学习：梯度下降用于策略优化和价值函数逼近，通过策略梯度、深度 Q 网络和 Actor-Critic 方法等实现。 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","summary":"梯度下降是一种核心优化算法，广泛应用于机器学习、深度学习和强化学习中。本文将详细介绍这三者的关系，以及梯度下降在这些领域中的具体应用和实现方","title":"理解梯度下降在机器学习、深度学习和强化学习中的应用"},{"content":"\r在机器学习和深度学习中，梯度下降是一种广泛使用的优化算法，用于最小化模型的损失函数，从而优化模型参数。梯度下降的三种主要变体是批量梯度下降、随机梯度下降和小批量梯度下降。本文将详细介绍这三种方法的定义、优缺点，以及它们在损失函数（准确度）曲线上的整体表现。\n一、批量梯度下降（Batch Gradient Descent） 1.1 定义 批量梯度下降（Batch Gradient Descent）在每次迭代时，使用整个训练集计算损失函数的梯度，并基于这个梯度来更新模型参数。损失函数 $J(\\theta)$ 通常是所有样本损失的平均值。例如，如果训练集中有 $N$ 个样本，则损失函数可以表示为：\n$$ J(\\theta) = \\frac{1}{N} \\sum_{i=1}^{N} L(f(x^{(i)}; \\theta), y^{(i)})。 $$\n其中，$f(x^{(i)}; \\theta)$ 是模型的预测，$y^{(i)}$ 是第 $i$ 个样本的真实标签，$L$ 是损失函数（例如均方误差或交叉熵损失）。每次迭代的参数更新公式为：\n$$ \\theta := \\theta - \\eta \\cdot \\nabla_\\theta J(\\theta)。 $$\n1.2优点 稳定性高：每次参数更新使用整个训练集的梯度，梯度估计准确，更新稳定。 收敛性好：更容易接近全局最优解。 1.3 缺点 计算成本高：每次迭代都需要计算整个训练集的梯度，尤其对于大型数据集，计算成本非常高。 内存消耗大：需要在内存中存储整个训练集，内存消耗大。 二、随机梯度下降（Stochastic Gradient Descent, SGD） 2.1定义 随机梯度下降在每次迭代时，仅使用一个样本计算损失函数的梯度，并基于这个梯度来更新模型参数。损失函数 $J(\\theta; x^{(i)}, y^{(i)})$ 是第 $i$ 个样本的损失函数。每次迭代的参数更新公式为：\n$$ \\theta := \\theta - \\eta \\cdot \\nabla_\\theta J(\\theta; x^{(i)}, y^{(i)}) $$\n2.2优点 计算成本低：每次迭代只需计算一个样本的梯度，计算成本低。 快速更新：由于每次迭代计算量小，参数更新频繁，初期收敛速度快。 2.3 缺点 梯度估计噪声大：每次更新的梯度波动大，导致优化路径不稳定。 收敛性差：容易在局部最优解附近震荡，难以收敛到全局最优解。 三、小批量梯度下降（Mini-batch Gradient Descent） 3.1 定义 小批量梯度下降是批量梯度下降和随机梯度下降的折中方案。每次迭代时，使用一个小批量样本（mini-batch）计算梯度，并基于这个梯度来更新模型参数。损失函数 $J(\\theta; B)$ 是一个小批量 $B$ 样本的平均损失。每次迭代的参数更新公式为：\n$$ \\theta := \\theta - \\eta \\cdot \\nabla_\\theta J(\\theta; B) $$\n3.2 优点 计算效率高：相比批量梯度下降，每次迭代计算的小批量样本梯度减少了计算成本。 收敛速度快：相比随机梯度下降，更新更加稳定，减少了震荡。 硬件效率：可以利用 GPU 加速计算，提高计算效率。 3.3 缺点 需要调参：需要选择合适的小批量大小，影响性能。 复杂度增加：相对于随机梯度下降和批量梯度下降，算法实现复杂度增加。 四、三者之间的联系与区别 4.1 联系 目标一致：三种方法都旨在通过梯度下降优化损失函数，以找到模型参数的最优值。 基本原理相同：三种方法的核心都是基于梯度下降，即使用损失函数的梯度来更新模型参数。 4.2 区别 数据使用方式： 批量梯度下降：使用整个训练集计算梯度。 随机梯度下降：每次迭代只使用一个样本计算梯度。 小批量梯度下降：每次迭代使用一个小批量样本计算梯度。 计算成本： 批量梯度下降：计算成本最高，因为每次迭代计算整个训练集的梯度。 随机梯度下降：计算成本最低，因为每次迭代只计算一个样本的梯度。 小批量梯度下降：计算成本介于两者之间。 收敛速度与稳定性： 批量梯度下降：更新稳定，收敛速度较慢。 随机梯度下降：初期收敛速度快，但更新不稳定，容易震荡。 小批量梯度下降：折中了两者的优点，更新较稳定，收敛速度较快。 内存消耗： 批量梯度下降：需要在内存中存储整个训练集。 随机梯度下降：内存消耗最小，只需存储一个样本。 小批量梯度下降：内存消耗介于两者之间，只需存储一个小批量样本。 五、反映在损失函数曲线和准确度曲线上的表现 5.1 批量梯度下降 损失函数曲线：曲线平滑，稳步下降，趋向于全局最优解。 准确度曲线：曲线平滑，准确度稳步上升，最终趋于收敛。 5.2 随机梯度下降 损失函数曲线：曲线波动大，总体趋势下降，但存在震荡和噪声。 准确度曲线：曲线波动大，总体上升，但有时会明显下降。 5.3 小批量梯度下降 损失函数曲线：曲线相对平滑，但有一些波动，介于批量和随机之间。 准确度曲线：曲线相对平稳，但有一些波动，总体上升。 总结 批量梯度下降、随机梯度下降和小批量梯度下降是机器学习和深度学习中常见的优化算法。它们在计算成本、收敛速度和更新稳定性上各有优缺点。相比较批量梯度下降与随机梯度下降，小批量梯度下降通过结合两者的优点，广泛应用于实际深度学习任务中。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%90%86%E8%A7%A3%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%89%B9%E9%87%8F%E9%9A%8F%E6%9C%BA%E4%B8%8E%E5%B0%8F%E6%89%B9%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94/","summary":"在机器学习和深度学习中，梯度下降是一种广泛使用的优化算法，用于最小化模型的损失函数，从而优化模型参数。梯度下降的三种主要变体是批量梯度下降、","title":"理解梯度下降：批量、随机与小批量的对比"},{"content":"\r在 Vim 的普通模式下，我们可以将光标放在括号内的任意位置输入如下命令快速删除括号（圆括号()、方括号[]、花括号{}）里的内容：\ndi(：删除当前括号对内的内容（但不删除括号本身）。其中，d 是删除命令，i( 表示括号 () 内的内容（i 表示 “inner”，内层）。 da(：删除当前括号对以及括号内的内容。其中，d 是删除命令，a( 表示括号 () 内的内容（a 表示 “around”，包括括号本身）。 对于方括号 [] 、花括号 {} 以及其他配对符号，如\u0026quot;\u0026quot;、''、\u0026lt;\u0026gt;等，使用方法与前述类似。 此外，在 Vim 的普通模式下，可以使用 vi* 或 va* 选择括号内的内容，并进入可视模式。\n","permalink":"https://oheyu.github.io/zh/posts/tech/vim%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%A0%E9%99%A4%E6%8B%AC%E5%8F%B7%E9%87%8C%E7%9A%84%E5%86%85%E5%AE%B9/","summary":"在 Vim 的普通模式下，我们可以将光标放在括号内的任意位置输入如下命令快速删除括号（圆括号()、方括号[]、花括号{}）里的内容： di(：删除当前","title":"Vim如何快速删除括号里的内容"},{"content":"\r大端序（Big-endian） 数据的高字节存储在低地址，低字节存储在高地址。即，大端序是从“最高有效字节（Most Significant Byte, MSB）”到“最低有效字节（Least Significant Byte, LSB）”按序排列的。\n小端序（Little-endian） 数据的低字节存储在低地址，高字节存储在高地址。即，小端序是从“最低有效字节”到“最高有效字节”按序排列的。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%AB%AF%E5%BA%8F/","summary":"大端序（Big-endian） 数据的高字节存储在低地址，低字节存储在高地址。即，大端序是从“最高有效字节（Most Significant Byte, MSB）”到“最低有效","title":"大端序与小端序"},{"content":"\r结构体（Struct） 结构体是一种用户定义的数据类型，允许将不同类型的变量组合在一起作为一个单一的实体进行处理。结构体常用于组织和管理不同类型的数据，使代码更具可读性和可维护性。结构体有如下三个关键特性：\n成员独立：结构体中的每个成员都有自己的内存空间，不同成员之间互不干扰；\n顺序存储：结构体中的成员按照声明的顺序依次存储在内存中，但可能存在字节填充（padding）以满足对齐要求；\n类型混合：结构体中可以包含不同类型的数据成员，例如整型、浮点型和字符数组等。\n以下是一个简短的代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; struct Person { char name[50]; int age; float height; }; int main() { Person person = {\u0026#34;Alice\u0026#34;, 30, 1.75}; std::cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; person.name \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; person.age \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Height: \u0026#34; \u0026lt;\u0026lt; person.height \u0026lt;\u0026lt; std::endl; return 0; } 联合体（Union） 同样的，联合体也是一种用户自定义的数据类型，允许将多个不同类型的变量存储在同一个内存位置。它常用于节省内存，尤其在需要处理多种数据类型但某一时刻只会使用其中一种的情况下。联合体有如下三个关键特性：\n共享内存：联合体中的所有成员共享同一块内存，某一时刻只能有一个成员是有效的；\n节省空间：联合体的大小等于其最大成员的大小；\n类型混合：同样可以包含不同类型的数据成员，但某一时刻只能使用某一个成员变量。\n以下是一个简短的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; union Data { int intValue; float flaotValue; char charValue; }; int main() { Data data; data.intValue = 10; std::cout \u0026lt;\u0026lt; \u0026#34;Integer: \u0026#34; \u0026lt;\u0026lt; data.intValue \u0026lt;\u0026lt; std::endl; data.floatValue = 3.14; std::cout \u0026lt;\u0026lt; \u0026#34;Float: \u0026#34; \u0026lt;\u0026lt; data.floatValue \u0026lt;\u0026lt; std::endl; data.charValue = \u0026#39;A\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Char: \u0026#34; \u0026lt;\u0026lt; data.charValue \u0026lt;\u0026lt; std::endl; return 0; } 结构体与联合体的对比分析 结构体 联合体 内存管理 每个成员都有独立的内存空间 所有成员共享同一内存空间 大小 所有成员大小之和（加上可能的填充字节） 最大成员的大小 数据有效性 结构体变量有效期中，所有成员始终有效 某一时刻，只能有一个成员有效 用途 数据记录、函数返回多个值 嵌入式系统节省内存、硬件寄存器访问 ","permalink":"https://oheyu.github.io/zh/posts/tech/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E8%81%94%E5%90%88%E4%BD%93/","summary":"结构体（Struct） 结构体是一种用户定义的数据类型，允许将不同类型的变量组合在一起作为一个单一的实体进行处理。结构体常用于组织和管理不同类","title":"结构体与联合体"},{"content":"\r解释型语言 解释型语言是被解释器逐行解释和执行源代码的语言。这意味着程序代码在运行时将被直接翻译为机器代码并执行。\n解释型语言有以下三个优点以及一个缺点：\n即时执行：代码在运行时被逐行解释，没有预编译的过程； 跨平台：解释器有不同平台的发行版本，同样的代码可以在多个操作系统上被执行； 调试友好：由于代码是被逐行解释和执行，调试和测试过程相对简单，可以即时查看和修改代码的效果； 速度较慢：由于每次运行都需要解释代码，执行速度通常比编译型语言慢。 常见的解释型语言有：Python、JavaScript、Ruby等。\n编译型语言 编译型语言有以下特点：\n预编译：代码在运行前需要经过编译器完成编译，生成独立的可执行文件； 执行速度快：由于编译后的代码时机器代码，可以直接由硬件执行，运行速度通常比解释型语言快； 平台依赖性：编译后的可执行文件通常与特定的平台和操作系统绑定，跨平台需要重新编译源代码； 调试复杂：由于代码在编译前不能运行，调试过程复杂，需要依赖编译器提供的调试工具。 常见的编译型语言有：C、C++、Rust、Go等\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80/","summary":"解释型语言 解释型语言是被解释器逐行解释和执行源代码的语言。这意味着程序代码在运行时将被直接翻译为机器代码并执行。 解释型语言有以下三个优点以及","title":"解释型语言与编译型语言"},{"content":"\r在C、C++语言中，将源代码文件转换成可执行文件涉及多个步骤，主要包括预处理、编译、汇编和链接。\n源代码（Source code）文件 源代码文件包含了一系列人类可读的计算机语言指令。在 C 语言规范中，源代码文件通常以 .c 为拓展名；而在 C++ 语言规范中，源代码文件通常以 .cpp 为拓展名。\n预处理（Preprocessing） 预处理是编译过程的第一步。在这个过程中，预处理器处理源代码文件中以 # 开头的指令。这些指令包括头文件 #include、宏定义 #define 替换、条件编译 #ifdef 等。预处理的结果是一个 “拓展源代码” 文件，通常以 .i 为拓展名。具体来说，“拓展源代码” 是在原始源代码的基础上，展开所有的宏，插入所有头文件的内容，处理所有的条件编译。\n假设有如下的C++源代码文件 “main.cpp” ：\n1 2 3 4 5 6 7 8 // main.cpp #include \u0026lt;iostream\u0026gt; #define PI 3.1415926 int main() { std::cout \u0026lt;\u0026lt; \u0026#34;PI value is \u0026#34; \u0026lt;\u0026lt; PI \u0026lt;\u0026lt; std::endl; return 0; } 预处理后的代码将不包含 “#include” 和 “#define” 指令，而是包含了 “iostream” 的全部内容并替换 “PI” 的值：\n1 2 3 4 5 6 7 // main.i // iostream 内容展开 // 例如 std::ostream, std::cout等的定义 int main() { std::cout \u0026lt;\u0026lt; \u0026#34;PI value is \u0026#34; \u0026lt;\u0026lt; 3.1415926 \u0026lt;\u0026lt; std::endl; return 0; } 编译（Compilation） 编译器将预处理后的代码转换为目标平台的汇编语言。这一步涉及语法分析、语义分析与优化等。编译器输出的是汇编代码，通常以 .s 为拓展名，这些汇编指令是平台相关的，表示如何在特定的硬件上执行程序。编译后的汇编代码可能看起来像这样（以x86平台为例）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .section .rodata .LC0: .string \u0026#34;PI value is %f\\n\u0026#34; .text .globl main main: pushq %rbp movq %rsp, %rbp subq $16, %rsp movss $0x40490fdb, -4(%rbp) // PI value as float movq $LC0, %rdi leaq -4(%rbp), %rsi call printf movl $0, %eax leave ret 汇编（Assembly） 汇编器将汇编代码转换为机器代码，即二进制指令，这些指令可以由计算机的 CPU 直接执行。汇编器生成的是对象文件（Object file），通常以 .o（Unix/Linux系统）或 .obj（Windows系统）为拓展名。对象文件包含了编译后的代码的机器语言版本，但这些代码还未进行地址绑定。对象文件是二进制文件，通常不可读，但它包含了函数和数据的二进制表示。\n为什么汇编阶段不完成地址绑定? 在汇编阶段，代码被转换成机器可执行的指令。然而，指令中引用的函数和全局变量的具体内存地址通常尚未确定。这些引用被暂时标记为“待定”，直到链接阶段才会被解析和绑定。出现这种情况的原因如下：\n多模块程序：一个大型程序通常由多个源代码文件组成。经过 “预处理、编译、汇编” 这三个步骤后，每个源代码文件会被独立地转换成对象文件。在这个过程中，汇编器仅能处理当前模块中的符号（如函数、全局变量等），而无法得知其他模块中定义的符号的具体地址。因此，在汇编时，这些跨模块的引用会被标记为待定。 库连接：程序可能依赖于多个外部库，这些库在编译和汇编时也是被独立处理的。因此，库函数的具体内存地址在汇编阶段是未知的，汇编器无法将这些地址填入生成的指令中。这些库函数的地址同样会在链接阶段由链接器解析和绑定。 对于上述问题，汇编器和链接器通过重定位解决这一问题：\n重定位记录：汇编器生成的对象文件中包括机器指令和一些符号表，其中符号表记录了未解析的符号及其引用位置。对于同一模块内定义和使用的符号（例如局部变量），汇编器可以直接将地址填入机器指令中；而对于跨模块引用的符号（例如其他源文件或库中的函数和全局变量），汇编器会生成 “重定位表”，标记这些符号为未解析，并记录它们在目标文件中的位置。 链接：在链接阶段，链接器将所有对象文件和库文件合并成一个可执行文件。链接器首先扫描所有目标文件的符号表，构建全局符号表（Global Symbol Table），该表包含了所有模块中定义的符号及其相对地址。接着，链接器通过重定位表，将未解析的符号地址替换为它们在最终可执行文件中的实际地址。链接器将所有模块的代码和数据段重定位到最终的内存地址空间中，这样每个符号都能正确地被引用。 链接（Linking） 链接器处理一个或多个对象文件，解决外部符号引用，可能还会链接运行时库等。链接器将所有对象文件及所需的库文件集合在一起，生成最终的可执行文件（在Windows上是 .exe，在Unix/Linux上通常没有扩展名）。链接器生成的可执行文件包含了所有必要的程序代码、数据和运行时库的引用，这些都已经是准备好可以被操作系统加载和执行的格式。最终的可执行文件实现了特定平台上的 “一次编译，多次运行”。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/","summary":"在C、C++语言中，将源代码文件转换成可执行文件涉及多个步骤，主要包括预处理、编译、汇编和链接。 源代码（Source code）文件 源代码文件","title":"源文件到可执行文件的过程"},{"content":"\r在 C++ 编程中，指针是一种非常强大的工具，它允许开发者直接操作内存地址。当处理简单的数据时，一级指针已经能够满足大部分需求，但在更复杂的场景中，比如动态内存管理、处理多维数组、以及函数参数的间接操作时，二级指针（指向指针的指针）则能提供更大的灵活性和功能。\n一、什么是二级指针？ 1.1 概念简介 二级指针（Double Pointer）是指向另一个指针的指针。简而言之，一级指针存储的是某个变量的地址，而二级指针存储的是一级指针的地址。这种多级指针间接性在动态内存管理和处理复杂数据结构时非常有用。\n在 C++ 中，二级指针的声明如下：\n1 int** ptr; 在这个例子中，ptr 是一个指向指向 int 类型变量的指针的指针。它的类型是 int**。\n1.2 二级指针的内存布局 为了理解二级指针，我们可以将其分为三层内存结构：\n第一层：实际数据的存储位置（例如 int 类型的整数）。 第二层：一级指针，存储第一层数据的地址。 第三层：二级指针，存储一级指针的地址。 1 2 3 int value = 42; // 第一层：存储数据 int* ptr = \u0026amp;value; // 第二层：指向 value 的指针 int** pptr = \u0026amp;ptr; // 第三层：指向 ptr 的指针 二、二级指针的使用 2.1 二级指针的基本操作 通过二级指针可以间接地访问或修改底层的数据。以下是一个简单的示例，展示了如何通过二级指针访问和修改原始数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; int main() { int value = 42; // 第一层：实际数据 int* ptr = \u0026amp;value; // 第二层：一级指针，指向 value int** pptr = \u0026amp;ptr; // 第三层：二级指针，指向 ptr std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Value via ptr: \u0026#34; \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Value via pptr: \u0026#34; \u0026lt;\u0026lt; **pptr \u0026lt;\u0026lt; std::endl; // 通过二级指针访问数据 **pptr = 100; // 修改数据 std::cout \u0026lt;\u0026lt; \u0026#34;Modified Value via pptr: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; // 检查修改结果 return 0; } 输出结果：\n1 2 3 4 Value: 42 Value via ptr: 42 Value via pptr: 42 Modified Value via pptr: 100 在这个例子中，通过二级指针 pptr，我们可以间接修改 value 的值。\n三、二级指针的应用场景 3.1 动态分配二维数组 在 C++ 中，二维数组通常用于表示矩阵等结构。使用二级指针可以动态分配二维数组的内存，并进行访问操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; int main() { int rows = 3, cols = 4; // 动态分配二维数组 int** matrix = new int*[rows]; for (int i = 0; i \u0026lt; rows; i++) { matrix[i] = new int[cols]; } // 初始化并打印二维数组 for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { matrix[i][j] = i * cols + j; std::cout \u0026lt;\u0026lt; matrix[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; } // 释放二维数组内存 for (int i = 0; i \u0026lt; rows; i++) { delete[] matrix[i]; } delete[] matrix; return 0; } 在此例中，matrix 是一个指向指针的数组，它指向多个一维数组，从而构成了二维数组结构。二级指针可以有效管理这种动态分配的二维数组。\n3.2 修改函数中的指针 在需要在函数内部修改指针值的场景中，二级指针非常有用。例如，当需要在函数中分配内存并将结果传递回主函数时，可以使用二级指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; void allocateMemory(int** ptr) { *ptr = new int(100); // 为一级指针分配内存 } int main() { int* ptr = nullptr; allocateMemory(\u0026amp;ptr); // 将指向 ptr 的地址传递给函数 std::cout \u0026lt;\u0026lt; \u0026#34;Allocated Value: \u0026#34; \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; std::endl; delete ptr; // 释放分配的内存 return 0; } 在这个例子中，函数 allocateMemory 使用二级指针来分配内存，并将分配的结果传递回主函数。\n3.3 数据结构的动态操作 二级指针在操作链表等复杂数据结构时非常有用，因为它可以直接修改指针的值，从而方便地插入或删除链表中的节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; struct Node { int data; Node* next; }; void insertAtHead(Node** head, int data) { Node* newNode = new Node(); newNode-\u0026gt;data = data; newNode-\u0026gt;next = *head; *head = newNode; } void printList(Node* head) { while (head != nullptr) { std::cout \u0026lt;\u0026lt; head-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34;; head = head-\u0026gt;next; } std::cout \u0026lt;\u0026lt; \u0026#34;nullptr\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { Node* head = nullptr; insertAtHead(\u0026amp;head, 10); insertAtHead(\u0026amp;head, 20); insertAtHead(\u0026amp;head, 30); printList(head); // 输出链表 // 释放链表内存 Node* temp; while (head != nullptr) { temp = head; head = head-\u0026gt;next; delete temp; } return 0; } 在这个例子中，insertAtHead 函数使用二级指针操作链表的头指针，使得我们可以在链表的开头插入节点。\n四、常见问题 4.1 内存泄漏 动态分配内存时，忘记释放内存会导致内存泄漏。特别是在处理二级指针时，必须确保在使用完二维数组或其他数据结构后，正确释放所有分配的内存。\n1 2 3 4 for (int i = 0; i \u0026lt; rows; i++) { delete[] matrix[i]; // 释放每个一维数组 } delete[] matrix; // 释放指针数组 4.2 悬空指针 当释放内存时，确保将指针置为 nullptr，以防止悬空指针的使用：\n1 2 delete[] matrix[i]; matrix[i] = nullptr; // 防止使用已释放的内存 4.3 二级指针的复杂性 虽然二级指针功能强大，但它们会增加代码的复杂性。尤其在多级指针嵌套时，容易引发混乱。为了提高代码的可读性，建议在设计复杂系统时使用智能指针（如 std::unique_ptr 和 std::shared_ptr）来自动管理内存。\n","permalink":"https://oheyu.github.io/zh/posts/tech/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/","summary":"在 C++ 编程中，指针是一种非常强大的工具，它允许开发者直接操作内存地址。当处理简单的数据时，一级指针已经能够满足大部分需求，但在更复杂的场景中，","title":"二级指针"}]