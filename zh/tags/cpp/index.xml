<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CPP on 史玉浩的个人博客</title>
    <link>https://oheyu.github.io/zh/tags/cpp/</link>
    <description>Recent content in CPP on 史玉浩的个人博客</description>
    <generator>Hugo -- 0.127.0</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 17 Aug 2023 19:46:48 +0800</lastBuildDate>
    <atom:link href="https://oheyu.github.io/zh/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CPP中的互斥锁：概念、实现与使用技巧</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E6%A6%82%E5%BF%B5%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 17 Aug 2023 19:46:48 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E6%A6%82%E5%BF%B5%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description>在并发编程中，互斥锁（Mutex）是保证多个线程或进程访问共享资源时数据一致性的重要同步机制。它通过限制同时访问某段代码的线程数，避免数据竞</description>
    </item>
    <item>
      <title>函数调用栈</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</link>
      <pubDate>Wed, 16 Aug 2023 19:29:32 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</guid>
      <description>在 C++ 编程中，函数调用栈是管理函数调用和返回的核心机制，它帮助程序高效管理函数的执行流程，包括参数传递、局部变量的存储和函数返回的控制。理解函</description>
    </item>
    <item>
      <title>CPP中共享内存的使用：为啥要避免string对象</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%BA%E5%95%A5%E8%A6%81%E9%81%BF%E5%85%8Dstring%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Tue, 15 Aug 2023 17:09:57 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%BA%E5%95%A5%E8%A6%81%E9%81%BF%E5%85%8Dstring%E5%AF%B9%E8%B1%A1/</guid>
      <description>在多进程编程中，共享内存是一种常用的进程间通信机制，允许多个进程访问同一块物理内存。这种方式不仅能够提高效率，还可以减少数据在进程间拷贝的开</description>
    </item>
    <item>
      <title>CPP中的仿函数（Functors）</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0functors/</link>
      <pubDate>Sun, 13 Aug 2023 16:59:30 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0functors/</guid>
      <description>在 C++ 编程中，仿函数（Function Objects, Functors）是一种强大的工具，它不仅可以像普通函数那样调用，还可以携带状态、使用类的继承和多态来</description>
    </item>
    <item>
      <title>CPP中结构体的内存管理：sizeof与memset的使用陷阱</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86sizeof%E4%B8%8Ememset%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1/</link>
      <pubDate>Fri, 11 Aug 2023 16:37:46 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86sizeof%E4%B8%8Ememset%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1/</guid>
      <description>在 C++ 编程中，结构体（struct）是一种常用的数据结构，尤其是在需要组织和管理多个相关数据时。然而，当结构体中包含指向动态分配内存的指针时，</description>
    </item>
    <item>
      <title>CPP中执行外部程序</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Tue, 08 Aug 2023 16:27:36 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</guid>
      <description>在 C++ 开发中，执行外部程序（如二进制文件、系统命令或 Shell 脚本）是一个常见的需求，尤其是在 Linux 系统中。C++ 提供了多种方式来实现这一功能，其中最常用</description>
    </item>
    <item>
      <title>全局变量与静态变量</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 07 Aug 2023 11:14:55 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</guid>
      <description>在 C++ 开发中，全局变量和静态变量的使用是一个常见且重要的话题。虽然它们有着各自独特的特性，但在实际项目中，合理运用这些变量可以帮助我们提高代码</description>
    </item>
    <item>
      <title>CPP内存模型</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 05 Aug 2023 10:37:41 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>内存，也就是我们常说的内存条，是计算机系统中至关重要的组成部分，它不仅用于存储程序的代码和数据，还负责数据的快速访问和处理。计算机内部以字节</description>
    </item>
    <item>
      <title>Free与malloc以及new与delete</title>
      <link>https://oheyu.github.io/zh/posts/tech/free%E4%B8%8Emalloc%E4%BB%A5%E5%8F%8Anew%E4%B8%8Edelete/</link>
      <pubDate>Sat, 05 Aug 2023 09:22:41 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/free%E4%B8%8Emalloc%E4%BB%A5%E5%8F%8Anew%E4%B8%8Edelete/</guid>
      <description>在 C/C++ 中，new/delete 与 malloc/free 的使用涉及内存分配和释放的机制，虽然它们的功能表面上类似，但在使用上存在许多本质上的区别，使用时务必配对使用</description>
    </item>
  </channel>
</rss>
