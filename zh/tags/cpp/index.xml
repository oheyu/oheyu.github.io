<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CPP on 史玉浩的个人博客</title>
    <link>https://oheyu.github.io/zh/tags/cpp/</link>
    <description>Recent content in CPP on 史玉浩的个人博客</description>
    <generator>Hugo -- 0.127.0</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 31 Aug 2023 21:42:05 +0800</lastBuildDate>
    <atom:link href="https://oheyu.github.io/zh/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CPP模板参数推导与显示指定的原理及应用场景</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC%E4%B8%8E%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Thu, 31 Aug 2023 21:42:05 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC%E4%B8%8E%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>C++ 的模板机制是其强大功能的核心之一，它允许编写通用的代码，并根据不同的类型进行实例化。然而，C++ 中的模板使用过程中，有时我们可以依赖编译器</description>
    </item>
    <item>
      <title>Return、exit、_exit以及_Exit</title>
      <link>https://oheyu.github.io/zh/posts/tech/returnexit_exit%E4%BB%A5%E5%8F%8A_exit/</link>
      <pubDate>Sun, 27 Aug 2023 21:20:55 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/returnexit_exit%E4%BB%A5%E5%8F%8A_exit/</guid>
      <description>在 C 和 C++ 编程中，return、exit()、_exit() 以及 _Exit() 都可以用于终止程序或函数的执行，但它们的行为、作用范围以及对资源的处理方式存</description>
    </item>
    <item>
      <title>CPP中的拷贝构造函数与赋值构造函数</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 23 Aug 2023 21:00:18 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid>
      <description>在 C++ 中，拷贝构造函数和赋值构造函数是管理对象复制行为的两个核心机制。它们的正确实现对于保障程序的健壮性与资源管理的正确性至关重要。 一、拷贝构</description>
    </item>
    <item>
      <title>静态库与动态库</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Wed, 23 Aug 2023 20:47:58 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>在 C++ 开发中，库文件是用于封装可重用代码的文件，帮助开发者在多个项目中共享和重用函数、类或数据结构。库文件主要分为两类：静态库（Static L</description>
    </item>
    <item>
      <title>CPP中的静态成员函数与普通成员函数</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 21 Aug 2023 20:25:34 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</guid>
      <description>在 C++ 面向对象编程中，类是封装数据和行为的核心概念。类的成员函数分为普通成员函数和静态成员函数两类，它们在访问方式、功能、以及使用场景上有着显</description>
    </item>
    <item>
      <title>CPP中的互斥锁：概念、实现与使用技巧</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E6%A6%82%E5%BF%B5%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 17 Aug 2023 19:46:48 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E6%A6%82%E5%BF%B5%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description>在并发编程中，互斥锁（Mutex）是保证多个线程或进程访问共享资源时数据一致性的重要同步机制。它通过限制同时访问某段代码的线程数，避免数据竞</description>
    </item>
    <item>
      <title>函数调用栈</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</link>
      <pubDate>Wed, 16 Aug 2023 19:29:32 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</guid>
      <description>在 C++ 编程中，函数调用栈是管理函数调用和返回的核心机制，它帮助程序高效管理函数的执行流程，包括参数传递、局部变量的存储和函数返回的控制。理解函</description>
    </item>
    <item>
      <title>CPP中共享内存的使用：为啥要避免string对象</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%BA%E5%95%A5%E8%A6%81%E9%81%BF%E5%85%8Dstring%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Tue, 15 Aug 2023 17:09:57 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%BA%E5%95%A5%E8%A6%81%E9%81%BF%E5%85%8Dstring%E5%AF%B9%E8%B1%A1/</guid>
      <description>在多进程编程中，共享内存是一种常用的进程间通信机制，允许多个进程访问同一块物理内存。这种方式不仅能够提高效率，还可以减少数据在进程间拷贝的开</description>
    </item>
    <item>
      <title>CPP中的仿函数（Functors）</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0functors/</link>
      <pubDate>Sun, 13 Aug 2023 16:59:30 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0functors/</guid>
      <description>在 C++ 编程中，仿函数（Function Objects, Functors）是一种强大的工具，它不仅可以像普通函数那样调用，还可以携带状态、使用类的继承和多态来</description>
    </item>
    <item>
      <title>CPP中结构体的内存管理：sizeof与memset的使用陷阱</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86sizeof%E4%B8%8Ememset%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1/</link>
      <pubDate>Fri, 11 Aug 2023 16:37:46 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86sizeof%E4%B8%8Ememset%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1/</guid>
      <description>在 C++ 编程中，结构体（struct）是一种常用的数据结构，尤其是在需要组织和管理多个相关数据时。然而，当结构体中包含指向动态分配内存的指针时，</description>
    </item>
    <item>
      <title>CPP中执行外部程序</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Tue, 08 Aug 2023 16:27:36 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</guid>
      <description>在 C++ 开发中，执行外部程序（如二进制文件、系统命令或 Shell 脚本）是一个常见的需求，尤其是在 Linux 系统中。C++ 提供了多种方式来实现这一功能，其中最常用</description>
    </item>
    <item>
      <title>全局变量与静态变量</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 07 Aug 2023 11:14:55 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</guid>
      <description>在 C++ 开发中，全局变量和静态变量的使用是一个常见且重要的话题。虽然它们有着各自独特的特性，但在实际项目中，合理运用这些变量可以帮助我们提高代码</description>
    </item>
    <item>
      <title>CPP内存模型</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 05 Aug 2023 10:37:41 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>内存，也就是我们常说的内存条，是计算机系统中至关重要的组成部分，它不仅用于存储程序的代码和数据，还负责数据的快速访问和处理。计算机内部以字节</description>
    </item>
    <item>
      <title>Free与malloc以及new与delete</title>
      <link>https://oheyu.github.io/zh/posts/tech/free%E4%B8%8Emalloc%E4%BB%A5%E5%8F%8Anew%E4%B8%8Edelete/</link>
      <pubDate>Sat, 05 Aug 2023 09:22:41 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/free%E4%B8%8Emalloc%E4%BB%A5%E5%8F%8Anew%E4%B8%8Edelete/</guid>
      <description>在 C/C++ 中，new/delete 与 malloc/free 的使用涉及内存分配和释放的机制，虽然它们的功能表面上类似，但在使用上存在许多本质上的区别，使用时务必配对使用</description>
    </item>
  </channel>
</rss>
