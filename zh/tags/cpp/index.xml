<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CPP on 史玉浩的个人博客</title>
    <link>https://oheyu.github.io/zh/tags/cpp/</link>
    <description>Recent content in CPP on 史玉浩的个人博客</description>
    <generator>Hugo -- 0.127.0</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 01 Sep 2024 10:37:23 +0800</lastBuildDate>
    <atom:link href="https://oheyu.github.io/zh/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Native_handle访问系统原生线程句柄</title>
      <link>https://oheyu.github.io/zh/posts/tech/native_handle%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%94%9F%E7%BA%BF%E7%A8%8B%E5%8F%A5%E6%9F%84/</link>
      <pubDate>Sun, 01 Sep 2024 10:37:23 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/native_handle%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%94%9F%E7%BA%BF%E7%A8%8B%E5%8F%A5%E6%9F%84/</guid>
      <description>C++11 为多线程编程提供了标准化的线程库，通过 std::thread 类封装了底层操作系统的线程库。然而，不同的操作系统具有各自的线程管理功能，有时我们需要直接访问这些</description>
    </item>
    <item>
      <title>CPP中的可调用对象</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 30 Aug 2024 15:25:18 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/</guid>
      <description>在 C++ 中，所有可以像函数一样被调用的实体，统称为可调用对象（Callable Objects）。这些对象不仅仅局限于普通函数，还包括类的静态成员</description>
    </item>
    <item>
      <title>CPP中的函数适配器</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8/</link>
      <pubDate>Sun, 25 Aug 2024 16:40:32 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8/</guid>
      <description>C++ 中，通用的函数适配器 std::bind 是一个强大而灵活的工具。它允许将可调用对象及其参数进行绑定，并生成一个新的可调用对象。在涉及回调机制、延迟函数执行、</description>
    </item>
    <item>
      <title>消息队列中的回调函数</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 21 Aug 2024 17:00:17 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid>
      <description>在异步编程中，回调函数是一种非常常见的设计模式，尤其是在消息队列或网络库中。它允许我们在接收到消息（或事件）时，调用预先注册的用户自定义处理</description>
    </item>
    <item>
      <title>CPP的虚函数及其替代品</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%9B%BF%E4%BB%A3%E5%93%81/</link>
      <pubDate>Sat, 17 Aug 2024 08:24:46 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%9B%BF%E4%BB%A3%E5%93%81/</guid>
      <description>对于 C++ 编程，多态是面向对象编程的核心特性之一。虚函数是实现多态性的主要工具，它允许通过基类指针或引用来调用派生类的成员函数，从而实现动态的行</description>
    </item>
    <item>
      <title>CPP中的原子类型</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 09 Aug 2024 20:59:01 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B/</guid>
      <description>在并发环境中，如何保证数据在多个线程之间的同步与一致性是一个关键问题。传统的同步方式使用互斥锁（mutex）来保护共享数据，但锁的使用带来了</description>
    </item>
    <item>
      <title>再探CPP中的互斥锁</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%86%8D%E6%8E%A2cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81/</link>
      <pubDate>Sat, 03 Aug 2024 10:49:56 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%86%8D%E6%8E%A2cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81/</guid>
      <description>很久之前，我就相关内容写了一篇博客。今日，重读相关内容，还是觉得自己要就相关内容，再写一篇。不为别的，权当加深印象之用吧。C++11 提供了标</description>
    </item>
    <item>
      <title>Call_once实现线程安全的单次执行</title>
      <link>https://oheyu.github.io/zh/posts/tech/call_once%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E6%AC%A1%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Wed, 31 Jul 2024 10:22:02 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/call_once%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E6%AC%A1%E6%89%A7%E8%A1%8C/</guid>
      <description>在多线程编程中，经常会遇到这样的需求：某些函数或操作只能被调用一次，特别是在初始化某些全局或共享资源时。C++11 提供了一个简洁的解决方案：</description>
    </item>
    <item>
      <title>This_thread</title>
      <link>https://oheyu.github.io/zh/posts/tech/this_thread/</link>
      <pubDate>Mon, 29 Jul 2024 09:59:30 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/this_thread/</guid>
      <description>在 C++11 中，为了更好地支持并发编程，标准库提供了命名空间 std::this_thread，它专门用于表示当前线程，并提供了一些常用的与线程管理相</description>
    </item>
    <item>
      <title>线程资源的回收</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Sat, 27 Jul 2024 09:50:25 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%9B%9E%E6%94%B6/</guid>
      <description>在 C++ 中，线程的使用为我们带来了多任务并发执行的能力，但与此同时，如何管理和回收线程资源也是一个不可忽视的问题。虽然一个进程的所有线程共享同一</description>
    </item>
    <item>
      <title>CPP11中的线程支持</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp11%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81/</link>
      <pubDate>Wed, 24 Jul 2024 09:33:07 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp11%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81/</guid>
      <description>在 C++11 之前，C++ 没有原生的线程支持，开发者需要依赖于操作系统提供的线程库，不同平台的实现各不相同，这导致了跨平台开发的复杂性。C++11 引入</description>
    </item>
    <item>
      <title>完美转发</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Fri, 17 Nov 2023 22:01:06 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</guid>
      <description>完美转发（Perfect Forwarding）是 C++11 一个重要的特性，允许函数模板将参数 完美地 转发给其它函数。这意味着不仅能够准确地传递参数的值</description>
    </item>
    <item>
      <title>移动语义</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</link>
      <pubDate>Sun, 12 Nov 2023 16:32:58 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</guid>
      <description>我们要知道，在 C++98 中，如果一个类包含 堆资源（例如动态分配的内存、文件句柄等），为了管理这些资源，需要手动编写 拷贝构造函数 和 赋值运算符，以实现 深</description>
    </item>
    <item>
      <title>左值、右值与引用</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8/</link>
      <pubDate>Sun, 12 Nov 2023 15:27:40 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8/</guid>
      <description>自上次撰写相关内容，我也算是有了一段实际的应用经验。现在，回头再次分析相关内容，有了更深的感悟。今儿个，我们再次探究一下左值、右值与引用等相</description>
    </item>
    <item>
      <title>Lambda表达式</title>
      <link>https://oheyu.github.io/zh/posts/tech/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sun, 12 Nov 2023 09:51:56 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>自 C++11 标准引入以来，Lambda 表达式（也称为匿名函数）已经成为现代 C++ 编程中不可或缺的一部分。它们提供了一种简洁而强大的方式来定义内联函数，特</description>
    </item>
    <item>
      <title>委托构造与继承构造</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0/</link>
      <pubDate>Fri, 10 Nov 2023 08:39:06 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0/</guid>
      <description>C++11 标准新增了两个重要的构造函数特性：委托构造 和 继承构造。这两个特性极大地简化了代码，减少了重复代码的编写，提升了代码的可读性和维护性。 一、委</description>
    </item>
    <item>
      <title>CPP11中的一些新标准</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp11%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E6%A0%87%E5%87%86/</link>
      <pubDate>Wed, 08 Nov 2023 07:46:30 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp11%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E6%A0%87%E5%87%86/</guid>
      <description>C++11 引入了许多新的特性，极大地提升了代码的安全性、可读性和性能。其中，final 和 override 关键字的引入为开发者提供了更强的控制与提示功能，而数值与字</description>
    </item>
    <item>
      <title>常引用与临时变量的自动创建</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%B8%B8%E5%BC%95%E7%94%A8%E4%B8%8E%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA/</link>
      <pubDate>Mon, 30 Oct 2023 10:41:50 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%B8%B8%E5%BC%95%E7%94%A8%E4%B8%8E%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA/</guid>
      <description>在 C++ 编程中，引用（References）是一个非常常用的特性，允许我们通过别名来引用已有的变量。通常情况下，引用要求引用的类型和实际变量类型</description>
    </item>
    <item>
      <title>RAII：资源获取即初始化</title>
      <link>https://oheyu.github.io/zh/posts/tech/raii%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Sat, 07 Oct 2023 10:07:35 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/raii%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>在 C++ 编程中，资源管理是一项至关重要的任务，尤其是在内存分配、文件操作、网络连接等与系统资源密切相关的场景中。RAII（Resource Acquisition Is I</description>
    </item>
    <item>
      <title>左值与右值</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/</link>
      <pubDate>Sun, 24 Sep 2023 16:55:52 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/</guid>
      <description>最近写代码，对左值（lvalue） 和 右值（rvalue） 两个概念感到有些拿不准，总结一下。 一、左值（lvalue）与右值（rvalue）的基</description>
    </item>
    <item>
      <title>Lock_guard与unique_lock</title>
      <link>https://oheyu.github.io/zh/posts/tech/lock_guard%E4%B8%8Eunique_lock/</link>
      <pubDate>Fri, 22 Sep 2023 16:44:33 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/lock_guard%E4%B8%8Eunique_lock/</guid>
      <description>在现代 C++ 多线程编程中，锁机制是确保线程安全访问共享资源的关键手段。C++ 标准库为开发者提供了多种锁管理工具，其中最常用的是 std::lock_guard 和 std::un</description>
    </item>
    <item>
      <title>CPP中的const与constexpr</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84const%E4%B8%8Econstexpr/</link>
      <pubDate>Wed, 20 Sep 2023 16:10:28 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84const%E4%B8%8Econstexpr/</guid>
      <description>在 C++ 中，const和constexpr是两个非常重要的关键字，它们的主要功能是保证变量和表达式在不同上下文中的不可修改性。然而，虽然这两个关</description>
    </item>
    <item>
      <title>Sizeof运算符</title>
      <link>https://oheyu.github.io/zh/posts/tech/sizeof%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Tue, 19 Sep 2023 16:00:43 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/sizeof%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>sizeof 运算符是一个极为常用且强大的工具。它能够在编译时计算任意数据类型或对象在内存中占用的字节数。 一、什么是 sizeof 运算符？ sizeof 是一个内置于 C++ 的运算符，</description>
    </item>
    <item>
      <title>CPP函数返回值的存储位置与优化策略</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</link>
      <pubDate>Sun, 17 Sep 2023 15:39:19 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</guid>
      <description>不论是那个编程语言，函数返回值是一个极其重要的概念，它不仅影响代码的逻辑，还直接关系到程序的性能。在不同的场景下，函数返回值的处理方式会对程</description>
    </item>
    <item>
      <title>CPP中的内联函数</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 13 Sep 2023 11:23:38 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</guid>
      <description>在C++编程中，内联函数（inline function）是一个强大的优化工具，它允许编译器将函数调用直接展开为内联代码，从而减少函数调用的开</description>
    </item>
    <item>
      <title>CPP智能指针初探</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Sun, 10 Sep 2023 11:17:32 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%9D%E6%8E%A2/</guid>
      <description>在 C++ 编程中，内存管理始终是一个关键问题，尤其是在手动管理动态分配内存时，容易引发内存泄漏、悬空指针等问题。为了解决这些问题，C++11 引入了</description>
    </item>
    <item>
      <title>冷不丁儿的内存就泄漏了</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%86%B7%E4%B8%8D%E4%B8%81%E5%84%BF%E7%9A%84%E5%86%85%E5%AD%98%E5%B0%B1%E6%B3%84%E6%BC%8F%E4%BA%86/</link>
      <pubDate>Sat, 09 Sep 2023 11:05:16 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%86%B7%E4%B8%8D%E4%B8%81%E5%84%BF%E7%9A%84%E5%86%85%E5%AD%98%E5%B0%B1%E6%B3%84%E6%BC%8F%E4%BA%86/</guid>
      <description>在 C++ 编程中，内存泄漏是一个经常遇到的重大问题，特别是在涉及动态内存管理的场景中。如果程序在分配内存后没有及时释放，可能导致系统内存逐渐被耗尽</description>
    </item>
    <item>
      <title>CPP模板参数推导与显示指定的原理及应用场景</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC%E4%B8%8E%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Thu, 31 Aug 2023 21:42:05 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC%E4%B8%8E%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>C++ 的模板机制是其强大功能的核心之一，它允许编写通用的代码，并根据不同的类型进行实例化。然而，C++ 中的模板使用过程中，有时我们可以依赖编译器</description>
    </item>
    <item>
      <title>Return、exit、_exit以及_Exit</title>
      <link>https://oheyu.github.io/zh/posts/tech/returnexit_exit%E4%BB%A5%E5%8F%8A_exit/</link>
      <pubDate>Sun, 27 Aug 2023 21:20:55 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/returnexit_exit%E4%BB%A5%E5%8F%8A_exit/</guid>
      <description>在 C 和 C++ 编程中，return、exit()、_exit() 以及 _Exit() 都可以用于终止程序或函数的执行，但它们的行为、作用范围以及对资源的处理方式存</description>
    </item>
    <item>
      <title>CPP中的拷贝构造函数与赋值构造函数</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 23 Aug 2023 21:00:18 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid>
      <description>在 C++ 中，拷贝构造函数和赋值构造函数是管理对象复制行为的两个核心机制。它们的正确实现对于保障程序的健壮性与资源管理的正确性至关重要。 一、拷贝构</description>
    </item>
    <item>
      <title>静态库与动态库</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Wed, 23 Aug 2023 20:47:58 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>在 C++ 开发中，库文件是用于封装可重用代码的文件，帮助开发者在多个项目中共享和重用函数、类或数据结构。库文件主要分为两类：静态库（Static L</description>
    </item>
    <item>
      <title>CPP中的静态成员函数与普通成员函数</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 21 Aug 2023 20:25:34 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</guid>
      <description>在 C++ 面向对象编程中，类是封装数据和行为的核心概念。类的成员函数分为普通成员函数和静态成员函数两类，它们在访问方式、功能、以及使用场景上有着显</description>
    </item>
    <item>
      <title>CPP中的互斥锁：概念、实现与使用技巧</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E6%A6%82%E5%BF%B5%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 17 Aug 2023 19:46:48 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E6%A6%82%E5%BF%B5%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description>在并发编程中，互斥锁（Mutex）是保证多个线程或进程访问共享资源时数据一致性的重要同步机制。它通过限制同时访问某段代码的线程数，避免数据竞</description>
    </item>
    <item>
      <title>函数调用栈</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</link>
      <pubDate>Wed, 16 Aug 2023 19:29:32 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</guid>
      <description>在 C++ 编程中，函数调用栈是管理函数调用和返回的核心机制，它帮助程序高效管理函数的执行流程，包括参数传递、局部变量的存储和函数返回的控制。理解函</description>
    </item>
    <item>
      <title>CPP中共享内存的使用：为啥要避免string对象</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%BA%E5%95%A5%E8%A6%81%E9%81%BF%E5%85%8Dstring%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Tue, 15 Aug 2023 17:09:57 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%BA%E5%95%A5%E8%A6%81%E9%81%BF%E5%85%8Dstring%E5%AF%B9%E8%B1%A1/</guid>
      <description>在多进程编程中，共享内存是一种常用的进程间通信机制，允许多个进程访问同一块物理内存。这种方式不仅能够提高效率，还可以减少数据在进程间拷贝的开</description>
    </item>
    <item>
      <title>CPP中的仿函数（Functors）</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0functors/</link>
      <pubDate>Sun, 13 Aug 2023 16:59:30 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0functors/</guid>
      <description>在 C++ 编程中，仿函数（Function Objects, Functors）是一种强大的工具，它不仅可以像普通函数那样调用，还可以携带状态、使用类的继承和多态来</description>
    </item>
    <item>
      <title>CPP中结构体的内存管理：sizeof与memset的使用陷阱</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86sizeof%E4%B8%8Ememset%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1/</link>
      <pubDate>Fri, 11 Aug 2023 16:37:46 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86sizeof%E4%B8%8Ememset%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1/</guid>
      <description>在 C++ 编程中，结构体（struct）是一种常用的数据结构，尤其是在需要组织和管理多个相关数据时。然而，当结构体中包含指向动态分配内存的指针时，</description>
    </item>
    <item>
      <title>CPP中执行外部程序</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Tue, 08 Aug 2023 16:27:36 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</guid>
      <description>在 C++ 开发中，执行外部程序（如二进制文件、系统命令或 Shell 脚本）是一个常见的需求，尤其是在 Linux 系统中。C++ 提供了多种方式来实现这一功能，其中最常用</description>
    </item>
    <item>
      <title>全局变量与静态变量</title>
      <link>https://oheyu.github.io/zh/posts/tech/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 07 Aug 2023 11:14:55 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</guid>
      <description>在 C++ 开发中，全局变量和静态变量的使用是一个常见且重要的话题。虽然它们有着各自独特的特性，但在实际项目中，合理运用这些变量可以帮助我们提高代码</description>
    </item>
    <item>
      <title>CPP内存模型</title>
      <link>https://oheyu.github.io/zh/posts/tech/cpp%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 05 Aug 2023 10:37:41 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/cpp%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>内存，也就是我们常说的内存条，是计算机系统中至关重要的组成部分，它不仅用于存储程序的代码和数据，还负责数据的快速访问和处理。计算机内部以字节</description>
    </item>
    <item>
      <title>Free与malloc以及new与delete</title>
      <link>https://oheyu.github.io/zh/posts/tech/free%E4%B8%8Emalloc%E4%BB%A5%E5%8F%8Anew%E4%B8%8Edelete/</link>
      <pubDate>Sat, 05 Aug 2023 09:22:41 +0800</pubDate>
      <guid>https://oheyu.github.io/zh/posts/tech/free%E4%B8%8Emalloc%E4%BB%A5%E5%8F%8Anew%E4%B8%8Edelete/</guid>
      <description>在 C/C++ 中，new/delete 与 malloc/free 的使用涉及内存分配和释放的机制，虽然它们的功能表面上类似，但在使用上存在许多本质上的区别，使用时务必配对使用</description>
    </item>
  </channel>
</rss>
